// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Output strategy pattern for different fusion formats
 */
import { createWriteStream, type WriteStream } from 'node:fs';
import path from 'node:path';
import GithubSlugger from 'github-slugger';
import type { FileSystemAdapter } from '../adapters/file-system.js';
import type { CancellationToken } from '../api.js';
import { type Config, type FilePath, createFilePath } from '../types.js';
import { formatLocalTimestamp, getMarkdownLanguage } from '../utils.js';

export interface FileInfo {
    content: string;
    relativePath: string;
    path: FilePath;
    size: number;
    isErrorPlaceholder?: boolean;
}

export interface OutputContext {
    projectTitle: string;
    versionInfo: string;
    filesToProcess: FileInfo[];
    config: Config;
    toolVersion?: string;
}

export interface OutputStrategy {
    readonly name: string;
    readonly extension: string;
    generateHeader(context: OutputContext): string;
    processFile(fileInfo: FileInfo, context: OutputContext): string;
    generateFooter?(context: OutputContext): string;
    createStream(outputPath: FilePath): WriteStream;
}

// Pre-create replacement map for better performance
const HTML_ESCAPE_MAP = new Map([
    ['&', '&amp;'],   // Must be first to avoid double-escaping
    ['<', '&lt;'],
    ['>', '&gt;'],
    ['"', '&quot;'],
    ["'", '&#39;'],
    ['/', '&#47;'],    // Prevent closing tags in attributes
    ['`', '&#96;'],    // Prevent JS template literals
    ['=', '&#61;'],    // Prevent attribute injection
    ['!', '&#33;'],    // Prevent comment injection
    ['@', '&#64;'],    // Prevent CSS injection
    ['$', '&#36;'],    // Prevent template variable injection
    ['%', '&#37;'],    // Prevent URL encoding issues
    ['(', '&#40;'],    // Prevent JS execution
    [')', '&#41;'],    // Prevent JS execution
    ['+', '&#43;'],    // Prevent URL encoding issues
    ['{', '&#123;'],   // Prevent template injection
    ['}', '&#125;'],   // Prevent template injection
    ['[', '&#91;'],    // Prevent array notation
    [']', '&#93;']     // Prevent array notation
]);

// Pre-compile regex for better performance
const HTML_ESCAPE_REGEX = /[!"$%&'()+/<=>@[\]`{}]/g;

function escapeHtml(text: string): string {
    // Enhanced HTML escaping for maximum security using optimized regex replacement
    return text.replaceAll(HTML_ESCAPE_REGEX, (char) => HTML_ESCAPE_MAP.get(char) ?? char);
}

export class TextOutputStrategy implements OutputStrategy {
    readonly name = 'text';
    readonly extension = '.txt';

    generateHeader(context: OutputContext): string {
        const toolVersionInfo = context.toolVersion ? ` v${context.toolVersion}` : '';
        return `# Generated Project Fusion File
# Project: ${context.projectTitle}${context.versionInfo}
# Generated: ${formatLocalTimestamp()}
# Files: ${context.filesToProcess.length}
# Generated by: project-fusion${toolVersionInfo}
# GitHub: https://github.com/the99studio/project-fusion

`;
    }

    processFile(fileInfo: FileInfo, context: OutputContext): string {
        const headerPrefix = fileInfo.isErrorPlaceholder ? 'ERROR' : 'FILE';
        
        let processedContent = fileInfo.content;
        
        if (context.config.aggressiveContentSanitization) {
            processedContent = aggressiveContentSanitization(processedContent);
        }
        
        return `<!-- ============================================================ -->
<!-- ${headerPrefix}: ${fileInfo.relativePath.padEnd(54 - headerPrefix.length + 4)} -->
<!-- ============================================================ -->
${processedContent}

`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath, { encoding: 'utf8' });
    }
}

// Pre-compile markdown escape regex for better performance - simplified to avoid polynomial complexity
const MARKDOWN_ESCAPE_REGEX = /[()[\\\]`]/g;
const MARKDOWN_ESCAPE_MAP = new Map([
    ['[', '\\['],
    [']', '\\]'],
    ['(', '\\('],
    [')', '\\)'],
    ['`', '\\`']
]);

function escapeMarkdown(text: string): string {
    // Escape special Markdown characters that could create malicious links
    // Focus on filename context - these characters could be used for link injection
    return text.replaceAll(MARKDOWN_ESCAPE_REGEX, (char) => MARKDOWN_ESCAPE_MAP.get(char) ?? char);
}

function sanitizeMarkdownContent(content: string): string {
    // Detect and neutralize dangerous protocols in markdown content - optimized to prevent ReDoS
    const dangerousProtocols = /\b(?:javascript|data|vbscript):/gi;
    
    // Use split/join approach to avoid potential ReDoS with global regex
    if (dangerousProtocols.test(content)) {
        // Reset regex lastIndex to avoid state issues
        dangerousProtocols.lastIndex = 0;
        return content.replaceAll(dangerousProtocols, (match) => {
            const protocol = match.toLowerCase().slice(0, -1);
            return `[BLOCKED-${protocol.toUpperCase()}]:`;
        });
    }
    
    return content;
}

function validateHtmlHref(href: string): string {
    // Validate internal anchor links to prevent injection
    if (href.startsWith('#')) {
        // Remove the # prefix for validation
        const slug = href.slice(1);
        
        // Allow only alphanumeric, dash, underscore characters in slugs - non-greedy pattern
        const validSlugPattern = /^[\w-]+$/;
        
        if (!validSlugPattern.test(slug)) {
            // Replace invalid characters with safe alternatives - avoid greedy patterns
            const sanitizedSlug = slug
                .replaceAll(/[^\w-]/g, '-')      // Non-global to prevent ReDoS
                .replaceAll(/-+/g, '-')          // Simplified pattern
                .replace(/^-+/, '')              // Remove leading dashes
                .replace(/-+$/, '');             // Remove trailing dashes
            
            return `#${sanitizedSlug}`;
        }
    }
    
    // For non-anchor links, use simple string checks instead of regex
    const lowerHref = href.toLowerCase();
    if (lowerHref.includes('javascript:') || lowerHref.includes('data:') || lowerHref.includes('vbscript:')) {
        return '#blocked-dangerous-protocol';
    }
    
    return href;
}

function aggressiveContentSanitization(content: string): string {
    // For highly sensitive environments, perform aggressive sanitization
    // This removes or neutralizes potentially dangerous content patterns
    // All regex patterns optimized to prevent ReDoS attacks
    
    let sanitized = content;
    
    // 1. Remove script blocks completely - safe string-based approach
    while (sanitized.includes('<script') || sanitized.includes('</script>')) {
        sanitized = sanitized.replaceAll(/<script\b[^>]*>/gi, '[REMOVED: SCRIPT BLOCK]');
        sanitized = sanitized.replaceAll(/<\/script>/gi, '');
    }
    sanitized = sanitized.replaceAll(/on\w{1,20}\s*=\s*["'][^"']{0,200}["']/gi, '[REMOVED: EVENT HANDLER]');
    
    // 2. Remove dangerous HTML elements - safe string-based approach
    // Use literal regex patterns to avoid dynamic RegExp constructor
    sanitized = sanitized.replaceAll(/<iframe\b[^>]*>/gi, '[REMOVED: IFRAME]');
    sanitized = sanitized.replaceAll(/<\/iframe>/gi, '');
    sanitized = sanitized.replaceAll(/<object\b[^>]*>/gi, '[REMOVED: OBJECT]');
    sanitized = sanitized.replaceAll(/<\/object>/gi, '');
    sanitized = sanitized.replaceAll(/<embed\b[^>]*\/?>/gi, '[REMOVED: EMBED]');
    sanitized = sanitized.replaceAll(/<\/embed>/gi, '');
    sanitized = sanitized.replaceAll(/<form\b[^>]*>/gi, '[REMOVED: FORM]');
    sanitized = sanitized.replaceAll(/<\/form>/gi, '');
    
    // 3. Remove dangerous CSS patterns - bounded
    sanitized = sanitized.replaceAll(/expression\s*\([^)]{0,200}\)/gi, '[REMOVED: CSS EXPRESSION]');
    sanitized = sanitized.replaceAll(/@import\s+[^;]{0,200};?/gi, '[REMOVED: CSS IMPORT]');
    sanitized = sanitized.replaceAll(/behavior\s*:[^;]{0,200};?/gi, '[REMOVED: CSS BEHAVIOR]');
    
    // 4. Neutralize protocols - simple string replacement for safety
    sanitized = sanitized.replaceAll(/data:[^,]{0,100},[^\s"']{0,500}/gi, '[REMOVED: DATA URL]');
    sanitized = sanitized.replaceAll(/javascript:[^\s"']{0,200}/gi, '[REMOVED: JAVASCRIPT PROTOCOL]');
    sanitized = sanitized.replaceAll(/vbscript:[^\s"']{0,200}/gi, '[REMOVED: VBSCRIPT PROTOCOL]');
    
    // 5. Remove eval patterns - bounded word boundaries
    sanitized = sanitized.replaceAll(/\b(?:eval|function|settimeout|setinterval)\s*\([^)]{0,100}\)/gi, '[REMOVED: EVAL-LIKE FUNCTION]');
    
    // 6. Template literals - bounded and non-greedy
    sanitized = sanitized.replaceAll(/`[^`]{0,500}`/g, '[REMOVED: TEMPLATE LITERAL]');
    
    // 7. SQL patterns - word boundary, bounded
    sanitized = sanitized.replaceAll(/\b(?:drop|delete|update|insert|create|alter)\s+\w{1,50}/gi, '[REMOVED: SQL-LIKE COMMAND]');
    
    // 8. Path traversal - simple pattern
    sanitized = sanitized.replaceAll(/\.\.[/\\]/g, '[REMOVED: PATH TRAVERSAL]');
    
    // 9. File protocol - simple bounded pattern
    sanitized = sanitized.replaceAll(/file:\/\/[^\s"']{0,200}/gi, '[REMOVED: FILE PROTOCOL]');
    
    return sanitized;
}

export class MarkdownOutputStrategy implements OutputStrategy {
    readonly name = 'markdown';
    readonly extension = '.md';
    private readonly slugger = new GithubSlugger();

    generateHeader(context: OutputContext): string {
        // Reset slugger for each new document to ensure consistent anchors
        this.slugger.reset();
        const tocEntries = context.filesToProcess
            .map(fileInfo => `- [${escapeMarkdown(fileInfo.relativePath)}](#${this.slugger.slug(fileInfo.relativePath)})`)
            .join('\n');
        // Reset again so processFile generates same anchors
        this.slugger.reset();

        return `# Generated Project Fusion File

**Project:** ${context.projectTitle}${context.versionInfo}

**Generated:** ${formatLocalTimestamp()}

**Files:** ${context.filesToProcess.length}

**Generated by:** [project-fusion${context.toolVersion ? ` v${context.toolVersion}` : ''}](https://github.com/the99studio/project-fusion)

---

## Table of Contents

${tocEntries}

---

`;
    }

    processFile(fileInfo: FileInfo, context: OutputContext): string {
        const anchor = this.slugger.slug(fileInfo.relativePath);
        let processedContent = fileInfo.content;
        
        if (context.config.aggressiveContentSanitization) {
            processedContent = aggressiveContentSanitization(processedContent);
        }
        
        processedContent = sanitizeMarkdownContent(processedContent);
        
        if (fileInfo.isErrorPlaceholder) {
            // For error placeholders, display without code block
            return `## Error: ${escapeMarkdown(fileInfo.relativePath)} {#${anchor}}

> **Content Validation Error**

${processedContent}

`;
        }
        
        const fileExt = path.extname(fileInfo.path).toLowerCase();
        const basename = path.basename(fileInfo.path);
        const language = getMarkdownLanguage(fileExt || basename);

        return `## ${escapeMarkdown(fileInfo.relativePath)} {#${anchor}}

\`\`\`${language}
${processedContent}
\`\`\`

`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath, { encoding: 'utf8' });
    }
}

export class HtmlOutputStrategy implements OutputStrategy {
    readonly name = 'html';
    readonly extension = '.html';
    private readonly slugger = new GithubSlugger();

    generateHeader(context: OutputContext): string {
        // Reset slugger for each new document to ensure consistent anchors
        this.slugger.reset();
        const tocEntries = context.filesToProcess
            .map(fileInfo => {
                const slug = this.slugger.slug(fileInfo.relativePath);
                const validatedHref = validateHtmlHref(`#${slug}`);
                return `<li><a href="${validatedHref}">${escapeHtml(fileInfo.relativePath)}</a></li>`;
            })
            .join('\n');
        // Reset again so processFile generates same anchors
        this.slugger.reset();

        // Simplified, portable HTML5 with minimal CSS
        return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline'; font-src 'self'; base-uri 'none'">
<meta http-equiv="X-Content-Type-Options" content="nosniff">
<meta http-equiv="X-Frame-Options" content="DENY">
<meta http-equiv="Referrer-Policy" content="no-referrer">
<title>${escapeHtml(context.projectTitle)}${escapeHtml(context.versionInfo)} - Project Fusion</title>
<style>
body{font-family:monospace;margin:20px;line-height:1.6;color:#000;background:#fff}
pre{background:#f5f5f5;border:1px solid #ccc;padding:10px;overflow-x:auto;white-space:pre}
h1,h2{margin-top:20px}
ul{padding-left:20px}
a{color:#00e;text-decoration:underline}
.error{background:#fee;border:1px solid #c00;padding:10px}
</style>
</head>
<body>
<h1>Project Fusion Output</h1>
<p><strong>Project:</strong> ${escapeHtml(context.projectTitle)}${escapeHtml(context.versionInfo)}</p>
<p><strong>Generated:</strong> ${escapeHtml(formatLocalTimestamp())}</p>
<p><strong>Files:</strong> ${context.filesToProcess.length}</p>
<p><strong>Created with:</strong> <a href="https://github.com/the99studio/project-fusion" target="_blank" rel="noopener noreferrer">project-fusion${context.toolVersion ? ` v${context.toolVersion}` : ''}</a></p>
<hr>
<h2>Table of Contents</h2>
<ul>
${tocEntries}
</ul>
<hr>
`;
    }

    processFile(fileInfo: FileInfo, context: OutputContext): string {
        const fileAnchor = this.slugger.slug(fileInfo.relativePath);
        const validatedAnchor = validateHtmlHref(`#${fileAnchor}`).slice(1); // Remove # for id attribute
        const escapedPath = escapeHtml(fileInfo.relativePath);
        
        let processedContent = fileInfo.content;
        
        if (context.config.aggressiveContentSanitization) {
            processedContent = aggressiveContentSanitization(processedContent);
        }
        
        const escapedContent = escapeHtml(processedContent);
        
        if (fileInfo.isErrorPlaceholder) {
            // Simple error display
            return `<h2 id="${validatedAnchor}">ERROR: ${escapedPath}</h2>
<pre class="error">${escapedContent}</pre>
`;
        }
        
        // Simple file display
        return `<h2 id="${validatedAnchor}">${escapedPath}</h2>
<pre>${escapedContent}</pre>
`;
    }

    generateFooter(): string {
        return `</body>
</html>`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath, { encoding: 'utf8' });
    }
}

export class OutputStrategyManager {
    private readonly strategies: Map<string, OutputStrategy> = new Map();

    constructor() {
        this.registerStrategy(new TextOutputStrategy());
        this.registerStrategy(new MarkdownOutputStrategy());
        this.registerStrategy(new HtmlOutputStrategy());
    }

    registerStrategy(strategy: OutputStrategy): void {
        this.strategies.set(strategy.name, strategy);
    }

    getStrategy(name: string): OutputStrategy | undefined {
        return this.strategies.get(name);
    }

    getEnabledStrategies(config: Config): OutputStrategy[] {
        const enabled: OutputStrategy[] = [];
        
        if (config.generateText) {
            const strategy = this.getStrategy('text');
            if (strategy) { enabled.push(strategy); }
        }
        
        if (config.generateMarkdown) {
            const strategy = this.getStrategy('markdown');
            if (strategy) { enabled.push(strategy); }
        }
        
        if (config.generateHtml) {
            const strategy = this.getStrategy('html');
            if (strategy) { enabled.push(strategy); }
        }
        
        return enabled;
    }

    getOutputPath(strategy: OutputStrategy, config: Config): FilePath {
        const outputDir = config.outputDirectory ?? config.rootDirectory;
        return createFilePath(path.resolve(outputDir, `${config.generatedFileName}${strategy.extension}`));
    }

    async generateOutput(
        strategy: OutputStrategy, 
        context: OutputContext, 
        fs: FileSystemAdapter,
        onFileProcessed?: (fileInfo: FileInfo, index: number, total: number) => void,
        cancellationToken?: CancellationToken
    ): Promise<FilePath> {
        const outputPath = this.getOutputPath(strategy, context.config);
        
        await fs.ensureDir(path.dirname(outputPath));
        
        const isMemoryFS = fs.constructor.name === 'MemoryFileSystemAdapter';
        
        if (isMemoryFS) {
            // For memory file system, build content in memory and write at once
            let content = strategy.generateHeader(context);
            const maxOutputBytes = (context.config.maxOutputSizeMB ?? 50) * 1024 * 1024;
            
            for (let i = 0; i < context.filesToProcess.length; i++) {
                // Check for cancellation
                if (cancellationToken?.isCancellationRequested) {
                    throw new Error('Operation was cancelled');
                }
                
                const fileInfo = context.filesToProcess[i];
                if (fileInfo) {
                    const fileContent = strategy.processFile(fileInfo, context);
                    
                    // Check output size limit to prevent DoS
                    if (Buffer.byteLength(content + fileContent, 'utf8') > maxOutputBytes) {
                        const limitMB = context.config.maxOutputSizeMB ?? 50;
                        const errorMsg = `Output size would exceed maximum limit of ${limitMB}MB. Consider increasing maxOutputSizeMB in config or reducing file count.`;
                        throw new Error(errorMsg);
                    }
                    
                    content += fileContent;
                    if (onFileProcessed) {
                        onFileProcessed(fileInfo, i, context.filesToProcess.length);
                    }
                }
            }
            
            if (strategy.generateFooter) {
                const footer = strategy.generateFooter(context);
                if (Buffer.byteLength(content + footer, 'utf8') > maxOutputBytes) {
                    const limitMB = context.config.maxOutputSizeMB ?? 50;
                    const errorMsg = `Output size would exceed maximum limit of ${limitMB}MB. Consider increasing maxOutputSizeMB in config.`;
                    throw new Error(errorMsg);
                }
                content += footer;
            }
            
            await fs.writeFile(outputPath, content);
            return outputPath;
        }
        
        // For real file system, use streaming
        const outputStream = strategy.createStream(outputPath);
        let streamClosed = false;
        let totalBytesWritten = 0;
        const maxOutputBytes = (context.config.maxOutputSizeMB ?? 50) * 1024 * 1024;
        
        // Helper to safely close the stream
        const closeStream = (): void => {
            if (!streamClosed) {
                streamClosed = true;
                outputStream.destroy();
            }
        };
        
        // Helper to check size limits before writing
        const checkSizeLimit = (content: string): void => {
            const contentBytes = Buffer.byteLength(content, 'utf8');
            if (totalBytesWritten + contentBytes > maxOutputBytes) {
                const limitMB = context.config.maxOutputSizeMB ?? 50;
                const errorMsg = `Output size would exceed maximum limit of ${limitMB}MB. Consider increasing maxOutputSizeMB in config or reducing file count.`;
                throw new Error(errorMsg);
            }
        };
        
        return new Promise<FilePath>((resolve, reject) => {
            let filesWritten = 0;
            
            outputStream.on('error', (err) => {
                closeStream();
                reject(err);
            });
            
            outputStream.on('finish', () => {
                streamClosed = true;
                resolve(outputPath);
            });
            
            let headerWritten = false;
            
            // Process files with backpressure handling
            const processNextFile = (): void => {
                // Check for cancellation
                if (cancellationToken?.isCancellationRequested) {
                    closeStream();
                    reject(new Error('Operation was cancelled'));
                    return;
                }
                // Write header first if not yet written
                if (!headerWritten) {
                    headerWritten = true;
                    const header = strategy.generateHeader(context);
                    
                    try {
                        checkSizeLimit(header);
                    } catch (error) {
                        closeStream();
                        reject(error instanceof Error ? error : new Error(String(error)));
                        return;
                    }
                    
                    totalBytesWritten += Buffer.byteLength(header, 'utf8');
                    
                    if (!outputStream.write(header)) {
                        // Header caused backpressure, wait for drain
                        outputStream.once('drain', processNextFile);
                        return;
                    }
                    // Header written successfully, continue processing
                }
                
                if (filesWritten >= context.filesToProcess.length) {
                    // All files processed, write footer and end
                    if (strategy.generateFooter) {
                        const footer = strategy.generateFooter(context);
                        
                        try {
                            checkSizeLimit(footer);
                        } catch (error) {
                            closeStream();
                            reject(error instanceof Error ? error : new Error(String(error)));
                            return;
                        }
                        
                        totalBytesWritten += Buffer.byteLength(footer, 'utf8');
                        
                        if (!outputStream.write(footer)) {
                            // Footer caused backpressure, wait for drain before ending
                            outputStream.once('drain', () => {
                                outputStream.end();
                            });
                            return;
                        }
                    }
                    outputStream.end();
                    return;
                }
                
                const fileInfo = context.filesToProcess[filesWritten];
                if (!fileInfo) {
                    // Shouldn't happen but handle gracefully
                    processNextFile();
                    return;
                }
                
                const fileContent = strategy.processFile(fileInfo, context);
                
                // Check size limit for the file content
                try {
                    checkSizeLimit(fileContent);
                } catch (error) {
                    closeStream();
                    reject(error instanceof Error ? error : new Error(String(error)));
                    return;
                }
                
                // Report progress
                if (onFileProcessed) {
                    onFileProcessed(fileInfo, filesWritten, context.filesToProcess.length);
                }
                
                filesWritten++;
                
                // Write file content with backpressure handling - optimized chunking
                const CHUNK_SIZE = 65_536; // 64KB chunks
                const contentByteLength = Buffer.byteLength(fileContent, 'utf8');
                totalBytesWritten += contentByteLength;
                
                if (fileContent.length > CHUNK_SIZE) {
                    // For large content, write in chunks with optimized slicing
                    let offset = 0;
                    
                    const writeNextChunk = (): void => {
                        // Check for cancellation during chunk writing
                        if (cancellationToken?.isCancellationRequested) {
                            closeStream();
                            reject(new Error('Operation was cancelled'));
                            return;
                        }
                        
                        if (offset >= fileContent.length) {
                            // Move to next file
                            processNextFile();
                            return;
                        }
                        
                        const nextOffset = Math.min(offset + CHUNK_SIZE, fileContent.length);
                        const chunk = fileContent.slice(offset, nextOffset);
                        offset = nextOffset;
                        
                        if (!outputStream.write(chunk)) {
                            // Wait for drain event before continuing
                            outputStream.once('drain', writeNextChunk);
                        } else if (offset < fileContent.length) {
                            // Continue immediately - use setTimeout for better performance than setImmediate
                            setTimeout(writeNextChunk, 0);
                        } else {
                            processNextFile();
                        }
                    };
                    
                    writeNextChunk();
                } else if (!outputStream.write(fileContent)) {
                    // Wait for drain event before continuing
                    outputStream.once('drain', processNextFile);
                } else {
                    // Continue with next file
                    setImmediate(processNextFile);
                }
            };
            
            // Start processing files
            processNextFile();
        });
    }
}