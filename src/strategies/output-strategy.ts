// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Output strategy pattern for different fusion formats
 */
import { createWriteStream, type WriteStream } from 'node:fs';
import path from 'node:path';
import GithubSlugger from 'github-slugger';
import type { FileSystemAdapter } from '../adapters/file-system.js';
import type { CancellationToken } from '../api.js';
import { type Config, type FilePath, createFilePath } from '../types.js';
import { formatLocalTimestamp, formatTimestamp, getMarkdownLanguage } from '../utils.js';

export interface FileInfo {
    content: string;
    relativePath: string;
    path: FilePath;
    size: number;
    isErrorPlaceholder?: boolean;
}

export interface OutputContext {
    projectTitle: string;
    versionInfo: string;
    filesToProcess: FileInfo[];
    config: Config;
    toolVersion?: string;
}

export interface OutputStrategy {
    readonly name: string;
    readonly extension: string;
    generateHeader(context: OutputContext): string;
    processFile(fileInfo: FileInfo, context: OutputContext): string;
    generateFooter?(context: OutputContext): string;
    createStream(outputPath: FilePath): WriteStream;
}

function escapeHtml(text: string): string {
    // Enhanced HTML escaping for maximum security
    // Escape all potentially dangerous characters
    return text
        .replaceAll('&', '&amp;')   // Must be first to avoid double-escaping
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;')
        .replaceAll('/', '&#47;')    // Prevent closing tags in attributes
        .replaceAll('`', '&#96;')    // Prevent JS template literals
        .replaceAll('=', '&#61;')    // Prevent attribute injection
        .replaceAll('!', '&#33;')    // Prevent comment injection
        .replaceAll('@', '&#64;')    // Prevent CSS injection
        .replaceAll('$', '&#36;')    // Prevent template variable injection
        .replaceAll('%', '&#37;')    // Prevent URL encoding issues
        .replaceAll('(', '&#40;')    // Prevent JS execution
        .replaceAll(')', '&#41;')    // Prevent JS execution
        .replaceAll('+', '&#43;')    // Prevent URL encoding issues
        .replaceAll('{', '&#123;')   // Prevent template injection
        .replaceAll('}', '&#125;')   // Prevent template injection
        .replaceAll('[', '&#91;')    // Prevent array notation
        .replaceAll(']', '&#93;');   // Prevent array notation
}

export class TextOutputStrategy implements OutputStrategy {
    readonly name = 'text';
    readonly extension = '.txt';

    generateHeader(context: OutputContext): string {
        const toolVersionInfo = context.toolVersion ? ` v${context.toolVersion}` : '';
        return `# Generated Project Fusion File
# Project: ${context.projectTitle}${context.versionInfo}
# Generated: ${formatLocalTimestamp()}
# UTC: ${formatTimestamp()}
# Files: ${context.filesToProcess.length}
# Generated by: project-fusion${toolVersionInfo} (https://github.com/the99studio/project-fusion)

`;
    }

    processFile(fileInfo: FileInfo): string {
        const headerPrefix = fileInfo.isErrorPlaceholder ? 'ERROR' : 'FILE';
        return `<!-- ============================================================ -->
<!-- ${headerPrefix}: ${fileInfo.relativePath.padEnd(54 - headerPrefix.length + 4)} -->
<!-- ============================================================ -->
${fileInfo.content}

`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath, { encoding: 'utf8' });
    }
}

export class MarkdownOutputStrategy implements OutputStrategy {
    readonly name = 'markdown';
    readonly extension = '.md';
    private readonly slugger = new GithubSlugger();

    generateHeader(context: OutputContext): string {
        // Reset slugger for each new document to ensure consistent anchors
        this.slugger.reset();
        const tocEntries = context.filesToProcess
            .map(fileInfo => `- [${fileInfo.relativePath}](#${this.slugger.slug(fileInfo.relativePath)})`)
            .join('\n');
        // Reset again so processFile generates same anchors
        this.slugger.reset();

        return `# Generated Project Fusion File

**Project:** ${context.projectTitle}${context.versionInfo}

**Generated:** ${formatLocalTimestamp()}

**UTC:** ${formatTimestamp()}

**Files:** ${context.filesToProcess.length}

**Generated by:** [project-fusion${context.toolVersion ? ` v${context.toolVersion}` : ''}](https://github.com/the99studio/project-fusion)

---

## 📁 Table of Contents

${tocEntries}

---

`;
    }

    processFile(fileInfo: FileInfo): string {
        const anchor = this.slugger.slug(fileInfo.relativePath);
        if (fileInfo.isErrorPlaceholder) {
            // For error placeholders, display without code block
            return `## ⚠️ ${fileInfo.relativePath} {#${anchor}}

> **Content Validation Error**

${fileInfo.content}

`;
        }
        
        const fileExt = path.extname(fileInfo.path).toLowerCase();
        const basename = path.basename(fileInfo.path);
        const language = getMarkdownLanguage(fileExt || basename);

        return `## 📄 ${fileInfo.relativePath} {#${anchor}}

\`\`\`${language}
${fileInfo.content}
\`\`\`

`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath, { encoding: 'utf8' });
    }
}

export class HtmlOutputStrategy implements OutputStrategy {
    readonly name = 'html';
    readonly extension = '.html';
    private readonly slugger = new GithubSlugger();

    generateHeader(context: OutputContext): string {
        // Reset slugger for each new document to ensure consistent anchors
        this.slugger.reset();
        const tocEntries = context.filesToProcess
            .map(fileInfo => `<li><a href="#${this.slugger.slug(fileInfo.relativePath)}">${escapeHtml(fileInfo.relativePath)}</a></li>`)
            .join('\n');
        // Reset again so processFile generates same anchors
        this.slugger.reset();

        // Simplified, portable HTML5 with minimal CSS
        return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>${escapeHtml(context.projectTitle)}${escapeHtml(context.versionInfo)} - Project Fusion</title>
<style>
body{font-family:monospace;margin:20px;line-height:1.6;color:#000;background:#fff}
pre{background:#f5f5f5;border:1px solid #ccc;padding:10px;overflow-x:auto;white-space:pre}
h1,h2{margin-top:20px}
ul{padding-left:20px}
a{color:#00e;text-decoration:underline}
.error{background:#fee;border:1px solid #c00;padding:10px}
</style>
</head>
<body>
<h1>Project Fusion Output</h1>
<p><strong>Project:</strong> ${escapeHtml(context.projectTitle)}${escapeHtml(context.versionInfo)}</p>
<p><strong>Generated:</strong> ${escapeHtml(formatLocalTimestamp())}</p>
<p><strong>Files:</strong> ${context.filesToProcess.length}</p>
<hr>
<h2>Table of Contents</h2>
<ul>
${tocEntries}
</ul>
<hr>
`;
    }

    processFile(fileInfo: FileInfo): string {
        const fileAnchor = this.slugger.slug(fileInfo.relativePath);
        const escapedPath = escapeHtml(fileInfo.relativePath);
        const escapedContent = escapeHtml(fileInfo.content);
        
        if (fileInfo.isErrorPlaceholder) {
            // Simple error display
            return `<h2 id="${fileAnchor}">ERROR: ${escapedPath}</h2>
<pre class="error">${escapedContent}</pre>
`;
        }
        
        // Simple file display
        return `<h2 id="${fileAnchor}">${escapedPath}</h2>
<pre>${escapedContent}</pre>
`;
    }

    generateFooter(): string {
        return `</body>
</html>`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath, { encoding: 'utf8' });
    }
}

export class OutputStrategyManager {
    private readonly strategies: Map<string, OutputStrategy> = new Map();

    constructor() {
        this.registerStrategy(new TextOutputStrategy());
        this.registerStrategy(new MarkdownOutputStrategy());
        this.registerStrategy(new HtmlOutputStrategy());
    }

    registerStrategy(strategy: OutputStrategy): void {
        this.strategies.set(strategy.name, strategy);
    }

    getStrategy(name: string): OutputStrategy | undefined {
        return this.strategies.get(name);
    }

    getEnabledStrategies(config: Config): OutputStrategy[] {
        const enabled: OutputStrategy[] = [];
        
        if (config.generateText) {
            const strategy = this.getStrategy('text');
            if (strategy) { enabled.push(strategy); }
        }
        
        if (config.generateMarkdown) {
            const strategy = this.getStrategy('markdown');
            if (strategy) { enabled.push(strategy); }
        }
        
        if (config.generateHtml) {
            const strategy = this.getStrategy('html');
            if (strategy) { enabled.push(strategy); }
        }
        
        return enabled;
    }

    getOutputPath(strategy: OutputStrategy, config: Config): FilePath {
        const outputDir = config.outputDirectory ?? config.rootDirectory;
        return createFilePath(path.resolve(outputDir, `${config.generatedFileName}${strategy.extension}`));
    }

    async generateOutput(
        strategy: OutputStrategy, 
        context: OutputContext, 
        fs: FileSystemAdapter,
        onFileProcessed?: (fileInfo: FileInfo, index: number, total: number) => void,
        cancellationToken?: CancellationToken
    ): Promise<FilePath> {
        const outputPath = this.getOutputPath(strategy, context.config);
        
        await fs.ensureDir(path.dirname(outputPath));
        
        // Check if we're using a memory file system (for testing)
        const isMemoryFS = fs.constructor.name === 'MemoryFileSystemAdapter';
        
        if (isMemoryFS) {
            // For memory file system, build content in memory and write at once
            let content = strategy.generateHeader(context);
            
            for (let i = 0; i < context.filesToProcess.length; i++) {
                // Check for cancellation
                if (cancellationToken?.isCancellationRequested) {
                    throw new Error('Operation was cancelled');
                }
                
                const fileInfo = context.filesToProcess[i];
                if (fileInfo) {
                    content += strategy.processFile(fileInfo, context);
                    if (onFileProcessed) {
                        onFileProcessed(fileInfo, i, context.filesToProcess.length);
                    }
                }
            }
            
            if (strategy.generateFooter) {
                content += strategy.generateFooter(context);
            }
            
            await fs.writeFile(outputPath, content);
            return outputPath;
        }
        
        // For real file system, use streaming
        const outputStream = strategy.createStream(outputPath);
        let streamClosed = false;
        
        // Helper to safely close the stream
        const closeStream = (): void => {
            if (!streamClosed) {
                streamClosed = true;
                outputStream.destroy();
            }
        };
        
        return new Promise<FilePath>((resolve, reject) => {
            let filesWritten = 0;
            
            // Handle stream errors
            outputStream.on('error', (err) => {
                closeStream();
                reject(err);
            });
            
            // Handle stream finish
            outputStream.on('finish', () => {
                streamClosed = true;
                resolve(outputPath);
            });
            
            let headerWritten = false;
            
            // Process files with backpressure handling
            const processNextFile = (): void => {
                // Check for cancellation
                if (cancellationToken?.isCancellationRequested) {
                    closeStream();
                    reject(new Error('Operation was cancelled'));
                    return;
                }
                // Write header first if not yet written
                if (!headerWritten) {
                    headerWritten = true;
                    const header = strategy.generateHeader(context);
                    if (!outputStream.write(header)) {
                        // Header caused backpressure, wait for drain
                        outputStream.once('drain', processNextFile);
                        return;
                    }
                    // Header written successfully, continue processing
                }
                
                if (filesWritten >= context.filesToProcess.length) {
                    // All files processed, write footer and end
                    if (strategy.generateFooter) {
                        const footer = strategy.generateFooter(context);
                        if (!outputStream.write(footer)) {
                            // Footer caused backpressure, wait for drain before ending
                            outputStream.once('drain', () => {
                                outputStream.end();
                            });
                            return;
                        }
                    }
                    outputStream.end();
                    return;
                }
                
                const fileInfo = context.filesToProcess[filesWritten];
                if (!fileInfo) {
                    // Shouldn't happen but handle gracefully
                    processNextFile();
                    return;
                }
                
                const fileContent = strategy.processFile(fileInfo, context);
                
                // Report progress
                if (onFileProcessed) {
                    onFileProcessed(fileInfo, filesWritten, context.filesToProcess.length);
                }
                
                filesWritten++;
                
                // Write file content with backpressure handling
                if (fileContent.length > 65_536) {
                    // For large content, write in chunks
                    const chunkSize = 65_536; // 64KB chunks
                    let offset = 0;
                    
                    const writeNextChunk = (): void => {
                        // Check for cancellation during chunk writing
                        if (cancellationToken?.isCancellationRequested) {
                            closeStream();
                            reject(new Error('Operation was cancelled'));
                            return;
                        }
                        
                        if (offset >= fileContent.length) {
                            // Move to next file
                            processNextFile();
                            return;
                        }
                        
                        const chunk = fileContent.slice(offset, offset + chunkSize);
                        offset += chunkSize;
                        
                        if (!outputStream.write(chunk)) {
                            // Wait for drain event before continuing
                            outputStream.once('drain', writeNextChunk);
                        } else {
                            // Continue immediately
                            setImmediate(writeNextChunk);
                        }
                    };
                    
                    writeNextChunk();
                } else if (!outputStream.write(fileContent)) {
                    // Wait for drain event before continuing
                    outputStream.once('drain', processNextFile);
                } else {
                    // Continue with next file
                    setImmediate(processNextFile);
                }
            };
            
            // Start processing files
            processNextFile();
        });
    }
}