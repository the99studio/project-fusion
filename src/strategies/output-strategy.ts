// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Output strategy pattern for different fusion formats
 */
import { createWriteStream, type WriteStream } from 'node:fs';
import path from 'node:path';
import GithubSlugger from 'github-slugger';
import type { FileSystemAdapter } from '../adapters/file-system.js';
import type { CancellationToken } from '../api.js';
import { type Config, type FilePath, createFilePath } from '../types.js';
import { formatLocalTimestamp, formatTimestamp, getMarkdownLanguage } from '../utils.js';

export interface FileInfo {
    content: string;
    relativePath: string;
    path: FilePath;
    size: number;
    isErrorPlaceholder?: boolean;
}

export interface OutputContext {
    projectTitle: string;
    versionInfo: string;
    filesToProcess: FileInfo[];
    config: Config;
    toolVersion?: string;
}

export interface OutputStrategy {
    readonly name: string;
    readonly extension: string;
    generateHeader(context: OutputContext): string;
    processFile(fileInfo: FileInfo, context: OutputContext): string;
    generateFooter?(context: OutputContext): string;
    createStream(outputPath: FilePath): WriteStream;
}

function escapeHtml(text: string): string {
    // Enhanced HTML escaping for maximum security
    // Escape all potentially dangerous characters
    return text
        .replaceAll('&', '&amp;')   // Must be first to avoid double-escaping
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;')
        .replaceAll('/', '&#47;')    // Prevent closing tags in attributes
        .replaceAll('`', '&#96;')    // Prevent JS template literals
        .replaceAll('=', '&#61;')    // Prevent attribute injection
        .replaceAll('!', '&#33;')    // Prevent comment injection
        .replaceAll('@', '&#64;')    // Prevent CSS injection
        .replaceAll('$', '&#36;')    // Prevent template variable injection
        .replaceAll('%', '&#37;')    // Prevent URL encoding issues
        .replaceAll('(', '&#40;')    // Prevent JS execution
        .replaceAll(')', '&#41;')    // Prevent JS execution
        .replaceAll('+', '&#43;')    // Prevent URL encoding issues
        .replaceAll('{', '&#123;')   // Prevent template injection
        .replaceAll('}', '&#125;')   // Prevent template injection
        .replaceAll('[', '&#91;')    // Prevent array notation
        .replaceAll(']', '&#93;');   // Prevent array notation
}

export class TextOutputStrategy implements OutputStrategy {
    readonly name = 'text';
    readonly extension = '.txt';

    generateHeader(context: OutputContext): string {
        const toolVersionInfo = context.toolVersion ? ` v${context.toolVersion}` : '';
        return `# Generated Project Fusion File
# Project: ${context.projectTitle}${context.versionInfo}
# Generated: ${formatLocalTimestamp()}
# UTC: ${formatTimestamp()}
# Files: ${context.filesToProcess.length}
# Generated by: project-fusion${toolVersionInfo}
# GitHub: https://github.com/the99studio/project-fusion

`;
    }

    processFile(fileInfo: FileInfo, context: OutputContext): string {
        const headerPrefix = fileInfo.isErrorPlaceholder ? 'ERROR' : 'FILE';
        
        let processedContent = fileInfo.content;
        
        // Apply aggressive sanitization if enabled
        if (context.config.aggressiveContentSanitization) {
            processedContent = aggressiveContentSanitization(processedContent);
        }
        
        return `<!-- ============================================================ -->
<!-- ${headerPrefix}: ${fileInfo.relativePath.padEnd(54 - headerPrefix.length + 4)} -->
<!-- ============================================================ -->
${processedContent}

`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath, { encoding: 'utf8' });
    }
}

function escapeMarkdown(text: string): string {
    // Escape special Markdown characters that could create malicious links
    // Focus on filename context - these characters could be used for link injection
    return text
        .replaceAll('[', '\\[')      // Prevent link start
        .replaceAll(']', '\\]')      // Prevent link end
        .replaceAll('(', '\\(')      // Prevent URL start
        .replaceAll(')', '\\)')      // Prevent URL end
        .replaceAll('`', '\\`');     // Prevent code injection
}

function sanitizeMarkdownContent(content: string): string {
    // Detect and neutralize dangerous protocols in markdown content
    const dangerousProtocols = /\b(javascript|data|vbscript):/gi;
    
    if (dangerousProtocols.test(content)) {
        // Replace dangerous protocols with safe alternative
        return content.replaceAll(dangerousProtocols, (match) => {
            const protocol = match.toLowerCase().slice(0, -1); // Remove the ':'
            return `[BLOCKED-${protocol.toUpperCase()}]:`;
        });
    }
    
    return content;
}

function validateHtmlHref(href: string): string {
    // Validate internal anchor links to prevent injection
    if (href.startsWith('#')) {
        // Remove the # prefix for validation
        const slug = href.slice(1);
        
        // Allow only alphanumeric, dash, underscore characters in slugs
        // This matches GitHub slug format used by github-slugger
        const validSlugPattern = /^[\w-]+$/i;
        
        if (!validSlugPattern.test(slug)) {
            // Replace invalid characters with safe alternatives
            const sanitizedSlug = slug
                .replaceAll(/[^\w-]/gi, '-')     // Replace invalid chars with dashes
                .replaceAll(/-{2,}/g, '-')       // Collapse multiple dashes
                .replaceAll(/^-+|-+$/g, '');     // Remove leading/trailing dashes
            
            return `#${sanitizedSlug}`;
        }
    }
    
    // For non-anchor links, apply basic validation
    if (href.includes('javascript:') || href.includes('data:') || href.includes('vbscript:')) {
        return '#blocked-dangerous-protocol';
    }
    
    return href;
}

function aggressiveContentSanitization(content: string): string {
    // For highly sensitive environments, perform aggressive sanitization
    // This removes or neutralizes potentially dangerous content patterns
    
    let sanitized = content;
    
    // 1. Remove or neutralize script-like patterns
    sanitized = sanitized.replaceAll(/<script[\S\s]*?<\/script>/gi, '[REMOVED: SCRIPT BLOCK]');
    sanitized = sanitized.replaceAll(/on\w+\s*=\s*["'][^"']*["']/gi, '[REMOVED: EVENT HANDLER]');
    
    // 2. Neutralize dangerous HTML elements and attributes
    sanitized = sanitized.replaceAll(/<iframe[\S\s]*?(?:<\/iframe>|\/?>)/gi, '[REMOVED: IFRAME]');
    sanitized = sanitized.replaceAll(/<object[\S\s]*?(?:<\/object>|\/?>)/gi, '[REMOVED: OBJECT]');
    sanitized = sanitized.replaceAll(/<embed[\S\s]*?(?:<\/embed>|\/?>)/gi, '[REMOVED: EMBED]');
    sanitized = sanitized.replaceAll(/<form[\S\s]*?(?:<\/form>|\/?>)/gi, '[REMOVED: FORM]');
    
    // 3. Remove dangerous CSS patterns
    sanitized = sanitized.replaceAll(/expression\s*\(/gi, '[REMOVED: CSS EXPRESSION]');
    sanitized = sanitized.replaceAll(/@import\s+/gi, '[REMOVED: CSS IMPORT]');
    sanitized = sanitized.replaceAll(/behavior\s*:/gi, '[REMOVED: CSS BEHAVIOR]');
    
    // 4. Neutralize potential data URLs and javascript: protocols more aggressively
    sanitized = sanitized.replaceAll(/data:\s*[^;]*;[^,]*,/gi, '[REMOVED: DATA URL]');
    sanitized = sanitized.replaceAll(/javascript:\s*/gi, '[REMOVED: JAVASCRIPT PROTOCOL]');
    sanitized = sanitized.replaceAll(/vbscript:\s*/gi, '[REMOVED: VBSCRIPT PROTOCOL]');
    
    // 5. Remove potential JSONP callbacks and eval patterns
    sanitized = sanitized.replaceAll(/\b(eval|function|settimeout|setinterval)\s*\(/gi, '[REMOVED: EVAL-LIKE FUNCTION](');
    
    // 6. Neutralize template literal patterns that could be dangerous
    sanitized = sanitized.replaceAll(/`[^`]*\${[^}]*}[^`]*`/g, '[REMOVED: TEMPLATE LITERAL]');
    
    // 7. Remove potential SQL injection patterns (basic)
    sanitized = sanitized.replaceAll(/\b(drop|delete|update|insert|create|alter)\s+\w+/gi, '[REMOVED: SQL-LIKE COMMAND]');
    
    // 8. Neutralize potential path traversal patterns
    sanitized = sanitized.replaceAll(/\.\.[/\\]/g, '[REMOVED: PATH TRAVERSAL]');
    
    // 9. Remove potential file protocol URLs
    sanitized = sanitized.replaceAll(/file:\s*\/\//gi, '[REMOVED: FILE PROTOCOL]');
    
    return sanitized;
}

export class MarkdownOutputStrategy implements OutputStrategy {
    readonly name = 'markdown';
    readonly extension = '.md';
    private readonly slugger = new GithubSlugger();

    generateHeader(context: OutputContext): string {
        // Reset slugger for each new document to ensure consistent anchors
        this.slugger.reset();
        const tocEntries = context.filesToProcess
            .map(fileInfo => `- [${escapeMarkdown(fileInfo.relativePath)}](#${this.slugger.slug(fileInfo.relativePath)})`)
            .join('\n');
        // Reset again so processFile generates same anchors
        this.slugger.reset();

        return `# Generated Project Fusion File

**Project:** ${context.projectTitle}${context.versionInfo}

**Generated:** ${formatLocalTimestamp()}

**UTC:** ${formatTimestamp()}

**Files:** ${context.filesToProcess.length}

**Generated by:** [project-fusion${context.toolVersion ? ` v${context.toolVersion}` : ''}](https://github.com/the99studio/project-fusion)

---

## üìÅ Table of Contents

${tocEntries}

---

`;
    }

    processFile(fileInfo: FileInfo, context: OutputContext): string {
        const anchor = this.slugger.slug(fileInfo.relativePath);
        let processedContent = fileInfo.content;
        
        // Apply aggressive sanitization if enabled
        if (context.config.aggressiveContentSanitization) {
            processedContent = aggressiveContentSanitization(processedContent);
        }
        
        // Always apply basic markdown sanitization
        processedContent = sanitizeMarkdownContent(processedContent);
        
        if (fileInfo.isErrorPlaceholder) {
            // For error placeholders, display without code block
            return `## ‚ö†Ô∏è ${escapeMarkdown(fileInfo.relativePath)} {#${anchor}}

> **Content Validation Error**

${processedContent}

`;
        }
        
        const fileExt = path.extname(fileInfo.path).toLowerCase();
        const basename = path.basename(fileInfo.path);
        const language = getMarkdownLanguage(fileExt || basename);

        return `## üìÑ ${escapeMarkdown(fileInfo.relativePath)} {#${anchor}}

\`\`\`${language}
${processedContent}
\`\`\`

`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath, { encoding: 'utf8' });
    }
}

export class HtmlOutputStrategy implements OutputStrategy {
    readonly name = 'html';
    readonly extension = '.html';
    private readonly slugger = new GithubSlugger();

    generateHeader(context: OutputContext): string {
        // Reset slugger for each new document to ensure consistent anchors
        this.slugger.reset();
        const tocEntries = context.filesToProcess
            .map(fileInfo => {
                const slug = this.slugger.slug(fileInfo.relativePath);
                const validatedHref = validateHtmlHref(`#${slug}`);
                return `<li><a href="${validatedHref}">${escapeHtml(fileInfo.relativePath)}</a></li>`;
            })
            .join('\n');
        // Reset again so processFile generates same anchors
        this.slugger.reset();

        // Simplified, portable HTML5 with minimal CSS
        return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline'; font-src 'self'; base-uri 'none'">
<meta http-equiv="X-Content-Type-Options" content="nosniff">
<meta http-equiv="X-Frame-Options" content="DENY">
<meta http-equiv="Referrer-Policy" content="no-referrer">
<title>${escapeHtml(context.projectTitle)}${escapeHtml(context.versionInfo)} - Project Fusion</title>
<style>
body{font-family:monospace;margin:20px;line-height:1.6;color:#000;background:#fff}
pre{background:#f5f5f5;border:1px solid #ccc;padding:10px;overflow-x:auto;white-space:pre}
h1,h2{margin-top:20px}
ul{padding-left:20px}
a{color:#00e;text-decoration:underline}
.error{background:#fee;border:1px solid #c00;padding:10px}
</style>
</head>
<body>
<h1>Project Fusion Output</h1>
<p><strong>Project:</strong> ${escapeHtml(context.projectTitle)}${escapeHtml(context.versionInfo)}</p>
<p><strong>Generated:</strong> ${escapeHtml(formatLocalTimestamp())}</p>
<p><strong>Files:</strong> ${context.filesToProcess.length}</p>
<p><strong>Created with:</strong> <a href="https://github.com/the99studio/project-fusion" target="_blank" rel="noopener noreferrer">project-fusion${context.toolVersion ? ` v${context.toolVersion}` : ''}</a></p>
<hr>
<h2>Table of Contents</h2>
<ul>
${tocEntries}
</ul>
<hr>
`;
    }

    processFile(fileInfo: FileInfo, context: OutputContext): string {
        const fileAnchor = this.slugger.slug(fileInfo.relativePath);
        const validatedAnchor = validateHtmlHref(`#${fileAnchor}`).slice(1); // Remove # for id attribute
        const escapedPath = escapeHtml(fileInfo.relativePath);
        
        let processedContent = fileInfo.content;
        
        // Apply aggressive sanitization if enabled
        if (context.config.aggressiveContentSanitization) {
            processedContent = aggressiveContentSanitization(processedContent);
        }
        
        // Always apply HTML escaping
        const escapedContent = escapeHtml(processedContent);
        
        if (fileInfo.isErrorPlaceholder) {
            // Simple error display
            return `<h2 id="${validatedAnchor}">ERROR: ${escapedPath}</h2>
<pre class="error">${escapedContent}</pre>
`;
        }
        
        // Simple file display
        return `<h2 id="${validatedAnchor}">${escapedPath}</h2>
<pre>${escapedContent}</pre>
`;
    }

    generateFooter(): string {
        return `</body>
</html>`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath, { encoding: 'utf8' });
    }
}

export class OutputStrategyManager {
    private readonly strategies: Map<string, OutputStrategy> = new Map();

    constructor() {
        this.registerStrategy(new TextOutputStrategy());
        this.registerStrategy(new MarkdownOutputStrategy());
        this.registerStrategy(new HtmlOutputStrategy());
    }

    registerStrategy(strategy: OutputStrategy): void {
        this.strategies.set(strategy.name, strategy);
    }

    getStrategy(name: string): OutputStrategy | undefined {
        return this.strategies.get(name);
    }

    getEnabledStrategies(config: Config): OutputStrategy[] {
        const enabled: OutputStrategy[] = [];
        
        if (config.generateText) {
            const strategy = this.getStrategy('text');
            if (strategy) { enabled.push(strategy); }
        }
        
        if (config.generateMarkdown) {
            const strategy = this.getStrategy('markdown');
            if (strategy) { enabled.push(strategy); }
        }
        
        if (config.generateHtml) {
            const strategy = this.getStrategy('html');
            if (strategy) { enabled.push(strategy); }
        }
        
        return enabled;
    }

    getOutputPath(strategy: OutputStrategy, config: Config): FilePath {
        const outputDir = config.outputDirectory ?? config.rootDirectory;
        return createFilePath(path.resolve(outputDir, `${config.generatedFileName}${strategy.extension}`));
    }

    async generateOutput(
        strategy: OutputStrategy, 
        context: OutputContext, 
        fs: FileSystemAdapter,
        onFileProcessed?: (fileInfo: FileInfo, index: number, total: number) => void,
        cancellationToken?: CancellationToken
    ): Promise<FilePath> {
        const outputPath = this.getOutputPath(strategy, context.config);
        
        await fs.ensureDir(path.dirname(outputPath));
        
        // Check if we're using a memory file system (for testing)
        const isMemoryFS = fs.constructor.name === 'MemoryFileSystemAdapter';
        
        if (isMemoryFS) {
            // For memory file system, build content in memory and write at once
            let content = strategy.generateHeader(context);
            const maxOutputBytes = (context.config.maxOutputSizeMB ?? 50) * 1024 * 1024;
            
            for (let i = 0; i < context.filesToProcess.length; i++) {
                // Check for cancellation
                if (cancellationToken?.isCancellationRequested) {
                    throw new Error('Operation was cancelled');
                }
                
                const fileInfo = context.filesToProcess[i];
                if (fileInfo) {
                    const fileContent = strategy.processFile(fileInfo, context);
                    
                    // Check output size limit to prevent DoS
                    if (Buffer.byteLength(content + fileContent, 'utf8') > maxOutputBytes) {
                        const limitMB = context.config.maxOutputSizeMB ?? 50;
                        const errorMsg = `Output size would exceed maximum limit of ${limitMB}MB. Consider increasing maxOutputSizeMB in config or reducing file count.`;
                        throw new Error(errorMsg);
                    }
                    
                    content += fileContent;
                    if (onFileProcessed) {
                        onFileProcessed(fileInfo, i, context.filesToProcess.length);
                    }
                }
            }
            
            if (strategy.generateFooter) {
                const footer = strategy.generateFooter(context);
                if (Buffer.byteLength(content + footer, 'utf8') > maxOutputBytes) {
                    const limitMB = context.config.maxOutputSizeMB ?? 50;
                    const errorMsg = `Output size would exceed maximum limit of ${limitMB}MB. Consider increasing maxOutputSizeMB in config.`;
                    throw new Error(errorMsg);
                }
                content += footer;
            }
            
            await fs.writeFile(outputPath, content);
            return outputPath;
        }
        
        // For real file system, use streaming
        const outputStream = strategy.createStream(outputPath);
        let streamClosed = false;
        let totalBytesWritten = 0;
        const maxOutputBytes = (context.config.maxOutputSizeMB ?? 50) * 1024 * 1024;
        
        // Helper to safely close the stream
        const closeStream = (): void => {
            if (!streamClosed) {
                streamClosed = true;
                outputStream.destroy();
            }
        };
        
        // Helper to check size limits before writing
        const checkSizeLimit = (content: string): void => {
            const contentBytes = Buffer.byteLength(content, 'utf8');
            if (totalBytesWritten + contentBytes > maxOutputBytes) {
                const limitMB = context.config.maxOutputSizeMB ?? 50;
                const errorMsg = `Output size would exceed maximum limit of ${limitMB}MB. Consider increasing maxOutputSizeMB in config or reducing file count.`;
                throw new Error(errorMsg);
            }
        };
        
        return new Promise<FilePath>((resolve, reject) => {
            let filesWritten = 0;
            
            // Handle stream errors
            outputStream.on('error', (err) => {
                closeStream();
                reject(err);
            });
            
            // Handle stream finish
            outputStream.on('finish', () => {
                streamClosed = true;
                resolve(outputPath);
            });
            
            let headerWritten = false;
            
            // Process files with backpressure handling
            const processNextFile = (): void => {
                // Check for cancellation
                if (cancellationToken?.isCancellationRequested) {
                    closeStream();
                    reject(new Error('Operation was cancelled'));
                    return;
                }
                // Write header first if not yet written
                if (!headerWritten) {
                    headerWritten = true;
                    const header = strategy.generateHeader(context);
                    
                    try {
                        checkSizeLimit(header);
                    } catch (error) {
                        closeStream();
                        reject(error instanceof Error ? error : new Error(String(error)));
                        return;
                    }
                    
                    totalBytesWritten += Buffer.byteLength(header, 'utf8');
                    
                    if (!outputStream.write(header)) {
                        // Header caused backpressure, wait for drain
                        outputStream.once('drain', processNextFile);
                        return;
                    }
                    // Header written successfully, continue processing
                }
                
                if (filesWritten >= context.filesToProcess.length) {
                    // All files processed, write footer and end
                    if (strategy.generateFooter) {
                        const footer = strategy.generateFooter(context);
                        
                        try {
                            checkSizeLimit(footer);
                        } catch (error) {
                            closeStream();
                            reject(error instanceof Error ? error : new Error(String(error)));
                            return;
                        }
                        
                        totalBytesWritten += Buffer.byteLength(footer, 'utf8');
                        
                        if (!outputStream.write(footer)) {
                            // Footer caused backpressure, wait for drain before ending
                            outputStream.once('drain', () => {
                                outputStream.end();
                            });
                            return;
                        }
                    }
                    outputStream.end();
                    return;
                }
                
                const fileInfo = context.filesToProcess[filesWritten];
                if (!fileInfo) {
                    // Shouldn't happen but handle gracefully
                    processNextFile();
                    return;
                }
                
                const fileContent = strategy.processFile(fileInfo, context);
                
                // Check size limit for the file content
                try {
                    checkSizeLimit(fileContent);
                } catch (error) {
                    closeStream();
                    reject(error instanceof Error ? error : new Error(String(error)));
                    return;
                }
                
                // Report progress
                if (onFileProcessed) {
                    onFileProcessed(fileInfo, filesWritten, context.filesToProcess.length);
                }
                
                filesWritten++;
                
                // Write file content with backpressure handling
                if (fileContent.length > 65_536) {
                    // For large content, write in chunks
                    const chunkSize = 65_536; // 64KB chunks
                    let offset = 0;
                    
                    const writeNextChunk = (): void => {
                        // Check for cancellation during chunk writing
                        if (cancellationToken?.isCancellationRequested) {
                            closeStream();
                            reject(new Error('Operation was cancelled'));
                            return;
                        }
                        
                        if (offset >= fileContent.length) {
                            // Move to next file
                            processNextFile();
                            return;
                        }
                        
                        const chunk = fileContent.slice(offset, offset + chunkSize);
                        offset += chunkSize;
                        
                        totalBytesWritten += Buffer.byteLength(chunk, 'utf8');
                        
                        if (!outputStream.write(chunk)) {
                            // Wait for drain event before continuing
                            outputStream.once('drain', writeNextChunk);
                        } else {
                            // Continue immediately
                            setImmediate(writeNextChunk);
                        }
                    };
                    
                    writeNextChunk();
                } else {
                    totalBytesWritten += Buffer.byteLength(fileContent, 'utf8');
                    
                    if (!outputStream.write(fileContent)) {
                        // Wait for drain event before continuing
                        outputStream.once('drain', processNextFile);
                    } else {
                        // Continue with next file
                        setImmediate(processNextFile);
                    }
                }
            };
            
            // Start processing files
            processNextFile();
        });
    }
}