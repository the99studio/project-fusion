// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Output strategy pattern for different fusion formats
 */
import { WriteStream, createWriteStream } from 'node:fs';
import path from 'node:path';
import type { FileSystemAdapter } from '../adapters/file-system.js';
import { type Config, type FilePath, createFilePath } from '../types.js';
import { formatLocalTimestamp, formatTimestamp, getMarkdownLanguage } from '../utils.js';

export interface FileInfo {
    content: string;
    relativePath: string;
    path: FilePath;
    size: number;
}

export interface OutputContext {
    projectTitle: string;
    versionInfo: string;
    filesToProcess: FileInfo[];
    config: Config;
}

export interface OutputStrategy {
    readonly name: string;
    readonly extension: string;
    generateHeader(context: OutputContext): string;
    processFile(fileInfo: FileInfo, context: OutputContext): string;
    generateFooter?(context: OutputContext): string;
    createStream?(outputPath: FilePath): WriteStream;
}

function escapeHtml(text: string): string {
    return text
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll('\'', '&#39;');
}

export class TextOutputStrategy implements OutputStrategy {
    readonly name = 'text';
    readonly extension = '.txt';

    generateHeader(context: OutputContext): string {
        return `# Generated Project Fusion File
# Project: ${context.projectTitle}${context.versionInfo}
# Generated: ${formatLocalTimestamp()}
# UTC: ${formatTimestamp()}
# Files: ${context.filesToProcess.length}
# Generated by: project-fusion

`;
    }

    processFile(fileInfo: FileInfo): string {
        return `<!-- ============================================================ -->
<!-- FILE: ${fileInfo.relativePath.padEnd(54)} -->
<!-- ============================================================ -->
${fileInfo.content}

`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath);
    }
}

export class MarkdownOutputStrategy implements OutputStrategy {
    readonly name = 'markdown';
    readonly extension = '.md';

    generateHeader(context: OutputContext): string {
        const tocEntries = context.filesToProcess
            .map(fileInfo => `- [${fileInfo.relativePath}](#${fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, '-').toLowerCase()})`)
            .join('\n');

        return `# Generated Project Fusion File

**Project:** ${context.projectTitle}${context.versionInfo}

**Generated:** ${formatLocalTimestamp()}

**UTC:** ${formatTimestamp()}

**Files:** ${context.filesToProcess.length}

**Generated by:** [project-fusion](https://github.com/the99studio/project-fusion)

---

## üìÅ Table of Contents

${tocEntries}

---

`;
    }

    processFile(fileInfo: FileInfo): string {
        const fileExt = path.extname(fileInfo.path).toLowerCase();
        const basename = path.basename(fileInfo.path);
        const language = getMarkdownLanguage(fileExt || basename);

        return `## üìÑ ${fileInfo.relativePath}

\`\`\`${language}
${fileInfo.content}
\`\`\`

`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath);
    }
}

export class HtmlOutputStrategy implements OutputStrategy {
    readonly name = 'html';
    readonly extension = '.html';

    generateHeader(context: OutputContext): string {
        const tocEntries = context.filesToProcess
            .map(fileInfo => `            <li><a href="#${fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, '-').toLowerCase()}">${escapeHtml(fileInfo.relativePath)}</a></li>`)
            .join('\n');

        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Fusion - ${escapeHtml(context.projectTitle)}${escapeHtml(context.versionInfo)}</title>
    <meta name="description" content="Generated fusion of ${context.filesToProcess.length} files from ${context.projectTitle}">
    <style>
        /* Reset and base styles */
        *, *::before, *::after { box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
            line-height: 1.6;
            color: #333;
        }
        
        /* Skip link for keyboard navigation */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #000;
            color: #fff;
            padding: 8px;
            text-decoration: none;
            z-index: 100;
            border-radius: 0 0 4px 0;
        }
        .skip-link:focus {
            top: 0;
        }
        
        /* Header styles */
        .header { 
            border-bottom: 2px solid #eee; 
            padding-bottom: 20px; 
            margin-bottom: 30px; 
        }
        .header dl { 
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px;
            margin: 1em 0;
        }
        .header dt { 
            font-weight: bold;
        }
        .header dd { 
            margin: 0;
        }
        
        /* File sections */
        .file-section { 
            margin-bottom: 40px; 
            border: 1px solid #ddd; 
            border-radius: 8px; 
            padding: 20px; 
        }
        .file-title { 
            background: #f5f5f5; 
            margin: -20px -20px 20px -20px; 
            padding: 15px 20px; 
            border-radius: 8px 8px 0 0; 
        }
        
        /* Code blocks */
        pre { 
            background: #f8f9fa; 
            padding: 15px; 
            border-radius: 6px; 
            overflow-x: auto; 
            border: 1px solid #e1e4e8;
            tab-size: 4;
        }
        code { 
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace; 
            font-size: 0.95em;
        }
        
        /* Table of contents */
        .toc { 
            background: #f8f9fa; 
            padding: 20px; 
            border-radius: 8px; 
            margin-bottom: 30px; 
            border: 1px solid #e1e4e8;
        }
        .toc ul { 
            margin: 0; 
            padding-left: 20px; 
            list-style-type: disc;
        }
        .toc a { 
            text-decoration: none; 
            color: #0366d6; 
        }
        .toc a:hover, .toc a:focus { 
            text-decoration: underline; 
            outline: 2px solid #0366d6;
            outline-offset: 2px;
        }
        
        /* Links */
        a:focus {
            outline: 2px solid #0366d6;
            outline-offset: 2px;
        }
        
        /* High contrast support */
        @media (prefers-contrast: high) {
            .file-section { border-width: 2px; }
            pre { border-width: 2px; }
            .toc { border-width: 2px; }
        }
        
        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            body { 
                background: #0d1117; 
                color: #c9d1d9; 
            }
            .header { border-bottom-color: #30363d; }
            .file-section { 
                border-color: #30363d; 
                background: #161b22;
            }
            .file-title { background: #0d1117; }
            pre { 
                background: #161b22; 
                border-color: #30363d;
                color: #c9d1d9;
            }
            .toc { 
                background: #161b22; 
                border-color: #30363d;
            }
            .toc a { color: #58a6ff; }
            a { color: #58a6ff; }
        }
        
        /* Print styles */
        @media print {
            .skip-link { display: none; }
            .file-section { page-break-inside: avoid; }
            pre { overflow-x: visible; white-space: pre-wrap; }
        }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <header class="header" role="banner">
        <h1>Generated Project Fusion File</h1>
        <dl>
            <dt>Project:</dt>
            <dd>${escapeHtml(context.projectTitle)}${escapeHtml(context.versionInfo)}</dd>
            <dt>Generated:</dt>
            <dd><time datetime="${new Date().toISOString()}">${formatLocalTimestamp()}</time></dd>
            <dt>UTC:</dt>
            <dd><time datetime="${new Date().toISOString()}">${formatTimestamp()}</time></dd>
            <dt>Files:</dt>
            <dd>${context.filesToProcess.length}</dd>
            <dt>Generated by:</dt>
            <dd><a href="https://github.com/the99studio/project-fusion" rel="external">project-fusion</a></dd>
        </dl>
    </header>
    
    <nav class="toc" role="navigation" aria-labelledby="toc-heading">
        <h2 id="toc-heading">üìÅ Table of Contents</h2>
        <ul role="list">
${tocEntries}
        </ul>
    </nav>
    
    <main id="main-content" role="main">
`;
    }

    processFile(fileInfo: FileInfo): string {
        const fileExt = path.extname(fileInfo.path).toLowerCase();
        const basename = path.basename(fileInfo.path);
        const language = getMarkdownLanguage(fileExt || basename);
        const escapedContent = escapeHtml(fileInfo.content);
        const fileAnchor = fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, '-').toLowerCase();

        return `        <article class="file-section" id="${fileAnchor}" aria-labelledby="heading-${fileAnchor}">
            <div class="file-title">
                <h2 id="heading-${fileAnchor}">üìÑ ${escapeHtml(fileInfo.relativePath)}</h2>
            </div>
            <pre role="region" aria-label="Source code for ${escapeHtml(fileInfo.relativePath)}"><code class="language-${language}" lang="${language}">${escapedContent}</code></pre>
        </article>

`;
    }

    generateFooter(): string {
        return `    </main>
</body>
</html>`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath);
    }
}

export class OutputStrategyManager {
    private readonly strategies: Map<string, OutputStrategy> = new Map();

    constructor() {
        this.registerStrategy(new TextOutputStrategy());
        this.registerStrategy(new MarkdownOutputStrategy());
        this.registerStrategy(new HtmlOutputStrategy());
    }

    registerStrategy(strategy: OutputStrategy): void {
        this.strategies.set(strategy.name, strategy);
    }

    getStrategy(name: string): OutputStrategy | undefined {
        return this.strategies.get(name);
    }

    getEnabledStrategies(config: Config): OutputStrategy[] {
        const enabled: OutputStrategy[] = [];
        
        if (config.generateText) {
            const strategy = this.getStrategy('text');
            if (strategy) enabled.push(strategy);
        }
        
        if (config.generateMarkdown) {
            const strategy = this.getStrategy('markdown');
            if (strategy) enabled.push(strategy);
        }
        
        if (config.generateHtml) {
            const strategy = this.getStrategy('html');
            if (strategy) enabled.push(strategy);
        }
        
        return enabled;
    }

    getOutputPath(strategy: OutputStrategy, config: Config): FilePath {
        return createFilePath(path.resolve(config.rootDirectory, `${config.generatedFileName}${strategy.extension}`));
    }

    async generateOutput(
        strategy: OutputStrategy, 
        context: OutputContext, 
        fs: FileSystemAdapter
    ): Promise<FilePath> {
        const outputPath = this.getOutputPath(strategy, context.config);
        
        await fs.ensureDir(path.dirname(outputPath));
        
        let content = strategy.generateHeader(context);
        
        for (const fileInfo of context.filesToProcess) {
            content += strategy.processFile(fileInfo, context);
        }
        
        if (strategy.generateFooter) {
            content += strategy.generateFooter(context);
        }
        
        await fs.writeFile(outputPath, content);
        
        return outputPath;
    }
}