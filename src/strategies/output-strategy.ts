// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Output strategy pattern for different fusion formats
 */
import { WriteStream, createWriteStream } from 'node:fs';
import path from 'node:path';
import type { FileSystemAdapter } from '../adapters/file-system.js';
import { type Config, type FilePath, createFilePath } from '../types.js';
import { formatLocalTimestamp, formatTimestamp, getMarkdownLanguage } from '../utils.js';

export interface FileInfo {
    content: string;
    relativePath: string;
    path: FilePath;
    size: number;
    isErrorPlaceholder?: boolean;
}

export interface OutputContext {
    projectTitle: string;
    versionInfo: string;
    filesToProcess: FileInfo[];
    config: Config;
}

export interface OutputStrategy {
    readonly name: string;
    readonly extension: string;
    generateHeader(context: OutputContext): string;
    processFile(fileInfo: FileInfo, context: OutputContext): string;
    generateFooter?(context: OutputContext): string;
    createStream(outputPath: FilePath): WriteStream;
}

function escapeHtml(text: string): string {
    return text
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll('\'', '&#39;');
}

export class TextOutputStrategy implements OutputStrategy {
    readonly name = 'text';
    readonly extension = '.txt';

    generateHeader(context: OutputContext): string {
        return `# Generated Project Fusion File
# Project: ${context.projectTitle}${context.versionInfo}
# Generated: ${formatLocalTimestamp()}
# UTC: ${formatTimestamp()}
# Files: ${context.filesToProcess.length}
# Generated by: project-fusion (https://github.com/the99studio/project-fusion)

`;
    }

    processFile(fileInfo: FileInfo): string {
        const headerPrefix = fileInfo.isErrorPlaceholder ? 'ERROR' : 'FILE';
        return `<!-- ============================================================ -->
<!-- ${headerPrefix}: ${fileInfo.relativePath.padEnd(54 - headerPrefix.length + 4)} -->
<!-- ============================================================ -->
${fileInfo.content}

`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath, { encoding: 'utf8' });
    }
}

export class MarkdownOutputStrategy implements OutputStrategy {
    readonly name = 'markdown';
    readonly extension = '.md';

    generateHeader(context: OutputContext): string {
        const tocEntries = context.filesToProcess
            .map(fileInfo => `- [${fileInfo.relativePath}](#${fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, '-').toLowerCase()})`)
            .join('\n');

        return `# Generated Project Fusion File

**Project:** ${context.projectTitle}${context.versionInfo}

**Generated:** ${formatLocalTimestamp()}

**UTC:** ${formatTimestamp()}

**Files:** ${context.filesToProcess.length}

**Generated by:** [project-fusion](https://github.com/the99studio/project-fusion)

---

## üìÅ Table of Contents

${tocEntries}

---

`;
    }

    processFile(fileInfo: FileInfo): string {
        if (fileInfo.isErrorPlaceholder) {
            // For error placeholders, display without code block
            return `## ‚ö†Ô∏è ${fileInfo.relativePath}

> **Content Validation Error**

${fileInfo.content}

`;
        }
        
        const fileExt = path.extname(fileInfo.path).toLowerCase();
        const basename = path.basename(fileInfo.path);
        const language = getMarkdownLanguage(fileExt || basename);

        return `## üìÑ ${fileInfo.relativePath}

\`\`\`${language}
${fileInfo.content}
\`\`\`

`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath, { encoding: 'utf8' });
    }
}

export class HtmlOutputStrategy implements OutputStrategy {
    readonly name = 'html';
    readonly extension = '.html';

    generateHeader(context: OutputContext): string {
        const tocEntries = context.filesToProcess
            .map(fileInfo => `            <li><a href="#${fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, '-').toLowerCase()}">${escapeHtml(fileInfo.relativePath)}</a></li>`)
            .join('\n');

        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Fusion - ${escapeHtml(context.projectTitle)}${escapeHtml(context.versionInfo)}</title>
    <meta name="description" content="Generated fusion of ${context.filesToProcess.length} files from ${context.projectTitle}">
    <style>
        /* Reset and base styles */
        *, *::before, *::after { box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
            line-height: 1.6;
            color: #333;
        }
        
        /* Skip link for keyboard navigation */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #000;
            color: #fff;
            padding: 8px;
            text-decoration: none;
            z-index: 100;
            border-radius: 0 0 4px 0;
        }
        .skip-link:focus {
            top: 0;
        }
        
        /* Header styles */
        .header { 
            border-bottom: 2px solid #eee; 
            padding-bottom: 20px; 
            margin-bottom: 30px; 
        }
        .header dl { 
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px;
            margin: 1em 0;
        }
        .header dt { 
            font-weight: bold;
        }
        .header dd { 
            margin: 0;
        }
        
        /* File sections */
        .file-section { 
            margin-bottom: 40px; 
            border: 1px solid #ddd; 
            border-radius: 8px; 
            padding: 20px; 
        }
        .file-title { 
            background: #f5f5f5; 
            margin: -20px -20px 20px -20px; 
            padding: 15px 20px; 
            border-radius: 8px 8px 0 0; 
        }
        
        /* Code blocks */
        pre { 
            background: #f8f9fa; 
            padding: 15px; 
            border-radius: 6px; 
            overflow-x: auto; 
            border: 1px solid #e1e4e8;
            tab-size: 4;
        }
        code { 
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace; 
            font-size: 0.95em;
        }
        
        /* Table of contents */
        .toc { 
            background: #f8f9fa; 
            padding: 20px; 
            border-radius: 8px; 
            margin-bottom: 30px; 
            border: 1px solid #e1e4e8;
        }
        .toc ul { 
            margin: 0; 
            padding-left: 20px; 
            list-style-type: disc;
        }
        .toc a { 
            text-decoration: none; 
            color: #0366d6; 
        }
        .toc a:hover, .toc a:focus { 
            text-decoration: underline; 
            outline: 2px solid #0366d6;
            outline-offset: 2px;
        }
        
        /* Links */
        a:focus {
            outline: 2px solid #0366d6;
            outline-offset: 2px;
        }
        
        /* High contrast support */
        @media (prefers-contrast: high) {
            .file-section { border-width: 2px; }
            pre { border-width: 2px; }
            .toc { border-width: 2px; }
        }
        
        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            body { 
                background: #0d1117; 
                color: #c9d1d9; 
            }
            .header { border-bottom-color: #30363d; }
            .file-section { 
                border-color: #30363d; 
                background: #161b22;
            }
            .file-title { background: #0d1117; }
            pre { 
                background: #161b22; 
                border-color: #30363d;
                color: #c9d1d9;
            }
            .toc { 
                background: #161b22; 
                border-color: #30363d;
            }
            .toc a { color: #58a6ff; }
            a { color: #58a6ff; }
        }
        
        /* Print styles */
        @media print {
            .skip-link { display: none; }
            .file-section { page-break-inside: avoid; }
            pre { overflow-x: visible; white-space: pre-wrap; }
        }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <header class="header" role="banner">
        <h1>Generated Project Fusion File</h1>
        <dl>
            <dt>Project:</dt>
            <dd>${escapeHtml(context.projectTitle)}${escapeHtml(context.versionInfo)}</dd>
            <dt>Generated:</dt>
            <dd><time datetime="${new Date().toISOString()}">${formatLocalTimestamp()}</time></dd>
            <dt>UTC:</dt>
            <dd><time datetime="${new Date().toISOString()}">${formatTimestamp()}</time></dd>
            <dt>Files:</dt>
            <dd>${context.filesToProcess.length}</dd>
            <dt>Generated by:</dt>
            <dd><a href="https://github.com/the99studio/project-fusion" rel="external">project-fusion</a></dd>
        </dl>
    </header>
    
    <nav class="toc" role="navigation" aria-labelledby="toc-heading">
        <h2 id="toc-heading">üìÅ Table of Contents</h2>
        <ul role="list">
${tocEntries}
        </ul>
    </nav>
    
    <main id="main-content" role="main">
`;
    }

    processFile(fileInfo: FileInfo): string {
        const fileAnchor = fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, '-').toLowerCase();
        const escapedPath = escapeHtml(fileInfo.relativePath);
        
        if (fileInfo.isErrorPlaceholder) {
            // For error placeholders, display as error message with distinct styling
            const escapedContent = escapeHtml(fileInfo.content);
            return `        <article class="file-section error-section" id="${fileAnchor}" aria-labelledby="heading-${fileAnchor}">
            <div class="file-title error-title">
                <h2 id="heading-${fileAnchor}">‚ö†Ô∏è ${escapedPath}</h2>
            </div>
            <div class="error-content" role="alert">
                <pre style="background: #fee; border: 2px solid #c00; padding: 1rem; white-space: pre-wrap;">${escapedContent}</pre>
            </div>
        </article>

`;
        }
        
        const fileExt = path.extname(fileInfo.path).toLowerCase();
        const basename = path.basename(fileInfo.path);
        const language = getMarkdownLanguage(fileExt || basename);
        const escapedContent = escapeHtml(fileInfo.content);

        return `        <article class="file-section" id="${fileAnchor}" aria-labelledby="heading-${fileAnchor}">
            <div class="file-title">
                <h2 id="heading-${fileAnchor}">üìÑ ${escapedPath}</h2>
            </div>
            <pre role="region" aria-label="Source code for ${escapedPath}"><code class="language-${language}" lang="${language}">${escapedContent}</code></pre>
        </article>

`;
    }

    generateFooter(): string {
        return `    </main>
</body>
</html>`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath, { encoding: 'utf8' });
    }
}

export class OutputStrategyManager {
    private readonly strategies: Map<string, OutputStrategy> = new Map();

    constructor() {
        this.registerStrategy(new TextOutputStrategy());
        this.registerStrategy(new MarkdownOutputStrategy());
        this.registerStrategy(new HtmlOutputStrategy());
    }

    registerStrategy(strategy: OutputStrategy): void {
        this.strategies.set(strategy.name, strategy);
    }

    getStrategy(name: string): OutputStrategy | undefined {
        return this.strategies.get(name);
    }

    getEnabledStrategies(config: Config): OutputStrategy[] {
        const enabled: OutputStrategy[] = [];
        
        if (config.generateText) {
            const strategy = this.getStrategy('text');
            if (strategy) enabled.push(strategy);
        }
        
        if (config.generateMarkdown) {
            const strategy = this.getStrategy('markdown');
            if (strategy) enabled.push(strategy);
        }
        
        if (config.generateHtml) {
            const strategy = this.getStrategy('html');
            if (strategy) enabled.push(strategy);
        }
        
        return enabled;
    }

    getOutputPath(strategy: OutputStrategy, config: Config): FilePath {
        const outputDir = config.outputDirectory ?? config.rootDirectory;
        return createFilePath(path.resolve(outputDir, `${config.generatedFileName}${strategy.extension}`));
    }

    async generateOutput(
        strategy: OutputStrategy, 
        context: OutputContext, 
        fs: FileSystemAdapter,
        onFileProcessed?: (fileInfo: FileInfo, index: number, total: number) => void,
        cancellationToken?: import('../api.js').CancellationToken
    ): Promise<FilePath> {
        const outputPath = this.getOutputPath(strategy, context.config);
        
        await fs.ensureDir(path.dirname(outputPath));
        
        // Check if we're using a memory file system (for testing)
        const isMemoryFS = fs.constructor.name === 'MemoryFileSystemAdapter';
        
        if (isMemoryFS) {
            // For memory file system, build content in memory and write at once
            let content = strategy.generateHeader(context);
            
            for (let i = 0; i < context.filesToProcess.length; i++) {
                // Check for cancellation
                if (cancellationToken?.isCancellationRequested) {
                    throw new Error('Operation was cancelled');
                }
                
                const fileInfo = context.filesToProcess[i];
                if (fileInfo) {
                    content += strategy.processFile(fileInfo, context);
                    if (onFileProcessed) {
                        onFileProcessed(fileInfo, i, context.filesToProcess.length);
                    }
                }
            }
            
            if (strategy.generateFooter) {
                content += strategy.generateFooter(context);
            }
            
            await fs.writeFile(outputPath, content);
            return outputPath;
        }
        
        // For real file system, use streaming
        const outputStream = strategy.createStream(outputPath);
        let streamClosed = false;
        
        // Helper to safely close the stream
        const closeStream = (): void => {
            if (!streamClosed) {
                streamClosed = true;
                outputStream.destroy();
            }
        };
        
        return new Promise<FilePath>((resolve, reject) => {
            let filesWritten = 0;
            
            // Handle stream errors
            outputStream.on('error', (err) => {
                closeStream();
                reject(err);
            });
            
            // Handle stream finish
            outputStream.on('finish', () => {
                streamClosed = true;
                resolve(outputPath);
            });
            
            let headerWritten = false;
            
            // Process files with backpressure handling
            const processNextFile = (): void => {
                // Check for cancellation
                if (cancellationToken?.isCancellationRequested) {
                    closeStream();
                    reject(new Error('Operation was cancelled'));
                    return;
                }
                // Write header first if not yet written
                if (!headerWritten) {
                    headerWritten = true;
                    const header = strategy.generateHeader(context);
                    if (!outputStream.write(header)) {
                        // Header caused backpressure, wait for drain
                        outputStream.once('drain', processNextFile);
                        return;
                    }
                    // Header written successfully, continue processing
                }
                
                if (filesWritten >= context.filesToProcess.length) {
                    // All files processed, write footer and end
                    if (strategy.generateFooter) {
                        const footer = strategy.generateFooter(context);
                        if (!outputStream.write(footer)) {
                            // Footer caused backpressure, wait for drain before ending
                            outputStream.once('drain', () => {
                                outputStream.end();
                            });
                            return;
                        }
                    }
                    outputStream.end();
                    return;
                }
                
                const fileInfo = context.filesToProcess[filesWritten];
                if (!fileInfo) {
                    // Shouldn't happen but handle gracefully
                    processNextFile();
                    return;
                }
                
                const fileContent = strategy.processFile(fileInfo, context);
                
                // Report progress
                if (onFileProcessed) {
                    onFileProcessed(fileInfo, filesWritten, context.filesToProcess.length);
                }
                
                filesWritten++;
                
                // Write file content with backpressure handling
                if (fileContent.length > 65_536) {
                    // For large content, write in chunks
                    const chunkSize = 65_536; // 64KB chunks
                    let offset = 0;
                    
                    const writeNextChunk = (): void => {
                        // Check for cancellation during chunk writing
                        if (cancellationToken?.isCancellationRequested) {
                            closeStream();
                            reject(new Error('Operation was cancelled'));
                            return;
                        }
                        
                        if (offset >= fileContent.length) {
                            // Move to next file
                            processNextFile();
                            return;
                        }
                        
                        const chunk = fileContent.slice(offset, offset + chunkSize);
                        offset += chunkSize;
                        
                        if (!outputStream.write(chunk)) {
                            // Wait for drain event before continuing
                            outputStream.once('drain', writeNextChunk);
                        } else {
                            // Continue immediately
                            setImmediate(writeNextChunk);
                        }
                    };
                    
                    writeNextChunk();
                } else {
                    // For smaller content, write all at once
                    if (!outputStream.write(fileContent)) {
                        // Wait for drain event before continuing
                        outputStream.once('drain', processNextFile);
                    } else {
                        // Continue with next file
                        setImmediate(processNextFile);
                    }
                }
            };
            
            // Start processing files
            processNextFile();
        });
    }
}