# Generated Project Fusion File

**Project:** project-fusion v1.0.0

**Generated:** 17/08/2025 10:04:05 UTC‚àí4

**UTC:** 2025-08-17T14:04:05.548Z

**Files:** 27

**Generated by:** [project-fusion](https://github.com/the99studio/project-fusion)

---

## üìÅ Table of Contents

- [CHANGELOG.md](#changelog-md)
- [CLAUDE.md](#claude-md)
- [CONTRIBUTING.md](#contributing-md)
- [DEVELOPMENT.md](#development-md)
- [eslint.config.js](#eslint-config-js)
- [package.json](#package-json)
- [project-fusioned.html](#project-fusioned-html)
- [README.md](#readme-md)
- [src/api.ts](#src-api-ts)
- [src/benchmark.ts](#src-benchmark-ts)
- [src/cli.ts](#src-cli-ts)
- [src/clicommands.ts](#src-clicommands-ts)
- [src/fusion.ts](#src-fusion-ts)
- [src/index.ts](#src-index-ts)
- [src/schema.ts](#src-schema-ts)
- [src/types.ts](#src-types-ts)
- [src/utils.ts](#src-utils-ts)
- [tests/api.test.ts](#tests-api-test-ts)
- [tests/benchmark.test.ts](#tests-benchmark-test-ts)
- [tests/formats.test.ts](#tests-formats-test-ts)
- [tests/integration.test.ts](#tests-integration-test-ts)
- [tests/schema.test.ts](#tests-schema-test-ts)
- [tests/types.test.ts](#tests-types-test-ts)
- [tests/utils.test.ts](#tests-utils-test-ts)
- [TODO.md](#todo-md)
- [tsconfig.json](#tsconfig-json)
- [vitest.config.ts](#vitest-config-ts)

---

## üìÑ CHANGELOG.md

```markdown
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [1.0.0] - 2025-01-17

### Initial Release

Project Fusion is a CLI tool that merges multiple project files into a single file for easy sharing and collaboration. This initial release provides multiple output formats.

### Added

#### Core Features
- **Multi-format output generation** - Supports .txt, .md, and .html formats
  - Plain text (.txt) with file separators
  - Markdown (.md) with syntax highlighting and table of contents
  - HTML (.html) with responsive design and navigation
- **Configuration system** with JSON schema validation using Zod
  - Automatic configuration generation with `init` command
  - File extension support (35+ extensions) organized by category
  - Customizable ignore patterns with .gitignore integration
- **CLI interface** built with Commander.js
  - Simple command structure: `project-fusion`, `project-fusion init`, `project-fusion config-check`
  - Command-line options for dynamic configuration overrides
  - Version and help commands

#### File Extension Support
- **Web Development**: .js, .jsx, .ts, .tsx, .html, .css, .scss, .vue, .svelte
- **Backend Languages**: .py, .rb, .java, .cs, .go, .rs, .php, .swift, .kt
- **Configuration**: .json, .yaml, .yml, .toml, .xml, .env, .ini
- **C/C++**: .c, .cpp, .h, .hpp, .cc, .cxx
- **Scripts**: .sh, .bash, .zsh, .bat, .ps1, .cmd
- **Godot Engine**: .gd, .tscn, .tres, .godot, .cfg
- **Documentation**: .md, .rst, .adoc, .txt

#### Technical Features
- **TypeScript 5.9.2** with strict mode and ESM modules
- **Branded types** (FilePath) for type-safe path handling
- **Discriminated unions** for robust error handling (FusionResult)
- **Error handling** with FusionError class, error codes, and severity levels
- **Performance metrics** logging
- **Clipboard integration** with automatic fallback for CI environments

#### Testing and Quality
- **Test coverage** with Vitest integration tests
- **ESLint v9** flat configuration
- **SPDX license headers** in all source files
- **Modular architecture** with separation of concerns
- **Error boundaries** and failure handling

#### Configuration Features
- **Schema versioning** for future compatibility
- **Default values** with fallback configuration
- **gitignore integration**
- **Custom ignore patterns** with glob support
- **File size limits** to prevent memory issues
- **Subdirectory parsing** control

### Technical Implementation
- **Architecture** with separation between CLI, fusion logic, and utilities
- **Zod validation** for configuration validation
- **File scanning** with glob patterns and ignore filtering
- **File size limits** configurable per project
- **Cross-platform compatibility** (Windows, macOS, Linux)
- **Node.js 18+** requirement

### Security
- **Symlink attack prevention** with `follow: false` on all glob operations
- **Input validation** with branded types and Zod schemas
- **Clipboard operations** with environment detection
- **File path validation** to prevent directory traversal

### Documentation
- README with quick start guide
- CLAUDE.md for AI context
- DEVELOPMENT.md for contributors
- CONTRIBUTING.md with guidelines
- MIT License

---

[1.0.0]: https://github.com/the99studio/project-fusion/releases/tag/v1.0.0
```

## üìÑ CLAUDE.md

```markdown
# Project Fusion - AI Context

> üìñ **For Human Development**: See [DEVELOPMENT.md](./DEVELOPMENT.md) for detailed development workflows, testing procedures, and npm publication guide.

## Project Overview
Project Fusion merges multiple project files into a single file for easy sharing and collaboration.

## Essential Architecture
- **TypeScript 5.9.2** ESM project with strict type checking
- **CLI tool** built with Commander.js that generates .txt, .md, and .html fusion files
- **Configuration-driven** with Zod validation and default fallbacks
- **Multi-format output** with syntax highlighting and filtering

## Core Files Structure
```
src/
‚îú‚îÄ‚îÄ cli.ts              # CLI entry point
‚îú‚îÄ‚îÄ clicommands.ts      # Command implementations  
‚îú‚îÄ‚îÄ fusion.ts           # Core fusion logic
‚îú‚îÄ‚îÄ types.ts            # Type definitions (branded types)
‚îú‚îÄ‚îÄ schema.ts           # Zod validation schemas
‚îú‚îÄ‚îÄ utils.ts            # File operations & utilities
‚îî‚îÄ‚îÄ index.ts            # Main exports
```

## Key Commands
```bash
npm run build           # Build TypeScript ‚Üí JavaScript
npm run typecheck       # Type checking only
project-fusion init     # Initialize config
project-fusion          # Run fusion process
```

## Testing Directory
**‚ö†Ô∏è Important**: All testing and temporary files MUST be created in `temp/` directory at project root. This includes:
- Package testing: `temp/package/`
- File generation tests: `temp/test-files/`
- Any temporary artifacts: `temp/artifacts/`

The `temp/` directory is gitignored and safe for any testing activities.

## Configuration Schema
```typescript
{
  schemaVersion: 1
  copyToClipboard: boolean
  generatedFileName: string
  generateHtml: boolean
  generateMarkdown: boolean
  generateText: boolean
  maxFileSizeKB: number
  parseSubDirectories: boolean
  parsedFileExtensions: {
    web: string[]       // .js, .ts, .tsx, .vue, etc.
    backend: string[]   // .py, .go, .java, .rs, etc. 
    config: string[]    // .json, .yaml, .toml, etc.
    cpp: string[]       // .c, .cpp, .h, .hpp
    scripts: string[]   // .sh, .bat, .ps1
    godot: string[]     // .gd, .tscn, .tres
    doc: string[]       // .md, .rst, .adoc
  }
  rootDirectory: string
  ignorePatterns: string[]
  useGitIgnoreForExcludes: boolean
}
```

## Core Workflow
1. Load `project-fusion.json` config with Zod validation
2. Scan files by extensions, apply .gitignore + custom ignore patterns
3. Generate triple output:
   - `project-fusioned.txt` - Plain text with separators
   - `project-fusioned.md` - Markdown with syntax highlighting + TOC
   - `project-fusioned.html` - HTML with responsive design + interactive TOC

## Key Implementation Details
- **Branded types** (FilePath) prevent string confusion
- **Discriminated unions** (FusionResult) for type-safe error handling  
- **ESM modules** with strict TypeScript
- **Configuration fallbacks** - uses defaults if config missing/invalid

## Quick Reference
- **Add extensions**: Update `src/schema.ts` + `src/utils.ts` default config
- **Add commands**: Register in `src/cli.ts`, implement in `src/clicommands.ts`
- **Modify output**: Edit `src/fusion.ts` processing logic

## Documentation Style Guide
- **Keep it simple and professional**: Avoid superlatives and marketing language
- **Be factual**: Describe features without overselling
- **Use neutral tone**: Focus on functionality rather than promotional phrases
- **No excessive adjectives**: Avoid words like "powerful", "beautiful", "smart", etc.
```

## üìÑ CONTRIBUTING.md

```markdown
# Contributing to Project Fusion

Thanks for your interest! This guide explains how to propose changes and report issues.

## Code of Conduct
Be respectful and constructive. By participating, you agree to foster an open and welcoming environment.

## How to contribute
1. **Fork** the repo and create a branch: `feat/<short-name>` or `fix/<short-name>`.
2. See [DEVELOPMENT.md](./DEVELOPMENT.md) for detailed development workflows, testing procedures, and npm publication guide.
3. Open a Pull Request with a clear description and checklist.

## PR checklist
- [ ] Feature/bugfix tested
- [ ] No regressions
- [ ] Docs/README updated if necessary
- [ ] Notable changes added to `CHANGELOG.md`

```

## üìÑ DEVELOPMENT.md

```markdown
# Project Fusion - Development Guide

> üìã **For Claude AI Context**: See [CLAUDE.md](./CLAUDE.md) for essential project information needed for development assistance.

## üöÄ Development Workflow

### Initial Setup
```bash
git clone https://github.com/the99studio/project-fusion.git
cd project-fusion
npm install
npm run build
```

### Claude Code Integration
The project includes `.claude/settings.local.json` which configures Claude Code permissions for smoother development. This file provides:

**Allowed Operations:**
- NPM commands: install, build, typecheck, test, clean, pack
- Project CLI: `project-fusion` and `node dist/cli.js` commands
- Git operations: status, diff, log, branch, add, commit, push, pull
- Safe file operations: Limited to `temp/` directory for rm/cp operations
- Search capabilities: find, grep, rg, ls, cat, head, tail for code exploration
- Package management: npm list, outdated, view

**Security Features:**
- File deletions restricted to `temp/` directory only
- No arbitrary Node.js code execution (only specific CLI commands)
- Explicit deny list for dangerous operations (sudo, eval, etc.)
- No system-wide file modifications allowed

These permissions eliminate repetitive authorization prompts while maintaining security boundaries.

### Testing the CLI
Use VS Code launch configurations (F5) for easy testing:
- **"Fusion (Default)"** - Default behavior (runs fusion)
- **"Fusion (Web)"** - Test web extensions only
- **"Help"** - Test CLI help
- **"Init"** - Test project initialization

### Testing with Real Package
For testing as if it were the real published package, see the [NPM Package Testing](#-npm-package-management) section below.

## üì¶ NPM Package Management

### Pre-Publication Testing

Use the **"Test NPM Package"** launch configuration in VS Code (F5) which automatically:
- Builds the project
- Creates and extracts test package to `temp/package/`
- Installs dependencies and tests CLI functionality

#### Manual Package Verification
```bash
# Preview what will be published
npm pack --dry-run

# Create test package (if not using VS Code)
npm pack  # Creates project-fusion-x.x.x.tgz
```

#### Testing with Real Package Installation
```bash
# Install the test package globally
npm install -g ./temp/package/ # start line with sudo if you need admin rights

# Test commands (acts like real published package)
project-fusion --help
project-fusion --version
project-fusion init
project-fusion # Default: runs fusion

# Uninstall when done testing
npm uninstall -g project-fusion # start line with sudo if you need admin rights
```

### Publication Process

```bash
# 1. Final verification
npm pack --dry-run

# 2. Simulate publication (verifies authentication, package validity)
npm publish --dry-run

# 3. Create npm account and login (first time only)
# Visit https://www.npmjs.com/signup to create account
npm login

# 4. Publish to npm
npm publish

# 5. Verify publication
npm view project-fusion
```

## üõ†Ô∏è Development Patterns

### Adding New File Extensions
1. Update `src/schema.ts` - add to `ParsedFileExtensionsSchema`
2. Update default config in `src/utils.ts` 
3. Test with various projects

### Adding New CLI Commands
1. Register command in `src/cli.ts` (Commander.js)
2. Implement in `src/clicommands.ts`
3. Update help text and documentation

### Modifying Fusion Output
1. Edit `src/fusion.ts` processing logic
2. Update types in `src/types.ts` if needed
3. Test both .txt and .md output formats

## üß™ Testing Strategy

### Manual Testing Checklist
- [ ] `npm run build` - clean build
- [ ] `npm run typecheck` - no type errors
- [ ] CLI help works: `project-fusion --help`
- [ ] Init works: `project-fusion init`
- [ ] Fusion works: `project-fusion`
- [ ] Extension filtering works
- [ ] .gitignore integration works
- [ ] Output files are properly formatted
- [ ] Package builds and installs correctly

### Test Projects
Use these types of projects for testing:
- **Node.js/TypeScript** (like this project)
- **Python projects** (test backend extensions)
- **React/Vue projects** (test web extensions)
- **Mixed projects** (multiple extension types)

## üîß Troubleshooting

### Common Issues

**Build Errors:**
```bash
npm run clean && npm run build
```

**Package Contains Wrong Files:**
- Check `package.json` `files` field
- Use `npm pack --dry-run` to verify

**TypeScript Errors:**
```bash
npm run typecheck
# Fix errors in src/ files
```

## üìÅ Directory Structure

```
project-fusion/
‚îú‚îÄ‚îÄ src/                    # TypeScript source
‚îÇ   ‚îú‚îÄ‚îÄ cli.ts             # CLI entry point
‚îÇ   ‚îú‚îÄ‚îÄ clicommands.ts     # Command implementations
‚îÇ   ‚îú‚îÄ‚îÄ fusion.ts          # Core fusion logic
‚îÇ   ‚îú‚îÄ‚îÄ types.ts           # Type definitions
‚îÇ   ‚îú‚îÄ‚îÄ schema.ts          # Zod schemas
‚îÇ   ‚îú‚îÄ‚îÄ utils.ts           # Utilities
‚îÇ   ‚îî‚îÄ‚îÄ index.ts           # Main exports
‚îú‚îÄ‚îÄ dist/                  # Compiled JavaScript (gitignored)
‚îú‚îÄ‚îÄ temp/                  # Testing directory (gitignored)
‚îú‚îÄ‚îÄ CLAUDE.md              # AI context (essential info)
‚îú‚îÄ‚îÄ DEVELOPMENT.md         # This file (human development)
‚îú‚îÄ‚îÄ package.json           # NPM configuration
‚îî‚îÄ‚îÄ tsconfig.json          # TypeScript configuration
```

## üîó Important Files

- **CLAUDE.md** - Essential project context for AI assistance
- **package.json** - NPM package configuration and scripts
- **tsconfig.json** - TypeScript compilation settings
- **.gitignore** - Git ignore patterns (includes `temp/`)
- **.vscode/launch.json** - VS Code debugging/testing configurations
```

## üìÑ eslint.config.js

```javascript
import js from '@eslint/js';
import tseslint from '@typescript-eslint/eslint-plugin';
import tsparser from '@typescript-eslint/parser';
import importPlugin from 'eslint-plugin-import';
import unicorn from 'eslint-plugin-unicorn';

export default [
  js.configs.recommended,
  {
    files: ['src/**/*.ts'],
    languageOptions: {
      parser: tsparser,
      parserOptions: {
        ecmaVersion: 2022,
        sourceType: 'module',
        project: './tsconfig.json'
      },
      globals: {
        console: 'readonly',
        process: 'readonly',
        Buffer: 'readonly',
        __dirname: 'readonly',
        __filename: 'readonly',
        NodeJS: 'readonly'
      }
    },
    plugins: {
      '@typescript-eslint': tseslint,
      'import': importPlugin,
      'unicorn': unicorn
    },
    rules: {
      // TypeScript strict rules
      '@typescript-eslint/no-explicit-any': 'error',
      '@typescript-eslint/no-unused-vars': 'error',
      '@typescript-eslint/prefer-readonly': 'error',
      '@typescript-eslint/explicit-function-return-type': 'error',
      '@typescript-eslint/explicit-module-boundary-types': 'error',
      '@typescript-eslint/no-inferrable-types': 'error',
      '@typescript-eslint/no-unnecessary-type-assertion': 'error',
      '@typescript-eslint/prefer-nullish-coalescing': 'error',
      '@typescript-eslint/prefer-optional-chain': 'error',
      '@typescript-eslint/prefer-string-starts-ends-with': 'error',
      '@typescript-eslint/prefer-includes': 'error',
      '@typescript-eslint/no-floating-promises': 'error',
      '@typescript-eslint/await-thenable': 'error',
      '@typescript-eslint/no-misused-promises': 'error',
      '@typescript-eslint/require-await': 'error',

      // General code quality
      'no-console': 'off', // CLI app needs console output
      'no-debugger': 'error',
      'no-alert': 'error',
      'no-var': 'error',
      'prefer-const': 'error',
      'prefer-arrow-callback': 'error',
      'prefer-template': 'error',
      'object-shorthand': 'error',
      'quote-props': ['error', 'as-needed'],
      'no-duplicate-imports': 'error',
      
      // Import rules
      'import/order': [
        'error',
        {
          'groups': [
            'builtin',
            'external', 
            'internal',
            'parent',
            'sibling',
            'index'
          ],
          'newlines-between': 'never',
          'alphabetize': {
            'order': 'asc',
            'caseInsensitive': true
          }
        }
      ],
      'import/no-duplicates': 'error',

      // Unicorn rules for modern JS practices
      'unicorn/prefer-node-protocol': 'error',
      'unicorn/prefer-module': 'error',
      'unicorn/prefer-ternary': 'warn',
      'unicorn/prefer-logical-operator-over-ternary': 'error',
      'unicorn/no-array-for-each': 'warn',
      'unicorn/prefer-array-some': 'error',
      'unicorn/prefer-array-find': 'error',
      'unicorn/prefer-array-flat': 'error',
      'unicorn/prefer-object-from-entries': 'error',
      'unicorn/prefer-set-has': 'error',
      'unicorn/prefer-string-slice': 'error',
      'unicorn/prefer-number-properties': 'error',
      'unicorn/numeric-separators-style': 'error',
      'unicorn/better-regex': 'error',
      'unicorn/catch-error-name': 'error',
      'unicorn/custom-error-definition': 'error',
      'unicorn/error-message': 'error',
      'unicorn/escape-case': 'error',
      'unicorn/explicit-length-check': 'error',
      'unicorn/filename-case': [
        'error',
        {
          'cases': {
            'camelCase': true,
            'pascalCase': true,
            'kebabCase': true
          }
        }
      ],
      'unicorn/new-for-builtins': 'error',
      'unicorn/no-abusive-eslint-disable': 'error',
      'unicorn/no-array-push-push': 'error',
      'unicorn/no-console-spaces': 'error',
      'unicorn/no-hex-escape': 'error',
      'unicorn/no-instanceof-array': 'error',
      'unicorn/no-new-buffer': 'error',
      'unicorn/no-unnecessary-await': 'error',
      'unicorn/no-useless-length-check': 'error',
      'unicorn/no-useless-spread': 'error',
      'unicorn/no-zero-fractions': 'error',
      'unicorn/number-literal-case': 'error',
      'unicorn/prefer-add-event-listener': 'error',
      'unicorn/prefer-array-index-of': 'error',
      'unicorn/prefer-date-now': 'error',
      'unicorn/prefer-default-parameters': 'error',
      'unicorn/prefer-includes': 'error',
      'unicorn/prefer-math-trunc': 'error',
      'unicorn/prefer-negative-index': 'error',
      'unicorn/prefer-optional-catch-binding': 'error',
      'unicorn/prefer-prototype-methods': 'error',
      'unicorn/prefer-reflect-apply': 'error',
      'unicorn/prefer-regexp-test': 'error',
      'unicorn/prefer-spread': 'error',
      'unicorn/prefer-string-replace-all': 'error',
      'unicorn/prefer-string-trim-start-end': 'error',
      'unicorn/prefer-switch': 'error',
      'unicorn/prefer-type-error': 'error',
      'unicorn/throw-new-error': 'error'
    }
  },
  {
    files: ['tests/**/*', '**/*.test.ts', '**/*.spec.ts'],
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/explicit-function-return-type': 'off',
      'no-console': 'off'
    }
  }
];
```

## üìÑ package.json

```json
{
    "name": "project-fusion",
    "version": "1.0.0",
    "description": "CLI tool for merging project files into a single file for easy sharing",
    "main": "dist/index.js",
    "types": "dist/index.d.ts",
    "type": "module",
    "bin": {
        "project-fusion": "dist/cli.js"
    },
    "exports": {
        ".": {
            "types": "./dist/index.d.ts",
            "import": "./dist/index.js"
        },
        "./package.json": "./package.json"
    },
    "files": [
        "dist/**/*",
        "README.md",
        "LICENSE",
        "CHANGELOG.md"
    ],
    "sideEffects": false,
    "scripts": {
        "build": "tsc",
        "clean": "rm -rf dist",
        "dev": "tsc --watch",
        "lint": "eslint src/**/*.ts",
        "lint:fix": "eslint src/**/*.ts --fix",
        "prepublishOnly": "npm run clean && npm run build",
        "test": "vitest",
        "test:coverage": "vitest run --coverage",
        "test:ui": "vitest --ui",
        "typecheck": "tsc --noEmit"
    },
    "keywords": [
        "cli",
        "code",
        "collaboration",
        "files",
        "fusion",
        "merge",
        "sharing"
    ],
    "author": "the99studio",
    "license": "MIT",
    "engines": {
        "node": ">=18.0.0"
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/the99studio/project-fusion.git"
    },
    "bugs": {
        "url": "https://github.com/the99studio/project-fusion/issues"
    },
    "homepage": "https://github.com/the99studio/project-fusion#readme",
    "dependencies": {
        "chalk": "^5.5.0",
        "clipboardy": "^4.0.0",
        "commander": "^14.0.0",
        "fs-extra": "^11.3.1",
        "glob": "^11.0.3",
        "ignore": "^7.0.5",
        "zod": "^4.0.17"
    },
    "devDependencies": {
        "@types/fs-extra": "^11.0.4",
        "@types/node": "^24.2.1",
        "@typescript-eslint/eslint-plugin": "^8.39.1",
        "@typescript-eslint/parser": "^8.39.1",
        "@vitest/coverage-v8": "^2.1.9",
        "eslint": "^9.33.0",
        "eslint-plugin-import": "^2.32.0",
        "eslint-plugin-node": "^11.1.0",
        "eslint-plugin-unicorn": "^60.0.0",
        "typescript": "^5.9.2",
        "vitest": "^2.1.6"
    }
}

```

## üìÑ project-fusioned.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Fusion - project-fusion v1.0.0</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { border-bottom: 2px solid #eee; padding-bottom: 20px; margin-bottom: 30px; }
        .file-section { margin-bottom: 40px; border: 1px solid #ddd; border-radius: 8px; padding: 20px; }
        .file-title { background: #f5f5f5; margin: -20px -20px 20px -20px; padding: 15px 20px; border-radius: 8px 8px 0 0; }
        pre { background: #f8f9fa; padding: 15px; border-radius: 6px; overflow-x: auto; }
        code { font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; }
        .toc { background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 30px; }
        .toc ul { margin: 0; padding-left: 20px; }
        .toc a { text-decoration: none; color: #0366d6; }
        .toc a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Generated Project Fusion File</h1>
        <p><strong>Project:</strong> project-fusion v1.0.0</p>
        <p><strong>Generated:</strong> 17/08/2025 10:04:05 UTC‚àí4</p>
        <p><strong>UTC:</strong> 2025-08-17T14:04:05.548Z</p>
        <p><strong>Files:</strong> 27</p>
        <p><strong>Generated by:</strong> <a href="https://github.com/the99studio/project-fusion">project-fusion</a></p>
    </div>
    <div class="toc">
        <h2>üìÅ Table of Contents</h2>
        <ul>
            <li><a href="#changelog-md">CHANGELOG.md</a></li>
            <li><a href="#claude-md">CLAUDE.md</a></li>
            <li><a href="#contributing-md">CONTRIBUTING.md</a></li>
            <li><a href="#development-md">DEVELOPMENT.md</a></li>
            <li><a href="#eslint-config-js">eslint.config.js</a></li>
            <li><a href="#package-json">package.json</a></li>
            <li><a href="#project-fusioned-html">project-fusioned.html</a></li>
            <li><a href="#readme-md">README.md</a></li>
            <li><a href="#src-api-ts">src/api.ts</a></li>
            <li><a href="#src-benchmark-ts">src/benchmark.ts</a></li>
            <li><a href="#src-cli-ts">src/cli.ts</a></li>
            <li><a href="#src-clicommands-ts">src/clicommands.ts</a></li>
            <li><a href="#src-fusion-ts">src/fusion.ts</a></li>
            <li><a href="#src-index-ts">src/index.ts</a></li>
            <li><a href="#src-schema-ts">src/schema.ts</a></li>
            <li><a href="#src-types-ts">src/types.ts</a></li>
            <li><a href="#src-utils-ts">src/utils.ts</a></li>
            <li><a href="#tests-api-test-ts">tests/api.test.ts</a></li>
            <li><a href="#tests-benchmark-test-ts">tests/benchmark.test.ts</a></li>
            <li><a href="#tests-formats-test-ts">tests/formats.test.ts</a></li>
            <li><a href="#tests-integration-test-ts">tests/integration.test.ts</a></li>
            <li><a href="#tests-schema-test-ts">tests/schema.test.ts</a></li>
            <li><a href="#tests-types-test-ts">tests/types.test.ts</a></li>
            <li><a href="#tests-utils-test-ts">tests/utils.test.ts</a></li>
            <li><a href="#todo-md">TODO.md</a></li>
            <li><a href="#tsconfig-json">tsconfig.json</a></li>
            <li><a href="#vitest-config-ts">vitest.config.ts</a></li>
        </ul>
    </div>    <div class="file-section" id="changelog-md">
        <div class="file-title">
            <h2>üìÑ CHANGELOG.md</h2>
        </div>
        <pre><code class="markdown"># Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [1.0.0] - 2025-01-17

### Initial Release

Project Fusion is a CLI tool that merges multiple project files into a single file for easy sharing and collaboration. This initial release provides multiple output formats.

### Added

#### Core Features
- **Multi-format output generation** - Supports .txt, .md, and .html formats
  - Plain text (.txt) with file separators
  - Markdown (.md) with syntax highlighting and table of contents
  - HTML (.html) with responsive design and navigation
- **Configuration system** with JSON schema validation using Zod
  - Automatic configuration generation with `init` command
  - File extension support (35+ extensions) organized by category
  - Customizable ignore patterns with .gitignore integration
- **CLI interface** built with Commander.js
  - Simple command structure: `project-fusion`, `project-fusion init`, `project-fusion config-check`
  - Command-line options for dynamic configuration overrides
  - Version and help commands

#### File Extension Support
- **Web Development**: .js, .jsx, .ts, .tsx, .html, .css, .scss, .vue, .svelte
- **Backend Languages**: .py, .rb, .java, .cs, .go, .rs, .php, .swift, .kt
- **Configuration**: .json, .yaml, .yml, .toml, .xml, .env, .ini
- **C/C++**: .c, .cpp, .h, .hpp, .cc, .cxx
- **Scripts**: .sh, .bash, .zsh, .bat, .ps1, .cmd
- **Godot Engine**: .gd, .tscn, .tres, .godot, .cfg
- **Documentation**: .md, .rst, .adoc, .txt

#### Technical Features
- **TypeScript 5.9.2** with strict mode and ESM modules
- **Branded types** (FilePath) for type-safe path handling
- **Discriminated unions** for robust error handling (FusionResult)
- **Error handling** with FusionError class, error codes, and severity levels
- **Performance metrics** logging
- **Clipboard integration** with automatic fallback for CI environments

#### Testing and Quality
- **Test coverage** with Vitest integration tests
- **ESLint v9** flat configuration
- **SPDX license headers** in all source files
- **Modular architecture** with separation of concerns
- **Error boundaries** and failure handling

#### Configuration Features
- **Schema versioning** for future compatibility
- **Default values** with fallback configuration
- **gitignore integration**
- **Custom ignore patterns** with glob support
- **File size limits** to prevent memory issues
- **Subdirectory parsing** control

### Technical Implementation
- **Architecture** with separation between CLI, fusion logic, and utilities
- **Zod validation** for configuration validation
- **File scanning** with glob patterns and ignore filtering
- **File size limits** configurable per project
- **Cross-platform compatibility** (Windows, macOS, Linux)
- **Node.js 18+** requirement

### Security
- **Symlink attack prevention** with `follow: false` on all glob operations
- **Input validation** with branded types and Zod schemas
- **Clipboard operations** with environment detection
- **File path validation** to prevent directory traversal

### Documentation
- README with quick start guide
- CLAUDE.md for AI context
- DEVELOPMENT.md for contributors
- CONTRIBUTING.md with guidelines
- MIT License

---

[1.0.0]: https://github.com/the99studio/project-fusion/releases/tag/v1.0.0</code></pre>
    </div>

    <div class="file-section" id="claude-md">
        <div class="file-title">
            <h2>üìÑ CLAUDE.md</h2>
        </div>
        <pre><code class="markdown"># Project Fusion - AI Context

&gt; üìñ **For Human Development**: See [DEVELOPMENT.md](./DEVELOPMENT.md) for detailed development workflows, testing procedures, and npm publication guide.

## Project Overview
Project Fusion merges multiple project files into a single file for easy sharing and collaboration.

## Essential Architecture
- **TypeScript 5.9.2** ESM project with strict type checking
- **CLI tool** built with Commander.js that generates .txt, .md, and .html fusion files
- **Configuration-driven** with Zod validation and default fallbacks
- **Multi-format output** with syntax highlighting and filtering

## Core Files Structure
```
src/
‚îú‚îÄ‚îÄ cli.ts              # CLI entry point
‚îú‚îÄ‚îÄ clicommands.ts      # Command implementations  
‚îú‚îÄ‚îÄ fusion.ts           # Core fusion logic
‚îú‚îÄ‚îÄ types.ts            # Type definitions (branded types)
‚îú‚îÄ‚îÄ schema.ts           # Zod validation schemas
‚îú‚îÄ‚îÄ utils.ts            # File operations &amp; utilities
‚îî‚îÄ‚îÄ index.ts            # Main exports
```

## Key Commands
```bash
npm run build           # Build TypeScript ‚Üí JavaScript
npm run typecheck       # Type checking only
project-fusion init     # Initialize config
project-fusion          # Run fusion process
```

## Testing Directory
**‚ö†Ô∏è Important**: All testing and temporary files MUST be created in `temp/` directory at project root. This includes:
- Package testing: `temp/package/`
- File generation tests: `temp/test-files/`
- Any temporary artifacts: `temp/artifacts/`

The `temp/` directory is gitignored and safe for any testing activities.

## Configuration Schema
```typescript
{
  schemaVersion: 1
  copyToClipboard: boolean
  generatedFileName: string
  generateHtml: boolean
  generateMarkdown: boolean
  generateText: boolean
  maxFileSizeKB: number
  parseSubDirectories: boolean
  parsedFileExtensions: {
    web: string[]       // .js, .ts, .tsx, .vue, etc.
    backend: string[]   // .py, .go, .java, .rs, etc. 
    config: string[]    // .json, .yaml, .toml, etc.
    cpp: string[]       // .c, .cpp, .h, .hpp
    scripts: string[]   // .sh, .bat, .ps1
    godot: string[]     // .gd, .tscn, .tres
    doc: string[]       // .md, .rst, .adoc
  }
  rootDirectory: string
  ignorePatterns: string[]
  useGitIgnoreForExcludes: boolean
}
```

## Core Workflow
1. Load `project-fusion.json` config with Zod validation
2. Scan files by extensions, apply .gitignore + custom ignore patterns
3. Generate triple output:
   - `project-fusioned.txt` - Plain text with separators
   - `project-fusioned.md` - Markdown with syntax highlighting + TOC
   - `project-fusioned.html` - HTML with responsive design + interactive TOC

## Key Implementation Details
- **Branded types** (FilePath) prevent string confusion
- **Discriminated unions** (FusionResult) for type-safe error handling  
- **ESM modules** with strict TypeScript
- **Configuration fallbacks** - uses defaults if config missing/invalid

## Quick Reference
- **Add extensions**: Update `src/schema.ts` + `src/utils.ts` default config
- **Add commands**: Register in `src/cli.ts`, implement in `src/clicommands.ts`
- **Modify output**: Edit `src/fusion.ts` processing logic

## Documentation Style Guide
- **Keep it simple and professional**: Avoid superlatives and marketing language
- **Be factual**: Describe features without overselling
- **Use neutral tone**: Focus on functionality rather than promotional phrases
- **No excessive adjectives**: Avoid words like &quot;powerful&quot;, &quot;beautiful&quot;, &quot;smart&quot;, etc.</code></pre>
    </div>

    <div class="file-section" id="contributing-md">
        <div class="file-title">
            <h2>üìÑ CONTRIBUTING.md</h2>
        </div>
        <pre><code class="markdown"># Contributing to Project Fusion

Thanks for your interest! This guide explains how to propose changes and report issues.

## Code of Conduct
Be respectful and constructive. By participating, you agree to foster an open and welcoming environment.

## How to contribute
1. **Fork** the repo and create a branch: `feat/&lt;short-name&gt;` or `fix/&lt;short-name&gt;`.
2. See [DEVELOPMENT.md](./DEVELOPMENT.md) for detailed development workflows, testing procedures, and npm publication guide.
3. Open a Pull Request with a clear description and checklist.

## PR checklist
- [ ] Feature/bugfix tested
- [ ] No regressions
- [ ] Docs/README updated if necessary
- [ ] Notable changes added to `CHANGELOG.md`
</code></pre>
    </div>

    <div class="file-section" id="development-md">
        <div class="file-title">
            <h2>üìÑ DEVELOPMENT.md</h2>
        </div>
        <pre><code class="markdown"># Project Fusion - Development Guide

&gt; üìã **For Claude AI Context**: See [CLAUDE.md](./CLAUDE.md) for essential project information needed for development assistance.

## üöÄ Development Workflow

### Initial Setup
```bash
git clone https://github.com/the99studio/project-fusion.git
cd project-fusion
npm install
npm run build
```

### Claude Code Integration
The project includes `.claude/settings.local.json` which configures Claude Code permissions for smoother development. This file provides:

**Allowed Operations:**
- NPM commands: install, build, typecheck, test, clean, pack
- Project CLI: `project-fusion` and `node dist/cli.js` commands
- Git operations: status, diff, log, branch, add, commit, push, pull
- Safe file operations: Limited to `temp/` directory for rm/cp operations
- Search capabilities: find, grep, rg, ls, cat, head, tail for code exploration
- Package management: npm list, outdated, view

**Security Features:**
- File deletions restricted to `temp/` directory only
- No arbitrary Node.js code execution (only specific CLI commands)
- Explicit deny list for dangerous operations (sudo, eval, etc.)
- No system-wide file modifications allowed

These permissions eliminate repetitive authorization prompts while maintaining security boundaries.

### Testing the CLI
Use VS Code launch configurations (F5) for easy testing:
- **&quot;Fusion (Default)&quot;** - Default behavior (runs fusion)
- **&quot;Fusion (Web)&quot;** - Test web extensions only
- **&quot;Help&quot;** - Test CLI help
- **&quot;Init&quot;** - Test project initialization

### Testing with Real Package
For testing as if it were the real published package, see the [NPM Package Testing](#-npm-package-management) section below.

## üì¶ NPM Package Management

### Pre-Publication Testing

Use the **&quot;Test NPM Package&quot;** launch configuration in VS Code (F5) which automatically:
- Builds the project
- Creates and extracts test package to `temp/package/`
- Installs dependencies and tests CLI functionality

#### Manual Package Verification
```bash
# Preview what will be published
npm pack --dry-run

# Create test package (if not using VS Code)
npm pack  # Creates project-fusion-x.x.x.tgz
```

#### Testing with Real Package Installation
```bash
# Install the test package globally
npm install -g ./temp/package/ # start line with sudo if you need admin rights

# Test commands (acts like real published package)
project-fusion --help
project-fusion --version
project-fusion init
project-fusion # Default: runs fusion

# Uninstall when done testing
npm uninstall -g project-fusion # start line with sudo if you need admin rights
```

### Publication Process

```bash
# 1. Final verification
npm pack --dry-run

# 2. Simulate publication (verifies authentication, package validity)
npm publish --dry-run

# 3. Create npm account and login (first time only)
# Visit https://www.npmjs.com/signup to create account
npm login

# 4. Publish to npm
npm publish

# 5. Verify publication
npm view project-fusion
```

## üõ†Ô∏è Development Patterns

### Adding New File Extensions
1. Update `src/schema.ts` - add to `ParsedFileExtensionsSchema`
2. Update default config in `src/utils.ts` 
3. Test with various projects

### Adding New CLI Commands
1. Register command in `src/cli.ts` (Commander.js)
2. Implement in `src/clicommands.ts`
3. Update help text and documentation

### Modifying Fusion Output
1. Edit `src/fusion.ts` processing logic
2. Update types in `src/types.ts` if needed
3. Test both .txt and .md output formats

## üß™ Testing Strategy

### Manual Testing Checklist
- [ ] `npm run build` - clean build
- [ ] `npm run typecheck` - no type errors
- [ ] CLI help works: `project-fusion --help`
- [ ] Init works: `project-fusion init`
- [ ] Fusion works: `project-fusion`
- [ ] Extension filtering works
- [ ] .gitignore integration works
- [ ] Output files are properly formatted
- [ ] Package builds and installs correctly

### Test Projects
Use these types of projects for testing:
- **Node.js/TypeScript** (like this project)
- **Python projects** (test backend extensions)
- **React/Vue projects** (test web extensions)
- **Mixed projects** (multiple extension types)

## üîß Troubleshooting

### Common Issues

**Build Errors:**
```bash
npm run clean &amp;&amp; npm run build
```

**Package Contains Wrong Files:**
- Check `package.json` `files` field
- Use `npm pack --dry-run` to verify

**TypeScript Errors:**
```bash
npm run typecheck
# Fix errors in src/ files
```

## üìÅ Directory Structure

```
project-fusion/
‚îú‚îÄ‚îÄ src/                    # TypeScript source
‚îÇ   ‚îú‚îÄ‚îÄ cli.ts             # CLI entry point
‚îÇ   ‚îú‚îÄ‚îÄ clicommands.ts     # Command implementations
‚îÇ   ‚îú‚îÄ‚îÄ fusion.ts          # Core fusion logic
‚îÇ   ‚îú‚îÄ‚îÄ types.ts           # Type definitions
‚îÇ   ‚îú‚îÄ‚îÄ schema.ts          # Zod schemas
‚îÇ   ‚îú‚îÄ‚îÄ utils.ts           # Utilities
‚îÇ   ‚îî‚îÄ‚îÄ index.ts           # Main exports
‚îú‚îÄ‚îÄ dist/                  # Compiled JavaScript (gitignored)
‚îú‚îÄ‚îÄ temp/                  # Testing directory (gitignored)
‚îú‚îÄ‚îÄ CLAUDE.md              # AI context (essential info)
‚îú‚îÄ‚îÄ DEVELOPMENT.md         # This file (human development)
‚îú‚îÄ‚îÄ package.json           # NPM configuration
‚îî‚îÄ‚îÄ tsconfig.json          # TypeScript configuration
```

## üîó Important Files

- **CLAUDE.md** - Essential project context for AI assistance
- **package.json** - NPM package configuration and scripts
- **tsconfig.json** - TypeScript compilation settings
- **.gitignore** - Git ignore patterns (includes `temp/`)
- **.vscode/launch.json** - VS Code debugging/testing configurations</code></pre>
    </div>

    <div class="file-section" id="eslint-config-js">
        <div class="file-title">
            <h2>üìÑ eslint.config.js</h2>
        </div>
        <pre><code class="javascript">import js from &#39;@eslint/js&#39;;
import tseslint from &#39;@typescript-eslint/eslint-plugin&#39;;
import tsparser from &#39;@typescript-eslint/parser&#39;;
import importPlugin from &#39;eslint-plugin-import&#39;;
import unicorn from &#39;eslint-plugin-unicorn&#39;;

export default [
  js.configs.recommended,
  {
    files: [&#39;src/**/*.ts&#39;],
    languageOptions: {
      parser: tsparser,
      parserOptions: {
        ecmaVersion: 2022,
        sourceType: &#39;module&#39;,
        project: &#39;./tsconfig.json&#39;
      },
      globals: {
        console: &#39;readonly&#39;,
        process: &#39;readonly&#39;,
        Buffer: &#39;readonly&#39;,
        __dirname: &#39;readonly&#39;,
        __filename: &#39;readonly&#39;,
        NodeJS: &#39;readonly&#39;
      }
    },
    plugins: {
      &#39;@typescript-eslint&#39;: tseslint,
      &#39;import&#39;: importPlugin,
      &#39;unicorn&#39;: unicorn
    },
    rules: {
      // TypeScript strict rules
      &#39;@typescript-eslint/no-explicit-any&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/no-unused-vars&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/prefer-readonly&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/explicit-function-return-type&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/explicit-module-boundary-types&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/no-inferrable-types&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/no-unnecessary-type-assertion&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/prefer-nullish-coalescing&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/prefer-optional-chain&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/prefer-string-starts-ends-with&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/prefer-includes&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/no-floating-promises&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/await-thenable&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/no-misused-promises&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/require-await&#39;: &#39;error&#39;,

      // General code quality
      &#39;no-console&#39;: &#39;off&#39;, // CLI app needs console output
      &#39;no-debugger&#39;: &#39;error&#39;,
      &#39;no-alert&#39;: &#39;error&#39;,
      &#39;no-var&#39;: &#39;error&#39;,
      &#39;prefer-const&#39;: &#39;error&#39;,
      &#39;prefer-arrow-callback&#39;: &#39;error&#39;,
      &#39;prefer-template&#39;: &#39;error&#39;,
      &#39;object-shorthand&#39;: &#39;error&#39;,
      &#39;quote-props&#39;: [&#39;error&#39;, &#39;as-needed&#39;],
      &#39;no-duplicate-imports&#39;: &#39;error&#39;,
      
      // Import rules
      &#39;import/order&#39;: [
        &#39;error&#39;,
        {
          &#39;groups&#39;: [
            &#39;builtin&#39;,
            &#39;external&#39;, 
            &#39;internal&#39;,
            &#39;parent&#39;,
            &#39;sibling&#39;,
            &#39;index&#39;
          ],
          &#39;newlines-between&#39;: &#39;never&#39;,
          &#39;alphabetize&#39;: {
            &#39;order&#39;: &#39;asc&#39;,
            &#39;caseInsensitive&#39;: true
          }
        }
      ],
      &#39;import/no-duplicates&#39;: &#39;error&#39;,

      // Unicorn rules for modern JS practices
      &#39;unicorn/prefer-node-protocol&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-module&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-ternary&#39;: &#39;warn&#39;,
      &#39;unicorn/prefer-logical-operator-over-ternary&#39;: &#39;error&#39;,
      &#39;unicorn/no-array-for-each&#39;: &#39;warn&#39;,
      &#39;unicorn/prefer-array-some&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-array-find&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-array-flat&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-object-from-entries&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-set-has&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-string-slice&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-number-properties&#39;: &#39;error&#39;,
      &#39;unicorn/numeric-separators-style&#39;: &#39;error&#39;,
      &#39;unicorn/better-regex&#39;: &#39;error&#39;,
      &#39;unicorn/catch-error-name&#39;: &#39;error&#39;,
      &#39;unicorn/custom-error-definition&#39;: &#39;error&#39;,
      &#39;unicorn/error-message&#39;: &#39;error&#39;,
      &#39;unicorn/escape-case&#39;: &#39;error&#39;,
      &#39;unicorn/explicit-length-check&#39;: &#39;error&#39;,
      &#39;unicorn/filename-case&#39;: [
        &#39;error&#39;,
        {
          &#39;cases&#39;: {
            &#39;camelCase&#39;: true,
            &#39;pascalCase&#39;: true,
            &#39;kebabCase&#39;: true
          }
        }
      ],
      &#39;unicorn/new-for-builtins&#39;: &#39;error&#39;,
      &#39;unicorn/no-abusive-eslint-disable&#39;: &#39;error&#39;,
      &#39;unicorn/no-array-push-push&#39;: &#39;error&#39;,
      &#39;unicorn/no-console-spaces&#39;: &#39;error&#39;,
      &#39;unicorn/no-hex-escape&#39;: &#39;error&#39;,
      &#39;unicorn/no-instanceof-array&#39;: &#39;error&#39;,
      &#39;unicorn/no-new-buffer&#39;: &#39;error&#39;,
      &#39;unicorn/no-unnecessary-await&#39;: &#39;error&#39;,
      &#39;unicorn/no-useless-length-check&#39;: &#39;error&#39;,
      &#39;unicorn/no-useless-spread&#39;: &#39;error&#39;,
      &#39;unicorn/no-zero-fractions&#39;: &#39;error&#39;,
      &#39;unicorn/number-literal-case&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-add-event-listener&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-array-index-of&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-date-now&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-default-parameters&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-includes&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-math-trunc&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-negative-index&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-optional-catch-binding&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-prototype-methods&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-reflect-apply&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-regexp-test&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-spread&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-string-replace-all&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-string-trim-start-end&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-switch&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-type-error&#39;: &#39;error&#39;,
      &#39;unicorn/throw-new-error&#39;: &#39;error&#39;
    }
  },
  {
    files: [&#39;tests/**/*&#39;, &#39;**/*.test.ts&#39;, &#39;**/*.spec.ts&#39;],
    rules: {
      &#39;@typescript-eslint/no-explicit-any&#39;: &#39;off&#39;,
      &#39;@typescript-eslint/explicit-function-return-type&#39;: &#39;off&#39;,
      &#39;no-console&#39;: &#39;off&#39;
    }
  }
];</code></pre>
    </div>

    <div class="file-section" id="package-json">
        <div class="file-title">
            <h2>üìÑ package.json</h2>
        </div>
        <pre><code class="json">{
    &quot;name&quot;: &quot;project-fusion&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;description&quot;: &quot;CLI tool for merging project files into a single file for easy sharing&quot;,
    &quot;main&quot;: &quot;dist/index.js&quot;,
    &quot;types&quot;: &quot;dist/index.d.ts&quot;,
    &quot;type&quot;: &quot;module&quot;,
    &quot;bin&quot;: {
        &quot;project-fusion&quot;: &quot;dist/cli.js&quot;
    },
    &quot;exports&quot;: {
        &quot;.&quot;: {
            &quot;types&quot;: &quot;./dist/index.d.ts&quot;,
            &quot;import&quot;: &quot;./dist/index.js&quot;
        },
        &quot;./package.json&quot;: &quot;./package.json&quot;
    },
    &quot;files&quot;: [
        &quot;dist/**/*&quot;,
        &quot;README.md&quot;,
        &quot;LICENSE&quot;,
        &quot;CHANGELOG.md&quot;
    ],
    &quot;sideEffects&quot;: false,
    &quot;scripts&quot;: {
        &quot;build&quot;: &quot;tsc&quot;,
        &quot;clean&quot;: &quot;rm -rf dist&quot;,
        &quot;dev&quot;: &quot;tsc --watch&quot;,
        &quot;lint&quot;: &quot;eslint src/**/*.ts&quot;,
        &quot;lint:fix&quot;: &quot;eslint src/**/*.ts --fix&quot;,
        &quot;prepublishOnly&quot;: &quot;npm run clean &amp;&amp; npm run build&quot;,
        &quot;test&quot;: &quot;vitest&quot;,
        &quot;test:coverage&quot;: &quot;vitest run --coverage&quot;,
        &quot;test:ui&quot;: &quot;vitest --ui&quot;,
        &quot;typecheck&quot;: &quot;tsc --noEmit&quot;
    },
    &quot;keywords&quot;: [
        &quot;cli&quot;,
        &quot;code&quot;,
        &quot;collaboration&quot;,
        &quot;files&quot;,
        &quot;fusion&quot;,
        &quot;merge&quot;,
        &quot;sharing&quot;
    ],
    &quot;author&quot;: &quot;the99studio&quot;,
    &quot;license&quot;: &quot;MIT&quot;,
    &quot;engines&quot;: {
        &quot;node&quot;: &quot;&gt;=18.0.0&quot;
    },
    &quot;repository&quot;: {
        &quot;type&quot;: &quot;git&quot;,
        &quot;url&quot;: &quot;https://github.com/the99studio/project-fusion.git&quot;
    },
    &quot;bugs&quot;: {
        &quot;url&quot;: &quot;https://github.com/the99studio/project-fusion/issues&quot;
    },
    &quot;homepage&quot;: &quot;https://github.com/the99studio/project-fusion#readme&quot;,
    &quot;dependencies&quot;: {
        &quot;chalk&quot;: &quot;^5.5.0&quot;,
        &quot;clipboardy&quot;: &quot;^4.0.0&quot;,
        &quot;commander&quot;: &quot;^14.0.0&quot;,
        &quot;fs-extra&quot;: &quot;^11.3.1&quot;,
        &quot;glob&quot;: &quot;^11.0.3&quot;,
        &quot;ignore&quot;: &quot;^7.0.5&quot;,
        &quot;zod&quot;: &quot;^4.0.17&quot;
    },
    &quot;devDependencies&quot;: {
        &quot;@types/fs-extra&quot;: &quot;^11.0.4&quot;,
        &quot;@types/node&quot;: &quot;^24.2.1&quot;,
        &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^8.39.1&quot;,
        &quot;@typescript-eslint/parser&quot;: &quot;^8.39.1&quot;,
        &quot;@vitest/coverage-v8&quot;: &quot;^2.1.9&quot;,
        &quot;eslint&quot;: &quot;^9.33.0&quot;,
        &quot;eslint-plugin-import&quot;: &quot;^2.32.0&quot;,
        &quot;eslint-plugin-node&quot;: &quot;^11.1.0&quot;,
        &quot;eslint-plugin-unicorn&quot;: &quot;^60.0.0&quot;,
        &quot;typescript&quot;: &quot;^5.9.2&quot;,
        &quot;vitest&quot;: &quot;^2.1.6&quot;
    }
}
</code></pre>
    </div>


```

## üìÑ README.md

```markdown
# Project Fusion

Project Fusion merges multiple project files into a single file for sharing and collaboration. It generates three output formats: plain text (.txt), markdown (.md), and HTML (.html) with syntax highlighting.

## Prerequisites

- **Node.js** version 18.0.0 or higher

## Installation

Install Project Fusion globally with npm:

```bash
npm install -g project-fusion
```

## Quick Start

1. **Initialize** Project Fusion in your project directory to customize settings (optional):
   ```bash
   cd your-project-directory
   project-fusion init
   ```

2. **Create fusion files** containing your project files:
   ```bash
   project-fusion
   ```
   This creates three files:
   - `project-fusioned.txt` - Plain text format with file separators
   - `project-fusioned.md` - Markdown format with syntax highlighting and table of contents
   - `project-fusioned.html` - HTML format with syntax highlighting and table of contents

3. **Share the fusion files** for collaboration or analysis

## Commands

- `project-fusion` - Create fusion files from project files (default action)
- `project-fusion init` - Create Project Fusion setting file (optional) in current directory
- `project-fusion config-check` - Validate configuration and show active settings
- `project-fusion --help` - Show help information

## Documentation

- **[CLAUDE.md](./CLAUDE.md)** - AI context and technical documentation
- **[DEVELOPMENT.md](./DEVELOPMENT.md)** - Development workflows and testing
- **[CONTRIBUTING.md](./CONTRIBUTING.md)** - How to contribute to the project
- **[LICENSE](./LICENSE)** - MIT License terms

## Usage Workflow

When sharing your code:

1. Run `project-fusion` to create merged files
2. Choose the appropriate format:
   - **`.txt`** - Universal compatibility with file separators
   - **`.md`** - Syntax highlighting and table of contents
   - **`.html`** - Web format with responsive design and navigation
3. Share the fusion file with colleagues or collaborators
4. Use for code review, AI analysis, documentation, or project overview

The fusion files contain your project files in a single, organized format.

## Configuration

Project Fusion creates a `project-fusion.json` configuration file when you run `init`. You can customize:
- File extensions to include (organized by category: web, backend, config, etc.)
- Directories to scan or ignore
- Output file names and locations
- Use of .gitignore patterns
- Clipboard copying behavior

### Supported File Extensions

Project Fusion supports 35+ file extensions organized by category:
- **Web**: .js, .jsx, .ts, .tsx, .html, .css, .vue, .svelte
- **Backend**: .py, .rb, .java, .cs, .go, .rs, .php
- **Config**: .json, .yaml, .yml, .toml, .xml
- **Scripts**: .sh, .bat, .ps1, .cmd
- **C/C++**: .c, .cpp, .h, .hpp
- **Godot**: .gd, .tscn, .tres, .cfg

The markdown output applies syntax highlighting for each file type.

### HTML Output

Project Fusion can generate HTML files with:

- **Responsive Design**: Styling for viewing and sharing
- **Table of Contents**: Navigation with anchor links to each file
- **Syntax Highlighting**: Code blocks with language detection
- **File Metadata**: Timestamps and file counts in header
- **Layout**: Typography and spacing for readability

Enable HTML generation in your config:

```json
{
  "generateHtml": true
}
```

### Performance Features

- **File Size Limiting**: Configure `maxFileSizeKB` to skip large files (default: 1MB)
- **Streaming Support**: Process large projects with reduced memory usage
- **Performance Metrics**: Benchmarks logged including throughput and memory usage
- **Filtering**: Ignores binary files, images, archives, and compiled files

## Programmatic API

Project Fusion can be used as a library in other Node.js projects, such as VS Code extensions or build tools.

### Installation as a Dependency

```bash
npm install project-fusion
```

### Basic Usage

```typescript
import { fusionAPI, createConfig, runFusion } from 'project-fusion';

// Method 1: Simple API with partial config
const result = await fusionAPI({
    rootDirectory: '/path/to/project',
    generateHtml: false,
    parsedFileExtensions: {
        web: ['.ts', '.tsx'],
        backend: ['.py']
    }
});

// Method 2: Create config then run
const config = createConfig({
    generateHtml: false,
    maxFileSizeKB: 2048,
    ignorePatterns: ['tests/', '*.spec.ts']
});
const result = await runFusion(config);

// Method 3: Direct fusion with options
const result = await runFusion(
    { rootDirectory: '/my/project' },
    { extensionGroups: ['web', 'backend'] }
);
```

### VS Code Extension Example

```typescript
import * as vscode from 'vscode';
import { fusionAPI } from 'project-fusion';

export async function activate(context: vscode.ExtensionContext) {
    const disposable = vscode.commands.registerCommand('extension.fusionProject', async () => {
        const workspacePath = vscode.workspace.rootPath;
        
        if (!workspacePath) {
            vscode.window.showErrorMessage('No workspace folder open');
            return;
        }
        
        try {
            // Run fusion with dynamic config
            const result = await fusionAPI({
                rootDirectory: workspacePath,
                generateHtml: true,
                generateMarkdown: true,
                generateText: false,
                copyToClipboard: false,
                // Custom extensions for this workspace
                parsedFileExtensions: {
                    web: ['.ts', '.tsx', '.jsx'],
                    backend: [],
                    config: ['.json'],
                    cpp: [],
                    scripts: [],
                    godot: [],
                    doc: ['.md']
                }
            });
            
            if (result.success) {
                vscode.window.showInformationMessage(`Fusion completed: ${result.filesProcessed} files processed`);
            }
        } catch (error) {
            vscode.window.showErrorMessage(`Fusion failed: ${error.message}`);
        }
    });
    
    context.subscriptions.push(disposable);
}
```

### API Reference

#### `fusionAPI(options: ProgrammaticFusionOptions): Promise<ProgrammaticFusionResult>`
Main API function for programmatic use with partial configuration.

#### `createConfig(overrides: Partial<Config>): Config`
Creates a complete configuration object with defaults.

#### `runFusion(config: Partial<Config> | Config, options?: FusionOptions): Promise<FusionResult>`
Runs fusion with a configuration object (partial or complete).

## Distribution

- **GitHub**: [github.com/the99studio/project-fusion](https://github.com/the99studio/project-fusion)
- **NPM**: [npmjs.com/package/project-fusion](https://www.npmjs.com/package/project-fusion)

## License

This project is licensed under the MIT License - see the [LICENSE](./LICENSE) file for details.
```

## üìÑ src/api.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Programmatic API for Project Fusion
 * Allows external packages to use fusion functionality without config files
 */
import path from 'node:path';
import { processFusion } from './fusion.js';
import { defaultConfig } from './utils.js';
import type { Config, FilePath, FusionOptions, FusionResult } from './types.js';

/**
 * Options for programmatic fusion
 */
export interface ProgrammaticFusionOptions extends Partial<Config> {
    /** Working directory (defaults to process.cwd()) */
    cwd?: string;
    /** Extension groups to include */
    extensionGroups?: string[];
    /** Root directory override */
    rootDir?: string;
}

/**
 * Result from programmatic fusion
 */
export interface ProgrammaticFusionResult {
    /** Error object (if failed) */
    error?: Error | undefined;
    /** Number of files processed (if successful) */
    filesProcessed?: number;
    /** Path to the fusion file (if successful) */
    fusionFilePath?: FilePath;
    /** Path to the log file */
    logFilePath?: FilePath;
    /** Status message */
    message: string;
    /** Whether the fusion was successful */
    success: boolean;
}

/**
 * Merge partial config with defaults
 * @param partialConfig Partial configuration to merge
 * @param cwd Current working directory
 * @returns Complete configuration
 */
function mergeWithDefaults(partialConfig: Partial<Config>, cwd: string): Config {
    const rootDirectory = partialConfig.rootDirectory || cwd;
    
    return {
        copyToClipboard: partialConfig.copyToClipboard ?? defaultConfig.copyToClipboard,
        generatedFileName: partialConfig.generatedFileName ?? defaultConfig.generatedFileName,
        generateHtml: partialConfig.generateHtml ?? defaultConfig.generateHtml,
        generateMarkdown: partialConfig.generateMarkdown ?? defaultConfig.generateMarkdown,
        generateText: partialConfig.generateText ?? defaultConfig.generateText,
        ignorePatterns: partialConfig.ignorePatterns ?? defaultConfig.ignorePatterns,
        maxFileSizeKB: partialConfig.maxFileSizeKB ?? defaultConfig.maxFileSizeKB,
        parsedFileExtensions: partialConfig.parsedFileExtensions ?? defaultConfig.parsedFileExtensions,
        parseSubDirectories: partialConfig.parseSubDirectories ?? defaultConfig.parseSubDirectories,
        rootDirectory,
        schemaVersion: 1,
        useGitIgnoreForExcludes: partialConfig.useGitIgnoreForExcludes ?? defaultConfig.useGitIgnoreForExcludes
    };
}

/**
 * Process fusion programmatically without requiring a config file
 * @param options Options for fusion including partial config
 * @returns Fusion result with optional file contents
 * 
 * @example
 * ```typescript
 * import { fusionAPI } from 'project-fusion';
 * 
 * // Use with custom configuration
 * const result = await fusionAPI({
 *     rootDirectory: '/path/to/project',
 *     generateHtml: false,
 *     parsedFileExtensions: {
 *         web: ['.ts', '.tsx'],
 *         backend: ['.py']
 *     },
 *     ignorePatterns: ['tests/', '*.spec.ts']
 * });
 * ```
 */
export async function fusionAPI(options: ProgrammaticFusionOptions = {}): Promise<ProgrammaticFusionResult> {
    const cwd = options.cwd || process.cwd();
    
    // Extract fusion options
    const { 
        cwd: _cwd,
        extensionGroups,
        rootDir,
        ...configOptions 
    } = options;
    
    // Build complete configuration
    const config = mergeWithDefaults(configOptions, cwd);
    
    // Override rootDirectory if rootDir is provided in fusion options
    if (rootDir) {
        config.rootDirectory = path.resolve(cwd, rootDir);
    }
    
    // Process fusion with the merged configuration
    const fusionOptions: FusionOptions = extensionGroups 
        ? { extensionGroups }
        : {};
    
    const result = await processFusion(config, fusionOptions);
    
    // Convert FusionResult to ProgrammaticFusionResult
    if (result.success) {
        return {
            fusionFilePath: result.fusionFilePath,
            logFilePath: result.logFilePath,
            message: result.message,
            success: true
            // TODO: Add filesProcessed when available from fusion.ts
        };
    } else {
        const errorResult: ProgrammaticFusionResult = {
            message: result.message,
            success: false
        };
        if (result.logFilePath) {
            errorResult.logFilePath = result.logFilePath;
        }
        if (result.error) {
            errorResult.error = result.error;
        }
        return errorResult;
    }
}

/**
 * Create a custom configuration object for programmatic use
 * @param overrides Configuration overrides
 * @returns Complete configuration object
 * 
 * @example
 * ```typescript
 * import { createConfig, processFusion } from 'project-fusion';
 * 
 * const config = createConfig({
 *     generateHtml: false,
 *     maxFileSizeKB: 2048
 * });
 * 
 * const result = await processFusion(config);
 * ```
 */
export function createConfig(overrides: Partial<Config> = {}): Config {
    return mergeWithDefaults(overrides, process.cwd());
}

/**
 * Programmatically run fusion with a specific configuration
 * Useful for VS Code extensions and other integrations
 * 
 * @param config Complete or partial configuration
 * @param options Additional fusion options
 * @returns Fusion result
 * 
 * @example
 * ```typescript
 * import { runFusion } from 'project-fusion';
 * 
 * // With partial config (uses defaults for missing values)
 * const result = await runFusion({
 *     rootDirectory: '/my/project',
 *     generateHtml: false
 * });
 * 
 * // With extension group filter
 * const result = await runFusion(
 *     { rootDirectory: '/my/project' },
 *     { extensionGroups: ['web', 'backend'] }
 * );
 * ```
 */
export async function runFusion(
    config: Partial<Config> | Config,
    options: FusionOptions = {}
): Promise<FusionResult> {
    // Check if config has all required fields
    const isCompleteConfig = (
        'schemaVersion' in config &&
        'rootDirectory' in config &&
        'parsedFileExtensions' in config
    );
    
    const fullConfig = isCompleteConfig 
        ? config as Config
        : mergeWithDefaults(config, config.rootDirectory || process.cwd());
    
    return await processFusion(fullConfig, options);
}
```

## üìÑ src/benchmark.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Benchmark utilities for performance monitoring
 */
import { performance } from 'node:perf_hooks';
import process from 'node:process';

export interface BenchmarkMetrics {
    averageFileProcessingTime: number;
    duration: number;
    filesProcessed: number;
    memoryUsed: number;
    throughputMBps: number;
    totalSizeMB: number;
}

export class BenchmarkTracker {
    private readonly startTime: number;
    private readonly startMemory: NodeJS.MemoryUsage;
    private readonly fileTimings: number[] = [];
    private filesProcessed = 0;
    private totalBytes = 0;

    constructor() {
        this.startTime = performance.now();
        this.startMemory = process.memoryUsage();
    }

    /**
     * Record file processing metrics
     */
    markFileProcessed(sizeBytes: number, processingTimeMs?: number): void {
        this.filesProcessed++;
        this.totalBytes += sizeBytes;
        if (processingTimeMs !== undefined) {
            this.fileTimings.push(processingTimeMs);
        }
    }

    /**
     * Calculate and return performance metrics
     */
    getMetrics(): BenchmarkMetrics {
        const endTime = performance.now();
        const endMemory = process.memoryUsage();
        
        const duration = (endTime - this.startTime) / 1000; // seconds
        const memoryUsed = (endMemory.heapUsed - this.startMemory.heapUsed) / (1024 * 1024); // MB
        const totalSizeMB = this.totalBytes / (1024 * 1024);
        
        const averageFileProcessingTime = this.fileTimings.length > 0
            ? this.fileTimings.reduce((a, b) => a + b, 0) / this.fileTimings.length
            : 0;
        
        const throughputMBps = duration > 0 ? totalSizeMB / duration : 0;

        return {
            duration,
            memoryUsed,
            filesProcessed: this.filesProcessed,
            totalSizeMB,
            averageFileProcessingTime,
            throughputMBps
        };
    }

}
```

## üìÑ src/cli.ts

```typescript
#!/usr/bin/env node
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Command-line interface for Project Fusion
 */
import { Command } from 'commander';
import pkg from '../package.json' with { type: 'json' };
import {
    runConfigCheckCommand,
    runFusionCommand,
    runInitCommand
} from './clicommands.js';

const program = new Command();

program
    .name('project-fusion')
    .description('Project Fusion - Efficient project file management and sharing')
    .version(pkg.version, '-v, --version');

// Default command (fusion) - runs when no subcommand is specified
program
    .option('--extensions <groups>', 'Comma-separated list of extension groups (e.g., backend,web)')
    .option('--root <directory>', 'Root directory to start scanning from (defaults to current directory)')
    .action((options) => {
        // Default action is to run fusion
        void runFusionCommand(options);
    });


// Init command
program
    .command('init')
    .description('Initialize Project Fusion in the current directory')
    .option('--force', 'Force initialization even if configuration already exists')
    .action((options) => {
        void runInitCommand(options);
    });

// Config check command
program
    .command('config-check')
    .description('Validate project-fusion.json and display active groups/extensions')
    .action(() => {
        void runConfigCheckCommand();
    });

// Parse arguments with Commander.js
program.parse(process.argv);
```

## üìÑ src/clicommands.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * CLI commands implementation
 */
import path from 'node:path';
import chalk from 'chalk';
import clipboardy from 'clipboardy';
import fs from 'fs-extra';
import { processFusion } from './fusion.js';
import { ConfigSchemaV1 } from './schema.js';
import type { Config, FusionOptions } from './types.js';
import { defaultConfig, getExtensionsFromGroups, loadConfig } from './utils.js';

/**
 * Run the fusion command
 * @param options Command options
 */
export async function runFusionCommand(options: { extensions?: string, root?: string }): Promise<void> {
    try {
        console.log(chalk.blue('üîÑ Starting Fusion Process...'));

        const config = await loadConfig();

        if (options.root) {
            config.rootDirectory = options.root;
            console.log(chalk.yellow(`‚ÑπÔ∏è Using specified directory as root: ${options.root}`));
        }

        // Parse extension groups from command line (comma-separated)
        let extensionGroups: string[] | undefined;
        if (options.extensions) {
            extensionGroups = options.extensions.split(',').map(e => e.trim());
            console.log(chalk.blue(`Using extension groups: ${extensionGroups.join(', ')}`));
        }

        const fusionOptions: FusionOptions = extensionGroups ? { extensionGroups } : {};
        const result = await processFusion(config, fusionOptions);

        if (result.success) {
            console.log(chalk.green(`‚úÖ ${result.message}`));
            console.log(chalk.green(`üìÑ Generated files:`));
            
            if (config.generateText) {
                console.log(chalk.cyan(`   - ${config.generatedFileName}.txt`));
            }
            if (config.generateMarkdown) {
                console.log(chalk.cyan(`   - ${config.generatedFileName}.md`));
            }
            if (config.generateHtml) {
                console.log(chalk.cyan(`   - ${config.generatedFileName}.html`));
            }

            // Copy fusion content to clipboard if enabled (skip in CI/non-interactive environments)
            const isNonInteractive = process.env['CI'] === 'true' || !process.stdout.isTTY;
            if (config.copyToClipboard === true && result.fusionFilePath && !isNonInteractive) {
                try {
                    const fusionContent = await fs.readFile(result.fusionFilePath, 'utf8');
                    await clipboardy.write(fusionContent);
                    console.log(chalk.blue(`üìã Fusion content copied to clipboard`));
                } catch (clipboardError) {
                    console.warn(chalk.yellow(`‚ö†Ô∏è Could not copy to clipboard: ${clipboardError}`));
                }
            } else if (config.copyToClipboard === true && isNonInteractive) {
                console.log(chalk.gray(`üìã Clipboard copy skipped (non-interactive environment)`));
            }

            console.log(chalk.gray(`üìù Log file available at: ${result.logFilePath}`));
        } else {
            console.log(chalk.red(`‚ùå ${result.message}`));
            if (result.logFilePath) {
                console.log(chalk.gray(`üìù Check log file for details: ${result.logFilePath}`));
            }
        }
    } catch (error) {
        console.error(chalk.red(`‚ùå Fusion process failed: ${error}`));
        process.exit(1);
    }
}


/**
 * Run the init command to initialize the config
 */
export async function runInitCommand(options: { force?: boolean } = {}): Promise<void> {
    try {
        console.log(chalk.blue('üîÑ Initializing Project Fusion...'));

        const configPath = path.resolve('./project-fusion.json');
        if (await fs.pathExists(configPath)) {
            if (!options.force) {
                console.log(chalk.yellow('‚ö†Ô∏è project-fusion.json file already exists.'));
                console.log(chalk.yellow('Use --force to override or delete project-fusion.json and run init again.'));
                process.exit(1);
            } else {
                console.log(chalk.yellow('‚ö†Ô∏è Overriding existing configuration file with --force option.'));
            }
        }

        await fs.writeJson(configPath, defaultConfig, { spaces: 4 });

        console.log(chalk.green('‚úÖ Project Fusion initialized successfully!'));
        console.log(chalk.blue('üìÅ Created:'));
        console.log(chalk.cyan('  - ./project-fusion.json'));

        console.log(chalk.blue('\nüìù Next steps:'));
        console.log(chalk.cyan('  1. Review project-fusion.json and adjust as needed'));
        console.log(chalk.cyan('  2. Run fusion: project-fusion'));
    } catch (error) {
        console.error(chalk.red(`‚ùå Initialization failed: ${error}`));
        process.exit(1);
    }
}

/**
 * Run the config-check command to validate configuration
 */
export async function runConfigCheckCommand(): Promise<void> {
    try {
        console.log(chalk.blue('üîç Checking Project Fusion Configuration...'));

        const configPath = path.resolve('./project-fusion.json');
        
        // Verify configuration file exists
        if (!await fs.pathExists(configPath)) {
            console.log(chalk.yellow('‚ö†Ô∏è No project-fusion.json found.'));
            console.log(chalk.cyan('   Using default configuration.'));
            console.log(chalk.gray('   Run "project-fusion init" to create a configuration file.'));
            
            await displayConfigInfo(defaultConfig, true);
            return;
        }

        // Load and parse configuration
        let configContent: string;
        try {
            configContent = await fs.readFile(configPath, 'utf8');
        } catch (error) {
            console.log(chalk.red(`‚ùå Cannot read configuration file: ${error}`));
            process.exit(1);
        }

        let parsedConfig: unknown;
        try {
            parsedConfig = JSON.parse(configContent);
        } catch (error) {
            console.log(chalk.red(`‚ùå Invalid JSON in configuration file: ${error}`));
            process.exit(1);
        }

        // Validate configuration against schema
        const validation = ConfigSchemaV1.safeParse(parsedConfig);
        
        if (!validation.success) {
            console.log(chalk.red('‚ùå Configuration validation failed:'));
            
            // Show detailed validation errors
            // Display detailed validation errors with helpful context
            for (const [index, issue] of validation.error.issues.entries()) {
                const path = issue.path.length > 0 ? issue.path.join('.') : 'root';
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const value = issue.path.reduce((obj: any, key) => obj?.[key], parsedConfig);
                console.log(chalk.red(`   ${index + 1}. Path: ${chalk.yellow(path)}`));
                console.log(chalk.red(`      Error: ${issue.message}`));
                console.log(chalk.red(`      Current value: ${chalk.cyan(JSON.stringify(value))}`));
                if (issue.code === 'invalid_type') {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    console.log(chalk.red(`      Expected: ${chalk.green((issue as any).expected)}, received: ${chalk.magenta((issue as any).received)}`));
                }
            }
            
            console.log(chalk.yellow('\nüí° Suggestions:'));
            console.log(chalk.cyan('   - Check your configuration against the schema'));
            console.log(chalk.cyan('   - Run "project-fusion init --force" to reset to default config'));
            process.exit(1);
        }

        console.log(chalk.green('‚úÖ Configuration is valid!'));
        await displayConfigInfo(validation.data, false);

    } catch (error) {
        console.error(chalk.red(`‚ùå Config check failed: ${error}`));
        process.exit(1);
    }
}

/**
 * Display comprehensive configuration summary with preview
 */
async function displayConfigInfo(config: Config, isDefault: boolean): Promise<void> {
    console.log(chalk.blue('\nüìã Configuration Summary:'));
    
    if (isDefault) {
        console.log(chalk.gray('   (Using default configuration)\n'));
    } else {
        console.log('');
    }

    // Core configuration settings
    console.log(chalk.cyan('üîß Basic Settings:'));
    console.log(`   Schema Version: ${config.schemaVersion}`);
    console.log(`   Root Directory: ${config.rootDirectory}`);
    console.log(`   Scan Subdirectories: ${config.parseSubDirectories ? 'Yes' : 'No'}`);
    console.log(`   Use .gitignore: ${config.useGitIgnoreForExcludes ? 'Yes' : 'No'}`);
    console.log(`   Copy to Clipboard: ${config.copyToClipboard ? 'Yes' : 'No'}`);
    console.log(`   Max File Size: ${config.maxFileSizeKB} KB`);

    // File generation options
    console.log(chalk.cyan('\nüìÑ Output Generation:'));
    console.log(`   Generated File Name: ${config.generatedFileName}`);
    console.log(`   Generate Text: ${config.generateText ? 'Yes' : 'No'}`);
    console.log(`   Generate Markdown: ${config.generateMarkdown ? 'Yes' : 'No'}`);
    console.log(`   Generate HTML: ${config.generateHtml ? 'Yes' : 'No'}`);
    console.log(`   Log File: project-fusion.log`);

    // File type configuration
    console.log(chalk.cyan('\nüìÅ File Extension Groups:'));
    const totalExtensions = getExtensionsFromGroups(config);
    
    for (const [group, extensions] of Object.entries(config.parsedFileExtensions)) {
        if (extensions) {
            console.log(`   ${group}: ${extensions.length} extensions (${extensions.join(', ')})`);
        }
    }
    
    console.log(chalk.gray(`   Total: ${totalExtensions.length} unique extensions`));

    // Pattern exclusions
    console.log(chalk.cyan('\nüö´ Ignore Patterns:'));
    if (config.ignorePatterns.length === 0) {
        console.log('   None defined');
    } else {
        for (const pattern of config.ignorePatterns.slice(0, 10)) {
            console.log(`   ${pattern}`);
        }
        if (config.ignorePatterns.length > 10) {
            console.log(chalk.gray(`   ... and ${config.ignorePatterns.length - 10} more`));
        }
    }

    // Preview matching files using current configuration
    console.log(chalk.cyan('\nüîç File Discovery Preview:'));
    try {
        const { glob } = await import('glob');
        const rootDir = path.resolve(config.rootDirectory);
        
        // Create glob pattern to preview file discovery
        const allExtensionsPattern = totalExtensions.map(ext => ext.startsWith('.') ? ext : `.${ext}`);
        const pattern = config.parseSubDirectories
            ? `${rootDir}/**/*@(${allExtensionsPattern.join('|')})` // Recursive search
            : `${rootDir}/*@(${allExtensionsPattern.join('|')})`; // Root-only search

        const filePaths = await glob(pattern, { 
            nodir: true,
            follow: false
        });

        console.log(`   Pattern: ${pattern}`);
        console.log(`   Files found: ${filePaths.length}`);
        
        if (filePaths.length > 0) {
            console.log(`   Sample files:`);
            for (const file of filePaths.slice(0, 5)) {
                const relativePath = path.relative(rootDir, file);
                console.log(`     ${relativePath}`);
            }
            if (filePaths.length > 5) {
                console.log(chalk.gray(`     ... and ${filePaths.length - 5} more`));
            }
        }
    } catch (error) {
        console.log(chalk.yellow(`   Could not preview files: ${error}`));
    }
}
```

## üìÑ src/fusion.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Fusion functionality - Optimized single-file-in-memory approach
 */
import { createWriteStream } from 'node:fs';
import path from 'node:path';
import fs from 'fs-extra';
import { glob } from 'glob';
import ignoreLib from 'ignore';
import { BenchmarkTracker } from './benchmark.js';
import { createFilePath, type Config, type FusionOptions, type FusionResult } from './types.js';
import {
    ensureDirectoryExists,
    formatLocalTimestamp,
    formatTimestamp,
    getExtensionsFromGroups,
    getMarkdownLanguage,
    logConfigSummary,
    writeLog
} from './utils.js';

/**
 * Process fusion of files - Optimized memory-efficient version
 * @param config Configuration
 * @param options Fusion options
 * @returns Fusion result
 */
export async function processFusion(
    config: Config,
    options: FusionOptions = {}
): Promise<FusionResult> {
    const benchmark = new BenchmarkTracker();
    
    try {
        // Note: parsing properties are now directly in config (flattened structure)
        const logFilePath = createFilePath(path.resolve('project-fusion.log'));
        const fusionFilePath = createFilePath(path.resolve(`${config.generatedFileName}.txt`));
        const mdFilePath = createFilePath(path.resolve(`${config.generatedFileName}.md`));
        const htmlFilePath = createFilePath(path.resolve(`${config.generatedFileName}.html`));
        const startTime = new Date();

        await fs.writeFile(logFilePath, '');
        await logConfigSummary(logFilePath, config);

        const extensions = getExtensionsFromGroups(config, options.extensionGroups);
        console.log(`Processing ${extensions.length} file extensions from ${Object.keys(config.parsedFileExtensions).length} categories`);
        
        if (extensions.length === 0) {
            const message = 'No file extensions to process.';
            await writeLog(logFilePath, `Status: Fusion failed\nReason: ${message}`, true);
            return { success: false, message, logFilePath };
        }

        // Initialize ignore handler for filtering files based on patterns
        const ig = ignoreLib();
        const rootDir = path.resolve(config.rootDirectory);

        // Load ignore patterns from .gitignore and custom config
        if (config.useGitIgnoreForExcludes) {
            const gitIgnorePath = path.join(rootDir, '.gitignore');
            if (await fs.pathExists(gitIgnorePath)) {
                const gitIgnoreContent = await fs.readFile(gitIgnorePath, 'utf8');
                ig.add(gitIgnoreContent);
            }
        }

        if (config.ignorePatterns.length > 0) {
            const patterns = config.ignorePatterns
                .filter(pattern => pattern.trim() !== '' && !pattern.startsWith('#'))
                .join('\n');
            ig.add(patterns);
        }

        // Create file discovery pattern based on extensions and subdirectory settings
        // Build glob pattern for file discovery: ensure extensions start with '.' and handle subdirectory option
        const allExtensionsPattern = extensions.map(ext => ext.startsWith('.') ? ext : `.${ext}`);
        const pattern = config.parseSubDirectories
            ? `${rootDir}/**/*@(${allExtensionsPattern.join('|')})` // Recursive pattern
            : `${rootDir}/*@(${allExtensionsPattern.join('|')})`; // Root-only pattern

        let filePaths = await glob(pattern, { 
            nodir: true,
            follow: false
        });
        const originalFileCount = filePaths.length;
        filePaths = filePaths.filter(file => {
            const relativePath = path.relative(rootDir, file);
            return !ig.ignores(relativePath);
        });
        console.log(`Found ${originalFileCount} files, ${filePaths.length} after filtering (${((originalFileCount - filePaths.length) / originalFileCount * 100).toFixed(1)}% filtered)`);

        if (filePaths.length === 0) {
            const message = 'No files found to process.';
            const endTime = new Date();
            await writeLog(logFilePath, `Status: Fusion failed\nReason: ${message}\nStart time: ${formatTimestamp(startTime)}\nEnd time: ${formatTimestamp(endTime)}\nDuration: ${((endTime.getTime() - startTime.getTime()) / 1000).toFixed(2)}s`, true);
            return { success: false, message, logFilePath };
        }

        // Extract project metadata for the fusion header
        const projectName = path.basename(process.cwd());
        let packageName = "";
        let projectVersion = "";
        const packageJsonPath = path.join(process.cwd(), 'package.json');
        if (await fs.pathExists(packageJsonPath)) {
            try {
                const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));
                if (packageJson.name) {
                    packageName = packageJson.name;
                }
                if (packageJson.version) {
                    projectVersion = packageJson.version;
                }
            } catch (error) {
                console.warn('Error reading package.json:', error);
            }
        }

        // Sort files alphabetically for consistent output across runs
        filePaths.sort((a, b) => path.relative(rootDir, a).localeCompare(path.relative(rootDir, b)));

        // Track extension usage for comprehensive reporting
        const foundExtensions = new Set<string>();
        const otherExtensions = new Set<string>();
        const allFilesPattern = config.parseSubDirectories ? `${rootDir}/**/*.*` : `${rootDir}/*.*`;
        const allFiles = await glob(allFilesPattern, { nodir: true, follow: false });

        const allConfiguredExtensions = Object.values(config.parsedFileExtensions).flat();
        const configuredExtensionSet = new Set(allConfiguredExtensions);
        // Discover unconfigured extensions for comprehensive reporting
        for (const file of allFiles) {
            const relativePath = path.relative(rootDir, file);
            const ext = path.extname(file).toLowerCase();

            // Track extensions found in project but not configured for processing
            if (ext && !ig.ignores(relativePath) && !configuredExtensionSet.has(ext)) {
                otherExtensions.add(ext);
            }
        }

        // Pre-process files: validate sizes and collect metadata
        const maxFileSizeKB = config.maxFileSizeKB;
        const filesToProcess: { path: string; relativePath: string; size: number }[] = [];
        const skippedFiles: string[] = [];
        let skippedCount = 0;
        let totalSizeBytes = 0;

        for (const filePath of filePaths) {
            const relativePath = path.relative(rootDir, filePath);
            const fileExt = path.extname(filePath).toLowerCase();
            foundExtensions.add(fileExt);

            try {
                const stats = await fs.stat(filePath);
                const sizeKB = stats.size / 1024;
                totalSizeBytes += stats.size;

                if (sizeKB > maxFileSizeKB) {
                    skippedCount++;
                    skippedFiles.push(relativePath);
                    await writeLog(logFilePath, `Skipped large file: ${relativePath} (${sizeKB.toFixed(2)} KB)`, true);
                } else {
                    filesToProcess.push({ path: filePath, relativePath, size: stats.size });
                }
            } catch (error) {
                await writeLog(logFilePath, `Error checking file ${filePath}: ${error}`, true);
                console.error(`Error checking file ${filePath}:`, error);
            }
        }

        // Create output directories for enabled formats
        if (config.generateText) await ensureDirectoryExists(path.dirname(fusionFilePath));
        if (config.generateMarkdown) await ensureDirectoryExists(path.dirname(mdFilePath));
        if (config.generateHtml) await ensureDirectoryExists(path.dirname(htmlFilePath));

        // Initialize write streams for concurrent file generation
        const txtStream = config.generateText ? createWriteStream(fusionFilePath) : null;
        const mdStream = config.generateMarkdown ? createWriteStream(mdFilePath) : null;
        const htmlStream = config.generateHtml ? createWriteStream(htmlFilePath) : null;
        

        // Generate format-specific headers with project metadata
        const projectTitle = packageName && packageName.toLowerCase() !== projectName.toLowerCase() 
            ? `${projectName} / ${packageName}` 
            : projectName;
        const versionInfo = projectVersion ? ` v${projectVersion}` : '';
        
        const txtHeader = `# Generated Project Fusion File\n` +
            `# Project: ${projectTitle}${versionInfo}\n` +
            `# Generated: ${formatLocalTimestamp()}\n` +
            `# UTC: ${formatTimestamp()}\n` +
            `# Files: ${filesToProcess.length}\n` +
            `# Generated by: project-fusion\n\n`;

        const mdHeader = `# Generated Project Fusion File\n\n` +
            `**Project:** ${projectTitle}${versionInfo}\n\n` +
            `**Generated:** ${formatLocalTimestamp()}\n\n` +
            `**UTC:** ${formatTimestamp()}\n\n` +
            `**Files:** ${filesToProcess.length}\n\n` +
            `**Generated by:** [project-fusion](https://github.com/the99studio/project-fusion)\n\n` +
            `---\n\n## üìÅ Table of Contents\n\n`;

        const htmlHeader = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Fusion - ${projectTitle}${versionInfo}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { border-bottom: 2px solid #eee; padding-bottom: 20px; margin-bottom: 30px; }
        .file-section { margin-bottom: 40px; border: 1px solid #ddd; border-radius: 8px; padding: 20px; }
        .file-title { background: #f5f5f5; margin: -20px -20px 20px -20px; padding: 15px 20px; border-radius: 8px 8px 0 0; }
        pre { background: #f8f9fa; padding: 15px; border-radius: 6px; overflow-x: auto; }
        code { font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; }
        .toc { background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 30px; }
        .toc ul { margin: 0; padding-left: 20px; }
        .toc a { text-decoration: none; color: #0366d6; }
        .toc a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Generated Project Fusion File</h1>
        <p><strong>Project:</strong> ${projectTitle}${versionInfo}</p>
        <p><strong>Generated:</strong> ${formatLocalTimestamp()}</p>
        <p><strong>UTC:</strong> ${formatTimestamp()}</p>
        <p><strong>Files:</strong> ${filesToProcess.length}</p>
        <p><strong>Generated by:</strong> <a href="https://github.com/the99studio/project-fusion">project-fusion</a></p>
    </div>
    <div class="toc">
        <h2>üìÅ Table of Contents</h2>
        <ul>
${filesToProcess.map(fileInfo => `            <li><a href="#${fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, '-').toLowerCase()}">${fileInfo.relativePath}</a></li>`).join('\n')}
        </ul>
    </div>`;

        if (txtStream) txtStream.write(txtHeader);
        if (mdStream) mdStream.write(mdHeader);
        if (htmlStream) htmlStream.write(htmlHeader);
        
        // Generate table of contents for markdown format
        if (mdStream) {
            for (const fileInfo of filesToProcess) {
                mdStream.write(`- [${fileInfo.relativePath}](#${fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, '-').toLowerCase()})\n`);
            }
            mdStream.write(`\n---\n\n`);
        }

        // Stream-process files to maintain low memory footprint
        let processedCount = 0;
        for (const fileInfo of filesToProcess) {
            try {
                const content = await fs.readFile(fileInfo.path, 'utf8');
                const fileExt = path.extname(fileInfo.path).toLowerCase();
                const basename = path.basename(fileInfo.path);
                const language = getMarkdownLanguage(fileExt || basename);
                // Escape HTML entities for safe HTML output
                const escapedContent = content
                    .replaceAll('&', '&amp;')
                    .replaceAll('<', '&lt;')
                    .replaceAll('>', '&gt;')
                    .replaceAll('"', '&quot;')
                    .replaceAll('\'', '&#39;');
                
                // Generate plain text format with file separators
                if (txtStream) {
                    txtStream.write(`<!-- ============================================================ -->\n`);
                    txtStream.write(`<!-- FILE: ${fileInfo.relativePath.padEnd(54)} -->\n`);
                    txtStream.write(`<!-- ============================================================ -->\n`);
                    txtStream.write(`${content}\n\n`);
                }

                // Generate markdown format with syntax highlighting
                if (mdStream) {
                    mdStream.write(`## üìÑ ${fileInfo.relativePath}\n\n`);
                    mdStream.write(`\`\`\`${language}\n`);
                    mdStream.write(`${content}\n`);
                    mdStream.write(`\`\`\`\n\n`);
                }

                // Generate HTML format with styled code blocks
                if (htmlStream) {
                    // Create URL-safe anchor ID for navigation
                    const fileAnchor = fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, '-').toLowerCase();
                    htmlStream.write(`    <div class="file-section" id="${fileAnchor}">\n`);
                    htmlStream.write(`        <div class="file-title">\n`);
                    htmlStream.write(`            <h2>üìÑ ${fileInfo.relativePath}</h2>\n`);
                    htmlStream.write(`        </div>\n`);
                    htmlStream.write(`        <pre><code class="${language}">${escapedContent}</code></pre>\n`);
                    htmlStream.write(`    </div>\n\n`);
                }

                processedCount++;
                benchmark.markFileProcessed(fileInfo.size);
            } catch (error) {
                await writeLog(logFilePath, `Error processing file ${fileInfo.path}: ${error}`, true);
                console.error(`Error processing file ${fileInfo.path}:`, error);
            }
        }

        // Finalize HTML document structure
        if (htmlStream) {
            htmlStream.write(`</body>\n</html>`);
        }

        // Ensure all streams are properly closed before HTML generation
        if (txtStream) {
            await new Promise<void>((resolve, reject) => {
                txtStream.end((err?: Error | null) => err ? reject(err) : resolve());
            });
        }
        if (mdStream) {
            await new Promise<void>((resolve, reject) => {
                mdStream.end((err?: Error | null) => err ? reject(err) : resolve());
            });
        }
        if (htmlStream) {
            await new Promise<void>((resolve, reject) => {
                htmlStream.end((err?: Error | null) => err ? reject(err) : resolve());
            });
        }


        // Generate detailed completion report with metrics
        const message = `Fusion completed successfully. ${processedCount} files processed${skippedCount > 0 ? `, ${skippedCount} skipped` : ''}.`;
        const endTime = new Date();
        const duration = ((endTime.getTime() - startTime.getTime()) / 1000).toFixed(2);
        const totalSizeMB = (totalSizeBytes / (1024 * 1024)).toFixed(2);
        
        await writeLog(logFilePath, `Status: Fusion completed successfully`, true);
        await writeLog(logFilePath, `Start time: ${formatTimestamp(startTime)}`, true);
        await writeLog(logFilePath, `End time: ${formatTimestamp(endTime)}`, true);
        await writeLog(logFilePath, `Duration: ${duration}s`, true);
        await writeLog(logFilePath, `Total data processed: ${totalSizeMB} MB`, true);
        
        // Include performance benchmarks in log
        const metrics = benchmark.getMetrics();
        await writeLog(logFilePath, `\nPerformance Metrics:`, true);
        await writeLog(logFilePath, `  Memory Used: ${metrics.memoryUsed.toFixed(2)} MB`, true);
        await writeLog(logFilePath, `  Throughput: ${metrics.throughputMBps.toFixed(2)} MB/s`, true);
        await writeLog(logFilePath, `  Files/second: ${(metrics.filesProcessed / metrics.duration).toFixed(2)}`, true);
        
        await writeLog(logFilePath, `Files found: ${originalFileCount}`, true);
        await writeLog(logFilePath, `Files processed successfully: ${processedCount}`, true);
        await writeLog(logFilePath, `Files skipped (too large): ${skippedCount}`, true);
        await writeLog(logFilePath, `Files filtered out: ${originalFileCount - filePaths.length}`, true);
        
        await writeLog(logFilePath, `Max file size limit: ${maxFileSizeKB} KB`, true);
        
        if (skippedFiles.length > 0) {
            await writeLog(logFilePath, `Skipped files:`, true);
            for (const file of skippedFiles.slice(0, 10)) {
                await writeLog(logFilePath, `  ${file}`, true);
            }
            if (skippedFiles.length > 10) {
                await writeLog(logFilePath, `  ... and ${skippedFiles.length - 10} more`, true);
            }
        }
        
        await writeLog(logFilePath, `File extensions actually processed:`, true);
        const foundExtArray = [...foundExtensions].sort();
        for (const ext of foundExtArray) {
            await writeLog(logFilePath, `  ${ext}`, true);
        }
        
        const ignoredExtensions = extensions.filter(ext => ![...foundExtensions].includes(ext));
        if (ignoredExtensions.length > 0) {
            await writeLog(logFilePath, `Configured extensions with no matching files found:`, true);
            for (const ext of ignoredExtensions.sort()) {
                await writeLog(logFilePath, `  ${ext}`, true);
            }
        }
        
        if (otherExtensions.size > 0) {
            await writeLog(logFilePath, `File extensions found in project but not configured for processing:`, true);
            for (const ext of [...otherExtensions].sort()) {
                await writeLog(logFilePath, `  ${ext}`, true);
            }
        }
        
        const generatedFormats = [];
        if (config.generateText) generatedFormats.push('.txt');
        if (config.generateMarkdown) generatedFormats.push('.md');
        if (config.generateHtml) generatedFormats.push('.html');
        
        return {
            success: true,
            message: `${message} Generated formats: ${generatedFormats.join(', ')}.`,
            fusionFilePath: config.generateText ? fusionFilePath : mdFilePath,
            logFilePath
        };
    } catch (error) {
        const errorMessage = `Fusion process failed: ${error}`;
        console.error(errorMessage);

        try {
            const logFilePath = createFilePath(path.resolve('project-fusion.log'));
            const endTime = new Date();
            await writeLog(logFilePath, `Status: Fusion failed due to error\nError details: ${errorMessage}\nEnd time: ${formatTimestamp(endTime)}`, true);

            return {
                success: false,
                message: errorMessage,
                logFilePath,
                error: error as Error
            };
        } catch (logError) {
            console.error('Could not write to log file:', logError);
            return {
                success: false,
                message: errorMessage,
                error: error as Error
            };
        }
    }
}
```

## üìÑ src/index.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Entry point for Project Fusion
 */

// Programmatic API - Main exports for external packages
export { 
    createConfig,
    fusionAPI,
    runFusion,
    type ProgrammaticFusionOptions,
    type ProgrammaticFusionResult 
} from './api.js';

// Core functionality
export { BenchmarkTracker, type BenchmarkMetrics } from './benchmark.js';
export { processFusion } from './fusion.js';

// Types and schemas
export * from './schema.js';
export * from './types.js';

// Utilities
export * from './utils.js';

```

## üìÑ src/schema.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Configuration schema definitions for Project Fusion
 */
import { z } from 'zod';

/**
 * File extension groups with support for custom categories
 */
const ParsedFileExtensionsSchema = z.object({
    backend: z.array(z.string()).default([".cs", ".go", ".java", ".php", ".py", ".rb", ".rs"]),
    config: z.array(z.string()).default([".json", ".toml", ".xml", ".yaml", ".yml"]),
    cpp: z.array(z.string()).default([".c", ".cc", ".cpp", ".h", ".hpp"]),
    doc: z.array(z.string()).default([".adoc", ".md", ".rst"]),
    godot: z.array(z.string()).default([".cfg", ".cs", ".gd", ".import", ".tscn", ".tres"]),
    scripts: z.array(z.string()).default([".bat", ".cmd", ".ps1", ".sh"]),
    web: z.array(z.string()).default([".css", ".html", ".js", ".jsx", ".svelte", ".ts", ".tsx", ".vue"]),
}).and(z.record(z.string(), z.array(z.string())));

/**
 * Complete configuration schema for version 1
 */
export const ConfigSchemaV1 = z.object({
    copyToClipboard: z.boolean().default(false),
    generatedFileName: z.string().default("project-fusioned"),
    generateHtml: z.boolean().default(true),
    generateMarkdown: z.boolean().default(true),
    generateText: z.boolean().default(true),
    maxFileSizeKB: z.number().default(1024),
    parseSubDirectories: z.boolean().default(true),
    parsedFileExtensions: ParsedFileExtensionsSchema.default({
        backend: [".cs", ".go", ".java", ".php", ".py", ".rb", ".rs"],
        config: [".json", ".toml", ".xml", ".yaml", ".yml"],
        cpp: [".c", ".cc", ".cpp", ".h", ".hpp"],
        doc: [".adoc", ".md", ".rst"],
        godot: [".cfg", ".cs", ".gd", ".import", ".tscn", ".tres"],
        scripts: [".bat", ".cmd", ".ps1", ".sh"],
        web: [".css", ".html", ".js", ".jsx", ".svelte", ".ts", ".tsx", ".vue"]
    }),
    ignorePatterns: z.array(z.string()).default([
        "project-fusion.json",
        "project-fusion.log",
        "project-fusioned.*",
        "node_modules/",
        "package-lock.json",
        "pnpm-lock.yaml",
        "yarn.lock",
        "dist/",
        "build/",
        "*.min.js",
        "*.min.css",
        ".env",
        ".env.*",
        "*.key",
        "*.pem",
        "**/credentials/*",
        "**/secrets/*",
        "*.log",
        "logs/",
        ".DS_Store",
        "Thumbs.db",
        ".vscode/",
        ".idea/",
        "*.swp",
        "*.swo",
        "*.zip",
        "*.tar",
        "*.tgz",
        "*.gz",
        "*.7z",
        "*.rar",
        "*.png",
        "*.jpg",
        "*.jpeg",
        "*.gif",
        "*.bmp",
        "*.ico",
        "*.svg",
        "*.webp",
        "*.pdf",
        "*.doc",
        "*.docx",
        "*.xls",
        "*.xlsx",
        "*.ppt",
        "*.pptx",
        "*.mp3",
        "*.mp4",
        "*.avi",
        "*.mov",
        "*.wmv",
        "*.flv",
        "*.wav",
        "*.flac",
        "*.unitypackage",
        "*.uasset",
        "*.fbx",
        "*.obj",
        "*.blend",
        "*.exe",
        "*.dll",
        "*.so",
        "*.dylib",
        "*.a",
        "*.o",
        "*.pyc",
        "*.pyo",
        "*.class",
        "*.jar",
        "*.war"
    ]),
    rootDirectory: z.string().default("."),
    schemaVersion: z.literal(1).default(1),
    useGitIgnoreForExcludes: z.boolean().default(true),
});
```

## üìÑ src/types.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Type definitions for the fusion functionality
 */

// Branded types for type-safe handling
export type FilePath = string & { readonly __brand: unique symbol };

export const createFilePath = (path: string): FilePath => {
    if (!path || typeof path !== 'string') {
        throw new FusionError('Invalid file path provided', 'INVALID_PATH', 'error');
    }
    return path as FilePath;
};

// Enhanced error hierarchy with codes and severity
export type FusionErrorCode = 
    | 'INVALID_PATH'
    | 'UNKNOWN_EXTENSION_GROUP';

export type FusionErrorSeverity = 'error' | 'warning' | 'info';

export class FusionError extends Error {
    public readonly code: FusionErrorCode;
    public readonly severity: FusionErrorSeverity;
    public readonly context: Record<string, unknown> | undefined;

    constructor(
        message: string, 
        code: FusionErrorCode, 
        severity: FusionErrorSeverity = 'error',
        context?: Record<string, unknown>
    ) {
        super(message);
        this.name = 'FusionError';
        this.code = code;
        this.severity = severity;
        this.context = context;
    }
}

/**
 * Main configuration interface
 */
export interface Config {
    copyToClipboard: boolean;
    generatedFileName: string;
    generateHtml: boolean;
    generateMarkdown: boolean;
    generateText: boolean;
    ignorePatterns: string[];
    maxFileSizeKB: number;
    parsedFileExtensions: {
        backend?: string[];
        config?: string[];
        cpp?: string[];
        doc?: string[];
        godot?: string[];
        scripts?: string[];
        web?: string[];
        [key: string]: string[] | undefined;
    };
    parseSubDirectories: boolean;
    rootDirectory: string;
    schemaVersion: number;
    useGitIgnoreForExcludes: boolean;
}

/**
 * Information about a file for fusion
 */
export interface FileInfo {
    content: string;
    path: FilePath;
}

/**
 * Options for the fusion process
 */
export interface FusionOptions {
    extensionGroups?: string[];
}

/**
 * Type-safe fusion result with discriminated union for success/failure states
 */
export type FusionResult = 
    | {
        fusionFilePath: FilePath;
        logFilePath: FilePath;
        message: string;
        success: true;
    }
    | {
        error?: Error;
        logFilePath?: FilePath;
        message: string;
        success: false;
    };
```

## üìÑ src/utils.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Utilities for Project Fusion
 */
import path from 'node:path';
import fs from 'fs-extra';
import { z } from 'zod';
import { ConfigSchemaV1 } from './schema.js';
import { FusionError, type Config, type FilePath } from './types.js';


/**
 * Default configuration for Project Fusion
 */
export const defaultConfig = {
    copyToClipboard: false,
    generatedFileName: "project-fusioned",
    generateHtml: true,
    generateMarkdown: true,
    generateText: true,
    maxFileSizeKB: 1024,
    parseSubDirectories: true,
    parsedFileExtensions: {
        backend: [".cs", ".go", ".java", ".php", ".py", ".rb", ".rs"] as const,
        config: [".json", ".toml", ".xml", ".yaml", ".yml"] as const,
        cpp: [".c", ".cc", ".cpp", ".h", ".hpp"] as const,
        doc: [".adoc", ".md", ".rst"] as const,
        godot: [".cfg", ".cs", ".gd", ".import", ".tscn", ".tres"] as const,
        scripts: [".bat", ".cmd", ".ps1", ".sh"] as const,
        web: [".css", ".html", ".js", ".jsx", ".svelte", ".ts", ".tsx", ".vue"] as const
    },
    ignorePatterns: [
        "project-fusion.json",
        "project-fusion.log",
        "project-fusioned.*",
        "node_modules/",
        "package-lock.json",
        "pnpm-lock.yaml",
        "yarn.lock",
        "dist/",
        "build/",
        "*.min.js",
        "*.min.css",
        ".env",
        ".env.*",
        "*.key",
        "*.pem",
        "**/credentials/*",
        "**/secrets/*",
        "*.log",
        "logs/",
        ".DS_Store",
        "Thumbs.db",
        ".vscode/",
        ".idea/",
        "*.swp",
        "*.swo",
        // Binary files and archives
        "*.zip",
        "*.tar",
        "*.tgz",
        "*.gz",
        "*.7z",
        "*.rar",
        // Images
        "*.png",
        "*.jpg",
        "*.jpeg",
        "*.gif",
        "*.bmp",
        "*.ico",
        "*.svg",
        "*.webp",
        // Documents
        "*.pdf",
        "*.doc",
        "*.docx",
        "*.xls",
        "*.xlsx",
        "*.ppt",
        "*.pptx",
        // Media
        "*.mp3",
        "*.mp4",
        "*.avi",
        "*.mov",
        "*.wmv",
        "*.flv",
        "*.wav",
        "*.flac",
        // Game engine assets
        "*.unitypackage",
        "*.uasset",
        "*.fbx",
        "*.obj",
        "*.blend",
        // Compiled/Binary
        "*.exe",
        "*.dll",
        "*.so",
        "*.dylib",
        "*.a",
        "*.o",
        "*.pyc",
        "*.pyo",
        "*.class",
        "*.jar",
        "*.war"
    ],
    rootDirectory: ".",
    schemaVersion: 1,
    useGitIgnoreForExcludes: true
} as const satisfies Config;


/**
 * Load and validate configuration with fallback to defaults
 * @returns The loaded configuration or default config if invalid/missing
 */
export async function loadConfig(): Promise<Config> {
    try {
        const configPath = path.resolve('./project-fusion.json');
        
        let configContent: string;
        try {
            configContent = await fs.readFile(configPath, 'utf8');
        } catch {
            return defaultConfig;
        }

        const parsedConfig = JSON.parse(configContent);

        try {
            const validatedConfig = ConfigSchemaV1.parse(parsedConfig);
            return validatedConfig;
        } catch (zodError: unknown) {
            // Graceful degradation with detailed error reporting
            if (zodError instanceof z.ZodError) {
                console.error('Configuration validation failed (will use default config):');
                for (const [index, issue] of zodError.issues.entries()) {
                    const path = issue.path.length > 0 ? issue.path.join('.') : 'root';
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const value = issue.path.reduce((obj: any, key) => obj?.[key], parsedConfig);
                    console.error(`  ${index + 1}. Path: ${path}`);
                    console.error(`     Error: ${issue.message}`);
                    console.error(`     Current value: ${JSON.stringify(value)}`);
                    if (issue.code === 'invalid_type') {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        console.error(`     Expected type: ${(issue as any).expected}, received: ${(issue as any).received}`);
                    }
                }
            } else {
                console.error('Unknown validation error (will use default config):', zodError);
            }
            return defaultConfig;
        }
    } catch (error) {
        const typedError = error instanceof Error ? error : new Error(String(error));

        console.error('Error loading configuration, will use default configuration:', {
            message: typedError.message,
            stack: typedError.stack,
            context: 'loadConfig',
            configPath: path.resolve('./project-fusion.json')
        });

        return defaultConfig;
    }
}

/**
 * Create directory if it doesn't exist
 * @param directory Directory path
 */
export async function ensureDirectoryExists(directory: string): Promise<void> {
    await fs.ensureDir(directory);
}

/**
 * Write content to log file with optional console output
 * @param logFilePath Path to log file
 * @param content Content to log
 * @param append If true, append to existing file
 * @param consoleOutput If true, also display on console
 */
export async function writeLog(
    logFilePath: string,
    content: string,
    append = false,
    consoleOutput = false
): Promise<void> {
    try {
        await ensureDirectoryExists(path.dirname(logFilePath));
        await (append ? fs.appendFile(logFilePath, `${content  }\n`) : fs.writeFile(logFilePath, `${content  }\n`));

        if (consoleOutput) {
            console.log(content);
        }
    } catch (error) {
        console.error('Error writing log:', error);
    }
}


/**
 * Format a timestamp
 * @param date Optional date to format, defaults to current date
 * @returns Formatted timestamp
 */
export function formatTimestamp(date?: Date): string {
    return (date ?? new Date()).toISOString();
}

/**
 * Format a local timestamp for display
 * @param date Optional date to format, defaults to current date
 * @returns Formatted local timestamp
 */
export function formatLocalTimestamp(date?: Date): string {
    const now = date ?? new Date();
    return now.toLocaleString('fr-FR', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        timeZoneName: 'short'
    });
}

/**
 * Read file content
 * @param filePath Path to file
 * @returns File content
 */
export async function readFileContent(filePath: string): Promise<string> {
    try {
        return await fs.readFile(filePath, 'utf8');
    } catch (error) {
        console.error(`Error reading file ${filePath}:`, error);
        throw error;
    }
}

/**
 * Write detailed configuration summary to log for debugging
 * @param logFilePath Path to log file
 * @param config Configuration to log
 */
export async function logConfigSummary(logFilePath: FilePath, config: Config): Promise<void> {
    await writeLog(logFilePath, `Configuration Summary:`, true);
    await writeLog(logFilePath, `  Schema Version: ${config.schemaVersion}`, true);
    await writeLog(logFilePath, `  Root Directory: ${config.rootDirectory}`, true);
    await writeLog(logFilePath, `  Scan Subdirectories: ${config.parseSubDirectories ? 'Yes' : 'No'}`, true);
    await writeLog(logFilePath, `  Use .gitignore: ${config.useGitIgnoreForExcludes ? 'Yes' : 'No'}`, true);
    await writeLog(logFilePath, `  Copy to Clipboard: ${config.copyToClipboard ? 'Yes' : 'No'}`, true);
    await writeLog(logFilePath, `  Max File Size: ${config.maxFileSizeKB} KB`, true);
    
    // Output files
    await writeLog(logFilePath, `  Generated File Name: ${config.generatedFileName}`, true);
    await writeLog(logFilePath, `  Generate Text: ${config.generateText ? 'Yes' : 'No'}`, true);
    await writeLog(logFilePath, `  Generate Markdown: ${config.generateMarkdown ? 'Yes' : 'No'}`, true);
    await writeLog(logFilePath, `  Generate HTML: ${config.generateHtml ? 'Yes' : 'No'}`, true);
    
    // File type statistics
    const totalExtensions = getExtensionsFromGroups(config);
    await writeLog(logFilePath, `  Extension Groups: ${Object.keys(config.parsedFileExtensions).length} groups`, true);
    await writeLog(logFilePath, `  Total Extensions: ${totalExtensions.length}`, true);
    
    // Exclusion pattern count
    await writeLog(logFilePath, `  Ignore Patterns: ${config.ignorePatterns.length} patterns`, true);
    
    await writeLog(logFilePath, ``, true); // Empty line for separation
}

/**
 * Write content to file
 * @param filePath Path to file
 * @param content Content to write
 */
export async function writeFileContent(filePath: string, content: string): Promise<void> {
    try {
        await ensureDirectoryExists(path.dirname(filePath));
        await fs.writeFile(filePath, content);
    } catch (error) {
        console.error(`Error writing file ${filePath}:`, error);
        throw error;
    }
}

/**
 * Extract file extensions from configuration groups
 * @param config Config object
 * @param groups Extension groups to include (all if undefined)
 * @returns Array of file extensions
 */
export function getExtensionsFromGroups(
    config: Config,
    groups?: string[]
): string[] {
    // Return all extensions if no specific groups requested
    if (!groups || groups.length === 0) {
        return Object.values(config.parsedFileExtensions)
            .filter((extensions): extensions is string[] => Boolean(extensions))
            .flat();
    }

    // Collect extensions from specified groups with validation
    return groups.reduce((acc: string[], group: string) => {
        const extensions = config.parsedFileExtensions[group];
        if (extensions) {
            acc.push(...extensions);
        } else {
            throw new FusionError(
                `Extension group '${group}' not found in config`, 
                'UNKNOWN_EXTENSION_GROUP', 
                'warning',
                { group, availableGroups: Object.keys(config.parsedFileExtensions) }
            );
        }
        return acc;
    }, []);
}

/**
 * Map file extensions to syntax highlighting languages for markdown/HTML
 * @param extensionOrBasename File extension or special basename
 * @returns Language identifier for syntax highlighting
 */
export function getMarkdownLanguage(extensionOrBasename: string): string {
    // Comprehensive mapping for syntax highlighting across multiple formats
    const languageMap: Record<string, string> = {
        // Backend (alphabetized)
        '.cs': 'csharp',
        '.go': 'go',
        '.java': 'java',
        '.kt': 'kotlin',
        '.lua': 'lua',
        '.perl': 'perl',
        '.php': 'php',
        '.pl': 'perl',
        '.py': 'python',
        '.r': 'r',
        '.rb': 'ruby',
        '.rs': 'rust',
        '.scala': 'scala',
        '.swift': 'swift',
        
        // C/C++ (alphabetized)
        '.c': 'c',
        '.cc': 'cpp',
        '.cpp': 'cpp',
        '.cxx': 'cpp',
        '.h': 'c',
        '.hpp': 'cpp',
        '.hxx': 'cpp',
        
        // Config (alphabetized)
        '.env': 'bash',
        '.ini': 'ini',
        '.json': 'json',
        '.toml': 'toml',
        '.xml': 'xml',
        '.yaml': 'yaml',
        '.yml': 'yaml',
        
        // Database
        '.sql': 'sql',
        
        // Documentation (alphabetized)
        '.md': 'markdown',
        '.mdx': 'markdown',
        '.rst': 'rst',
        '.tex': 'latex',
        
        // Godot (alphabetized)
        '.cfg': 'ini',
        '.gd': 'gdscript',
        '.import': 'ini',
        '.tres': 'gdscript',
        '.tscn': 'gdscript',
        
        // Other (alphabetized)
        '.cmake': 'cmake',
        '.dockerfile': 'dockerfile',
        '.Dockerfile': 'dockerfile',
        '.gql': 'graphql',
        '.gradle': 'gradle',
        '.graphql': 'graphql',
        '.makefile': 'makefile',
        '.Makefile': 'makefile',
        '.proto': 'protobuf',
        
        // Shell/Scripts (alphabetized)
        '.bash': 'bash',
        '.bat': 'batch',
        '.cmd': 'batch',
        '.fish': 'bash',
        '.ps1': 'powershell',
        '.sh': 'bash',
        '.zsh': 'bash',
        
        // Web (alphabetized)
        '.css': 'css',
        '.html': 'html',
        '.js': 'javascript',
        '.jsx': 'jsx',
        '.less': 'less',
        '.sass': 'sass',
        '.scss': 'scss',
        '.svelte': 'svelte',
        '.ts': 'typescript',
        '.tsx': 'tsx',
        '.vue': 'vue',
        
        // Files without extensions (alphabetized by basename)
        '.gitattributes': 'text',
        '.gitignore': 'text',
        '.htaccess': 'apache',
        'Cargo.lock': 'toml',
        'Cargo.toml': 'toml',
        'CMakeLists.txt': 'cmake',
        dockerfile: 'dockerfile',
        Dockerfile: 'dockerfile',
        Gemfile: 'ruby',
        'go.mod': 'go',
        'go.sum': 'text',
        Jenkinsfile: 'groovy',
        makefile: 'makefile',
        Makefile: 'makefile',
        'nginx.conf': 'nginx',
        Rakefile: 'ruby',
        'requirements.txt': 'text',
        Vagrantfile: 'ruby',
    };
    
    // Case-insensitive lookup with fallback to 'text'
    const lang = languageMap[extensionOrBasename.toLowerCase()] ?? languageMap[extensionOrBasename];
    return lang ?? 'text';
}
```

## üìÑ tests/api.test.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for programmatic API
 */
import { existsSync } from 'node:fs';
import { join } from 'node:path';
import { mkdir, rm, writeFile } from 'node:fs/promises';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { createConfig, fusionAPI, runFusion } from '../src/api.js';
import { defaultConfig } from '../src/utils.js';
import type { Config } from '../src/types.js';

describe('API Tests', () => {
    const testDir = join(process.cwd(), 'temp', 'test-api');
    const testProjectDir = join(testDir, 'test-project');
    
    beforeEach(async () => {
        // Create test directories
        await mkdir(testProjectDir, { recursive: true });
        
        // Create test files
        await writeFile(join(testProjectDir, 'index.js'), 'console.log("Hello");');
        await writeFile(join(testProjectDir, 'app.ts'), 'const app = "test";');
        await writeFile(join(testProjectDir, 'style.css'), 'body { margin: 0; }');
        await writeFile(join(testProjectDir, 'config.json'), '{"test": true}');
        await writeFile(join(testProjectDir, 'README.md'), '# Test Project');
        await writeFile(join(testProjectDir, 'script.py'), 'print("Python")');
    });
    
    afterEach(async () => {
        // Clean up test directories
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        
        // Clean up generated files in current directory if any
        const generatedFiles = [
            'project-fusioned.txt',
            'project-fusioned.md',
            'project-fusioned.html',
            'project-fusion.log'
        ];
        for (const file of generatedFiles) {
            const filePath = join(testProjectDir, file);
            if (existsSync(filePath)) {
                await rm(filePath, { force: true });
            }
        }
    });
    
    describe('createConfig', () => {
        it('should create a complete config with defaults', () => {
            const config = createConfig();
            
            expect(config.schemaVersion).toBe(1);
            expect(config.copyToClipboard).toBe(defaultConfig.copyToClipboard);
            expect(config.generatedFileName).toBe(defaultConfig.generatedFileName);
            expect(config.generateHtml).toBe(defaultConfig.generateHtml);
            expect(config.generateMarkdown).toBe(defaultConfig.generateMarkdown);
            expect(config.generateText).toBe(defaultConfig.generateText);
            expect(config.maxFileSizeKB).toBe(defaultConfig.maxFileSizeKB);
            expect(config.parsedFileExtensions).toEqual(defaultConfig.parsedFileExtensions);
            expect(config.parseSubDirectories).toBe(defaultConfig.parseSubDirectories);
            expect(config.rootDirectory).toBe(process.cwd());
            expect(config.useGitIgnoreForExcludes).toBe(defaultConfig.useGitIgnoreForExcludes);
        });
        
        it('should override defaults with provided values', () => {
            const overrides = {
                generateHtml: false,
                maxFileSizeKB: 2048,
                rootDirectory: '/custom/path'
            };
            
            const config = createConfig(overrides);
            
            expect(config.generateHtml).toBe(false);
            expect(config.maxFileSizeKB).toBe(2048);
            expect(config.rootDirectory).toBe('/custom/path');
            expect(config.generateMarkdown).toBe(defaultConfig.generateMarkdown);
        });
        
        it('should handle partial parsedFileExtensions override', () => {
            const config = createConfig({
                parsedFileExtensions: {
                    web: ['.ts', '.tsx'],
                    backend: ['.py']
                }
            });
            
            expect(config.parsedFileExtensions).toEqual({
                web: ['.ts', '.tsx'],
                backend: ['.py']
            });
        });
    });
    
    describe('fusionAPI', () => {
        it('should process fusion with default config', async () => {
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            expect(result.message).toContain('Fusion completed');
            expect(result.fusionFilePath).toBeDefined();
            expect(result.logFilePath).toBeDefined();
            
            // Check files were created
            expect(existsSync(join(testProjectDir, 'project-fusioned.txt'))).toBe(true);
            expect(existsSync(join(testProjectDir, 'project-fusioned.md'))).toBe(true);
            expect(existsSync(join(testProjectDir, 'project-fusion.log'))).toBe(true);
        });
        
        it('should handle custom extensions', async () => {
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                parsedFileExtensions: {
                    web: ['.js', '.ts'],
                    backend: [],
                    config: [],
                    cpp: [],
                    doc: [],
                    godot: [],
                    scripts: []
                },
                generateHtml: false,
                generateMarkdown: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            
            // Check that only .js and .ts files were processed
            const content = await import('node:fs').then(fs => 
                fs.promises.readFile(join(testProjectDir, 'project-fusioned.txt'), 'utf8')
            );
            expect(content).toContain('index.js');
            expect(content).toContain('app.ts');
            expect(content).not.toContain('style.css');
            expect(content).not.toContain('config.json');
        });
        
        it('should respect extensionGroups filter', async () => {
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                extensionGroups: ['web'],
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            
            const content = await import('node:fs').then(fs => 
                fs.promises.readFile(join(testProjectDir, 'project-fusioned.txt'), 'utf8')
            );
            expect(content).toContain('index.js');
            expect(content).toContain('app.ts');
            expect(content).toContain('style.css');
            expect(content).not.toContain('config.json');
            expect(content).not.toContain('script.py');
        });
        
        it('should handle rootDir option', async () => {
            const result = await fusionAPI({
                cwd: testDir,
                rootDir: 'test-project',
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            expect(existsSync(join(testProjectDir, 'project-fusioned.txt'))).toBe(true);
        });
        
        it('should handle errors gracefully', async () => {
            const result = await fusionAPI({
                rootDirectory: '/non/existent/path',
                copyToClipboard: false
            });
            
            expect(result.success).toBe(false);
            expect(result.message).toContain('error');
            expect(result.error).toBeDefined();
        });
    });
    
    describe('runFusion', () => {
        it('should work with partial config', async () => {
            const result = await runFusion({
                rootDirectory: testProjectDir,
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            expect(result.message).toContain('Fusion completed');
        });
        
        it('should work with complete config', async () => {
            const config = createConfig({
                rootDirectory: testProjectDir,
                generateHtml: false,
                generateMarkdown: false,
                copyToClipboard: false
            });
            
            const result = await runFusion(config);
            
            expect(result.success).toBe(true);
            expect(existsSync(join(testProjectDir, 'project-fusioned.txt'))).toBe(true);
            expect(existsSync(join(testProjectDir, 'project-fusioned.md'))).toBe(false);
            expect(existsSync(join(testProjectDir, 'project-fusioned.html'))).toBe(false);
        });
        
        it('should accept fusion options', async () => {
            const result = await runFusion(
                { rootDirectory: testProjectDir, copyToClipboard: false },
                { extensionGroups: ['config', 'doc'] }
            );
            
            expect(result.success).toBe(true);
            
            const content = await import('node:fs').then(fs => 
                fs.promises.readFile(join(testProjectDir, 'project-fusioned.txt'), 'utf8')
            );
            expect(content).toContain('config.json');
            expect(content).toContain('README.md');
            expect(content).not.toContain('index.js');
            expect(content).not.toContain('script.py');
        });
        
        it('should handle empty extension groups', async () => {
            const result = await runFusion(
                { 
                    rootDirectory: testProjectDir,
                    parsedFileExtensions: {
                        backend: [],
                        config: [],
                        cpp: [],
                        doc: [],
                        godot: [],
                        scripts: [],
                        web: []
                    },
                    copyToClipboard: false
                }
            );
            
            expect(result.success).toBe(false);
            expect(result.message).toContain('No file extensions to process');
        });
    });
    
    describe('Integration Tests', () => {
        it('should handle complex nested project structure', async () => {
            // Create nested structure
            const nestedDir = join(testProjectDir, 'src', 'components');
            await mkdir(nestedDir, { recursive: true });
            await writeFile(join(nestedDir, 'Button.tsx'), 'export const Button = () => <button />;');
            await writeFile(join(nestedDir, 'Card.tsx'), 'export const Card = () => <div />;');
            
            const utilsDir = join(testProjectDir, 'src', 'utils');
            await mkdir(utilsDir, { recursive: true });
            await writeFile(join(utilsDir, 'helpers.ts'), 'export const helper = () => {};');
            
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                parseSubDirectories: true,
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            
            const content = await import('node:fs').then(fs => 
                fs.promises.readFile(join(testProjectDir, 'project-fusioned.txt'), 'utf8')
            );
            expect(content).toContain('Button.tsx');
            expect(content).toContain('Card.tsx');
            expect(content).toContain('helpers.ts');
        });
        
        it('should respect ignore patterns', async () => {
            // Create test files
            await writeFile(join(testProjectDir, 'test.spec.ts'), 'test("example", () => {});');
            await writeFile(join(testProjectDir, '.env'), 'SECRET=123');
            await writeFile(join(testProjectDir, 'main.ts'), 'const main = () => {};');
            
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                ignorePatterns: ['*.spec.ts', '.env'],
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            
            const content = await import('node:fs').then(fs => 
                fs.promises.readFile(join(testProjectDir, 'project-fusioned.txt'), 'utf8')
            );
            expect(content).toContain('main.ts');
            expect(content).not.toContain('test.spec.ts');
            expect(content).not.toContain('.env');
        });
        
        it('should handle file size limits', async () => {
            // Create a large file
            const largeContent = 'x'.repeat(2 * 1024 * 1024); // 2MB
            await writeFile(join(testProjectDir, 'large.js'), largeContent);
            
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                maxFileSizeKB: 1024, // 1MB limit
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            
            const content = await import('node:fs').then(fs => 
                fs.promises.readFile(join(testProjectDir, 'project-fusioned.txt'), 'utf8')
            );
            expect(content).not.toContain('large.js');
            expect(content).toContain('index.js'); // Small files should still be included
        });
    });
});
```

## üìÑ tests/benchmark.test.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for benchmark functionality
 */
import { describe, expect, it, vi, beforeEach, afterEach } from 'vitest';
import { BenchmarkTracker } from '../src/benchmark.js';

describe('BenchmarkTracker', () => {
    let originalMemoryUsage: NodeJS.MemoryUsage;
    
    beforeEach(() => {
        // Mock process.memoryUsage
        originalMemoryUsage = process.memoryUsage();
        vi.spyOn(process, 'memoryUsage').mockReturnValue({
            rss: 100 * 1024 * 1024, // 100MB
            heapTotal: 80 * 1024 * 1024,
            heapUsed: 50 * 1024 * 1024,
            external: 10 * 1024 * 1024,
            arrayBuffers: 5 * 1024 * 1024
        });
    });
    
    afterEach(() => {
        vi.restoreAllMocks();
    });
    
    describe('constructor', () => {
        it('should initialize with zero values', () => {
            const tracker = new BenchmarkTracker();
            const metrics = tracker.getMetrics();
            
            expect(metrics.filesProcessed).toBe(0);
            expect(metrics.totalBytesProcessed).toBe(0);
            expect(metrics.memoryUsedMB).toBeGreaterThan(0);
            expect(metrics.processingTimeMs).toBeGreaterThanOrEqual(0);
        });
    });
    
    describe('recordFile', () => {
        it('should track file metrics', () => {
            const tracker = new BenchmarkTracker();
            
            tracker.recordFile('file1.js', 1024);
            tracker.recordFile('file2.ts', 2048);
            
            const metrics = tracker.getMetrics();
            expect(metrics.filesProcessed).toBe(2);
            expect(metrics.totalBytesProcessed).toBe(3072);
        });
        
        it('should handle empty files', () => {
            const tracker = new BenchmarkTracker();
            
            tracker.recordFile('empty.txt', 0);
            
            const metrics = tracker.getMetrics();
            expect(metrics.filesProcessed).toBe(1);
            expect(metrics.totalBytesProcessed).toBe(0);
        });
        
        it('should handle large files', () => {
            const tracker = new BenchmarkTracker();
            const largeSize = 10 * 1024 * 1024; // 10MB
            
            tracker.recordFile('large.bin', largeSize);
            
            const metrics = tracker.getMetrics();
            expect(metrics.filesProcessed).toBe(1);
            expect(metrics.totalBytesProcessed).toBe(largeSize);
        });
    });
    
    describe('getMetrics', () => {
        it('should calculate processing time', async () => {
            const tracker = new BenchmarkTracker();
            
            // Wait a bit to ensure processing time > 0
            await new Promise(resolve => setTimeout(resolve, 10));
            
            const metrics = tracker.getMetrics();
            expect(metrics.processingTimeMs).toBeGreaterThan(0);
        });
        
        it('should calculate throughput correctly', () => {
            const tracker = new BenchmarkTracker();
            
            // Add files
            tracker.recordFile('file1.txt', 1024 * 1024); // 1MB
            tracker.recordFile('file2.txt', 1024 * 1024); // 1MB
            
            const metrics = tracker.getMetrics();
            
            // Throughput should be total bytes / time in seconds
            if (metrics.processingTimeMs > 0) {
                const expectedThroughput = (2 * 1024 * 1024) / (metrics.processingTimeMs / 1000);
                expect(metrics.throughputBytesPerSec).toBeCloseTo(expectedThroughput, 0);
            }
        });
        
        it('should handle zero processing time', () => {
            const tracker = new BenchmarkTracker();
            
            // Mock Date.now to return same value
            const now = Date.now();
            vi.spyOn(Date, 'now').mockReturnValue(now);
            
            tracker.recordFile('instant.txt', 1024);
            const metrics = tracker.getMetrics();
            
            expect(metrics.processingTimeMs).toBe(0);
            expect(metrics.throughputBytesPerSec).toBe(0);
        });
        
        it('should report memory usage', () => {
            const tracker = new BenchmarkTracker();
            const metrics = tracker.getMetrics();
            
            // Based on our mock: 50MB heap used
            expect(metrics.memoryUsedMB).toBeCloseTo(50, 1);
        });
    });
    
    describe('logMetrics', () => {
        it('should log metrics to console', () => {
            const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
            const tracker = new BenchmarkTracker();
            
            tracker.recordFile('test.txt', 1024);
            tracker.logMetrics();
            
            expect(consoleSpy).toHaveBeenCalled();
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Performance Metrics'));
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Files processed'));
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Total size'));
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Processing time'));
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Throughput'));
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Memory used'));
            
            consoleSpy.mockRestore();
        });
        
        it('should format large numbers correctly', () => {
            const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
            const tracker = new BenchmarkTracker();
            
            // Add a large file
            tracker.recordFile('large.bin', 5 * 1024 * 1024); // 5MB
            tracker.logMetrics();
            
            // Check that MB formatting is used
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('5.00 MB'));
            
            consoleSpy.mockRestore();
        });
        
        it('should handle multiple file recordings', () => {
            const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
            const tracker = new BenchmarkTracker();
            
            for (let i = 0; i < 100; i++) {
                tracker.recordFile(`file${i}.txt`, 1024);
            }
            
            tracker.logMetrics();
            
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('100'));
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('0.10 MB')); // 100KB
            
            consoleSpy.mockRestore();
        });
    });
    
    describe('Edge Cases', () => {
        it('should handle rapid successive recordings', () => {
            const tracker = new BenchmarkTracker();
            
            for (let i = 0; i < 1000; i++) {
                tracker.recordFile(`file${i}`, i);
            }
            
            const metrics = tracker.getMetrics();
            expect(metrics.filesProcessed).toBe(1000);
            expect(metrics.totalBytesProcessed).toBe(499500); // Sum of 0 to 999
        });
        
        it('should handle special characters in filenames', () => {
            const tracker = new BenchmarkTracker();
            
            tracker.recordFile('file with spaces.txt', 100);
            tracker.recordFile('file-with-dashes.js', 200);
            tracker.recordFile('file_with_underscores.py', 300);
            tracker.recordFile('Êñá‰ª∂.txt', 400);
            
            const metrics = tracker.getMetrics();
            expect(metrics.filesProcessed).toBe(4);
            expect(metrics.totalBytesProcessed).toBe(1000);
        });
        
        it('should maintain accuracy with floating point sizes', () => {
            const tracker = new BenchmarkTracker();
            
            tracker.recordFile('file1', 0.1);
            tracker.recordFile('file2', 0.2);
            tracker.recordFile('file3', 0.3);
            
            const metrics = tracker.getMetrics();
            expect(metrics.totalBytesProcessed).toBeCloseTo(0.6, 10);
        });
    });
});
```

## üìÑ tests/formats.test.ts

```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs-extra';
import path from 'path';
import { processFusion } from '../src/fusion.js';
import { Config } from '../src/types.js';

// Test configuration for multiple output formats
const testConfig: Config = {
  schemaVersion: 1,
  generatedFileName: 'test-output',
  copyToClipboard: false,
  generateText: true,
  generateMarkdown: true,
  generateHtml: true,
  parsedFileExtensions: {
    web: ['.js', '.ts'],
    doc: ['.md']
  },
  parseSubDirectories: false,
  rootDirectory: '.',
  maxFileSizeKB: 1024,
  ignorePatterns: [],
  useGitIgnoreForExcludes: false
};

const testDir = path.resolve('./temp/test-formats');
const originalCwd = process.cwd();

describe('Multiple Format Generation', () => {
  beforeEach(async () => {
    await fs.ensureDir(testDir);
    process.chdir(testDir);
    
    // Create test files
    await fs.writeFile(path.join(testDir, 'test.js'), `
console.log('Hello World');
function greet(name) {
  return \`Hello, \${name}!\`;
}
export { greet };
    `.trim());

    await fs.writeFile(path.join(testDir, 'README.md'), `
# Test Project

This is a **test** project with _markdown_ content.

## Features
- Feature 1
- Feature 2
    `.trim());
  });

  afterEach(async () => {
    process.chdir(originalCwd);
    await fs.remove(testDir);
  });

  it('should generate text format when enabled', async () => {
    const config = { ...testConfig, generateText: true, generateMarkdown: false, generateHtml: false };
    const result = await processFusion(config);
    
    expect(result.success).toBe(true);
    expect(await fs.pathExists('test-output.txt')).toBe(true);
    expect(await fs.pathExists('test-output.md')).toBe(false);
    expect(await fs.pathExists('test-output.html')).toBe(false);
  });

  it('should generate markdown format when enabled', async () => {
    const config = { ...testConfig, generateText: false, generateMarkdown: true, generateHtml: false };
    const result = await processFusion(config);
    
    expect(result.success).toBe(true);
    expect(await fs.pathExists('test-output.txt')).toBe(false);
    expect(await fs.pathExists('test-output.md')).toBe(true);
    expect(await fs.pathExists('test-output.html')).toBe(false);
  });

  it('should generate HTML format when enabled', async () => {
    const config = { ...testConfig, generateText: false, generateMarkdown: false, generateHtml: true };
    const result = await processFusion(config);
    
    expect(result.success).toBe(true);
    expect(await fs.pathExists('test-output.txt')).toBe(false);
    expect(await fs.pathExists('test-output.md')).toBe(false);
    expect(await fs.pathExists('test-output.html')).toBe(true);
  });

  it('should generate multiple formats when enabled', async () => {
    const result = await processFusion(testConfig);
    
    expect(result.success).toBe(true);
    expect(await fs.pathExists('test-output.txt')).toBe(true);
    expect(await fs.pathExists('test-output.md')).toBe(true);
    expect(await fs.pathExists('test-output.html')).toBe(true);
  });

  it('should include proper HTML structure', async () => {
    const result = await processFusion(testConfig);
    
    expect(result.success).toBe(true);
    const htmlContent = await fs.readFile('test-output.html', 'utf8');
    
    expect(htmlContent).toContain('<!DOCTYPE html>');
    expect(htmlContent).toContain('<html lang="en">');
    expect(htmlContent).toContain('<title>Project Fusion - test-formats</title>');
    expect(htmlContent).toContain('üìÅ Table of Contents');
    expect(htmlContent).toContain('üìÑ test.js');
    expect(htmlContent).toContain('üìÑ README.md');
    expect(htmlContent).toContain('</body>');
    expect(htmlContent).toContain('</html>');
  });

  it('should escape HTML in code content', async () => {
    // Add a file with HTML-like content
    await fs.writeFile('html-test.js', `
const html = '<div>Hello & <span>World</span></div>';
console.log(html);
    `.trim());

    const result = await processFusion(testConfig);
    
    expect(result.success).toBe(true);
    const htmlContent = await fs.readFile('test-output.html', 'utf8');
    
    expect(htmlContent).toContain('&lt;div&gt;Hello &amp; &lt;span&gt;World&lt;/span&gt;&lt;/div&gt;');
  });


  it('should include proper metadata in generated files', async () => {
    // Create a package.json with version info
    await fs.writeFile('package.json', JSON.stringify({
      name: 'test-package',
      version: '1.0.0'
    }, null, 2));

    const configWithPackage = {
      ...testConfig,
      parsedFileExtensions: { ...testConfig.parsedFileExtensions, config: ['.json'] }
    };

    const result = await processFusion(configWithPackage);
    
    expect(result.success).toBe(true);
    const txtContent = await fs.readFile('test-output.txt', 'utf8');
    const mdContent = await fs.readFile('test-output.md', 'utf8');
    
    expect(txtContent).toContain('# Generated Project Fusion File');
    expect(txtContent).toContain('# Project: test-formats / test-package v1.0.0');
    expect(txtContent).toContain('# Generated by: project-fusion');
    
    expect(mdContent).toContain('# Generated Project Fusion File');
    expect(mdContent).toContain('**Project:** test-formats / test-package v1.0.0');
    expect(mdContent).toContain('[project-fusion](https://github.com/the99studio/project-fusion)');
  });
});
```

## üìÑ tests/integration.test.ts

```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs-extra';
import path from 'path';
import { processFusion } from '../src/fusion.js';
import { defaultConfig } from '../src/utils.js';
import { Config } from '../src/types.js';

describe('integration', () => {
  const testDir = path.join(process.cwd(), 'temp', 'test-integration');
  const originalCwd = process.cwd();

  beforeEach(async () => {
    // Clean up and create test directory
    await fs.remove(testDir);
    await fs.ensureDir(testDir);
    
    // Change to test directory
    process.chdir(testDir);
  });

  afterEach(async () => {
    // Restore original directory
    process.chdir(originalCwd);
    
    // Clean up test directory
    await fs.remove(testDir);
  });

  describe('processFusion', () => {
    it('should process fusion successfully with test files', async () => {
      // Create test files
      await fs.writeFile('test.js', 'console.log("Hello World");');
      await fs.writeFile('test.ts', 'const message: string = "TypeScript";');
      await fs.writeFile('Dockerfile', 'FROM node:18\nCOPY . .\nRUN npm install');
      
      // Create config for test
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        parsedFileExtensions: {
          web: ['.js', '.ts']
        }
      };

      const result = await processFusion(testConfig);

      expect(result.success).toBe(true);
      expect(result.message).toContain('2 files processed');
      expect(result.fusionFilePath).toBeDefined();
      
      // Check if fusion files were created
      expect(await fs.pathExists(result.fusionFilePath!)).toBe(true);
      expect(await fs.pathExists(result.fusionFilePath!.replace('.txt', '.md'))).toBe(true);
      
      // Check content of fusion file
      const fusionContent = await fs.readFile(result.fusionFilePath!, 'utf8');
      expect(fusionContent).toContain('test.js');
      expect(fusionContent).toContain('test.ts');
      expect(fusionContent).toContain('console.log("Hello World");');
      expect(fusionContent).toContain('const message: string = "TypeScript";');
      expect(fusionContent).not.toContain('Dockerfile'); // Not in web extensions
    });

    it('should handle empty directory gracefully', async () => {
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false
      };

      const result = await processFusion(testConfig);

      expect(result.success).toBe(false);
      expect(result.message).toContain('No files found to process');
    });

    it('should respect ignore patterns', async () => {
      // Create test files
      await fs.writeFile('test.js', 'console.log("Hello World");');
      await fs.writeFile('ignored.js', 'console.log("Should be ignored");');
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        parsedFileExtensions: {
          web: ['.js']
        },
        ignorePatterns: ['ignored.js']
      };

      const result = await processFusion(testConfig);

      expect(result.success).toBe(true);
      expect(result.message).toContain('1 files processed'); // Only test.js
      
      const fusionContent = await fs.readFile(result.fusionFilePath!, 'utf8');
      expect(fusionContent).toContain('test.js');
      expect(fusionContent).not.toContain('ignored.js');
    });

    it('should filter files by extensions correctly', async () => {
      // Create test files with different extensions
      await fs.writeFile('app.js', 'console.log("JavaScript");');
      await fs.writeFile('app.ts', 'const app: string = "TypeScript";');
      await fs.writeFile('app.py', 'print("Python")');
      await fs.writeFile('config.json', '{"test": true}');
      
      // Test web extensions only
      const webConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        parsedFileExtensions: {
          web: ['.js', '.ts']
        }
      };

      const webResult = await processFusion(webConfig);
      expect(webResult.success).toBe(true);
      expect(webResult.message).toContain('2 files processed');
      
      const webContent = await fs.readFile(webResult.fusionFilePath!, 'utf8');
      expect(webContent).toContain('app.js');
      expect(webContent).toContain('app.ts');
      expect(webContent).not.toContain('app.py');
      expect(webContent).not.toContain('config.json');

      // Test backend extensions only
      const backendConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        parsedFileExtensions: {
          backend: ['.py']
        }
      };

      const backendResult = await processFusion(backendConfig);
      expect(backendResult.success).toBe(true);
      expect(backendResult.message).toContain('1 files processed');
      
      const backendContent = await fs.readFile(backendResult.fusionFilePath!, 'utf8');
      expect(backendContent).toContain('app.py');
      expect(backendContent).not.toContain('app.js');
      expect(backendContent).not.toContain('app.ts');
    });

    it('should respect .gitignore patterns', async () => {
      // Create test files
      await fs.writeFile('app.js', 'console.log("main app");');
      await fs.writeFile('build.js', 'console.log("build file");');
      await fs.ensureDir('node_modules');
      await fs.writeFile('node_modules/lib.js', 'console.log("dependency");');
      await fs.ensureDir('dist');
      await fs.writeFile('dist/output.js', 'console.log("compiled");');
      
      // Create .gitignore
      await fs.writeFile('.gitignore', 'node_modules/\ndist/\nbuild.js');
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: true,
        useGitIgnoreForExcludes: true,
        parsedFileExtensions: {
          web: ['.js']
        }
      };

      const result = await processFusion(testConfig);
      expect(result.success).toBe(true);
      expect(result.message).toContain('1 files processed'); // Only app.js
      
      const fusionContent = await fs.readFile(result.fusionFilePath!, 'utf8');
      expect(fusionContent).toContain('app.js');
      expect(fusionContent).not.toContain('build.js');
      expect(fusionContent).not.toContain('node_modules');
      expect(fusionContent).not.toContain('dist');
    });

    it('should skip files larger than maxFileSizeKB', async () => {
      // Create small file
      await fs.writeFile('small.js', 'console.log("small");');
      
      // Create large file (2KB)
      const largeContent = 'console.log("large");' + 'x'.repeat(2000);
      await fs.writeFile('large.js', largeContent);
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        maxFileSizeKB: 1, // 1KB limit
        parsedFileExtensions: {
          web: ['.js']
        }
      };

      const result = await processFusion(testConfig);
      expect(result.success).toBe(true);
      expect(result.message).toContain('1 files processed'); // Only small.js
      
      const fusionContent = await fs.readFile(result.fusionFilePath!, 'utf8');
      expect(fusionContent).toContain('small.js');
      expect(fusionContent).not.toContain('large.js');
    });

    it('should respect non-recursive directory parsing', async () => {
      // Create files in root
      await fs.writeFile('root.js', 'console.log("root");');
      
      // Create files in subdirectory
      await fs.ensureDir('sub');
      await fs.writeFile('sub/nested.js', 'console.log("nested");');
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false, // Non-recursive
        parsedFileExtensions: {
          web: ['.js']
        }
      };

      const result = await processFusion(testConfig);
      expect(result.success).toBe(true);
      expect(result.message).toContain('1 files processed'); // Only root.js
      
      const fusionContent = await fs.readFile(result.fusionFilePath!, 'utf8');
      expect(fusionContent).toContain('root.js');
      expect(fusionContent).not.toContain('nested.js');
    });

    it('should generate HTML output when enabled', async () => {
      // Create test files
      await fs.writeFile('test.js', 'console.log("Hello HTML");');
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        generateHtml: true,
        parsedFileExtensions: {
          web: ['.js']
        }
      };

      const result = await processFusion(testConfig);
      expect(result.success).toBe(true);
      
      // Check HTML file was created
      const htmlPath = result.fusionFilePath!.replace('.txt', '.html');
      expect(await fs.pathExists(htmlPath)).toBe(true);
      
      const htmlContent = await fs.readFile(htmlPath, 'utf8');
      expect(htmlContent).toContain('<!DOCTYPE html>');
      expect(htmlContent).toContain('<html lang="en">');
      expect(htmlContent).toContain('test.js');
      expect(htmlContent).toContain('console.log(&quot;Hello HTML&quot;);');
    });
  });
});
```

## üìÑ tests/schema.test.ts

```typescript
import { describe, it, expect } from 'vitest';
import { ConfigSchemaV1 } from '../src/schema.js';
import { defaultConfig } from '../src/utils.js';

describe('schema', () => {
  describe('ConfigSchemaV1', () => {
    it('should validate default config', () => {
      const result = ConfigSchemaV1.safeParse(defaultConfig);
      expect(result.success).toBe(true);
    });

    it('should validate minimal valid config', () => {
      const minimalConfig = {
        schemaVersion: 1,
        generatedFileName: "test-fusion",
        copyToClipboard: false,
        generateText: true,
        generateMarkdown: true,
        generateHtml: false,
        parsedFileExtensions: {
          web: [".js", ".ts"]
        },
        rootDirectory: ".",
        parseSubDirectories: true,
        maxFileSizeKB: 1024,
        ignorePatterns: [],
        useGitIgnoreForExcludes: true
      };

      const result = ConfigSchemaV1.safeParse(minimalConfig);
      expect(result.success).toBe(true);
    });

    it('should reject config with invalid schema version', () => {
      const invalidConfig = {
        ...defaultConfig,
        schemaVersion: 2
      };

      const result = ConfigSchemaV1.safeParse(invalidConfig);
      expect(result.success).toBe(false);
    });

    it('should reject config with missing required fields', () => {
      const invalidConfig = {
        schemaVersion: 1
        // All other fields have defaults, so this should actually pass
      };

      const result = ConfigSchemaV1.safeParse(invalidConfig);
      expect(result.success).toBe(true); // Schema has defaults for all fields
    });

    it('should reject config with invalid copyToClipboard type', () => {
      const invalidConfig = {
        ...defaultConfig,
        copyToClipboard: "true" // Should be boolean
      };

      const result = ConfigSchemaV1.safeParse(invalidConfig);
      expect(result.success).toBe(false);
    });

    it('should validate config with copyToClipboard true', () => {
      const validConfig = {
        ...defaultConfig,
        copyToClipboard: true
      };

      const result = ConfigSchemaV1.safeParse(validConfig);
      expect(result.success).toBe(true);
    });

    it('should validate config with HTML generation enabled', () => {
      const validConfig = {
        ...defaultConfig,
        generateHtml: true
      };

      const result = ConfigSchemaV1.safeParse(validConfig);
      expect(result.success).toBe(true);
    });

    it('should validate config with HTML generation enabled', () => {
      const validConfig = {
        ...defaultConfig,
        generateHtml: true
      };

      const result = ConfigSchemaV1.safeParse(validConfig);
      expect(result.success).toBe(true);
    });
  });
});
```

## üìÑ tests/types.test.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for type definitions and branded types
 */
import { describe, expect, it } from 'vitest';
import { createFilePath, FusionError } from '../src/types.js';
import type { FilePath, FusionErrorCode, FusionErrorSeverity } from '../src/types.js';

describe('Branded Types', () => {
    describe('createFilePath', () => {
        it('should create a valid FilePath from a string', () => {
            const path = createFilePath('/valid/path/to/file.txt');
            expect(path).toBe('/valid/path/to/file.txt');
            expect(typeof path).toBe('string');
        });
        
        it('should throw FusionError for invalid inputs', () => {
            expect(() => createFilePath('')).toThrow(FusionError);
            expect(() => createFilePath('')).toThrow('Invalid file path provided');
            
            // @ts-expect-error Testing invalid input
            expect(() => createFilePath(null)).toThrow(FusionError);
            
            // @ts-expect-error Testing invalid input
            expect(() => createFilePath(undefined)).toThrow(FusionError);
            
            // @ts-expect-error Testing invalid input
            expect(() => createFilePath(123)).toThrow(FusionError);
        });
        
        it('should handle paths with special characters', () => {
            const specialPaths = [
                '/path with spaces/file.txt',
                '/path-with-dashes/file.txt',
                '/path_with_underscores/file.txt',
                '/path/with/unicode/Êñá‰ª∂.txt',
                'C:\\Windows\\System32\\file.txt',
                './relative/path/file.txt',
                '../parent/path/file.txt'
            ];
            
            specialPaths.forEach(p => {
                const filePath = createFilePath(p);
                expect(filePath).toBe(p);
            });
        });
        
        it('should maintain type safety', () => {
            const path = createFilePath('/test/path.txt');
            
            // This should satisfy the FilePath type
            const acceptsFilePath = (fp: FilePath): string => fp;
            expect(acceptsFilePath(path)).toBe('/test/path.txt');
        });
    });
});

describe('FusionError', () => {
    describe('constructor', () => {
        it('should create error with required parameters', () => {
            const error = new FusionError('Test error', 'INVALID_PATH');
            
            expect(error).toBeInstanceOf(Error);
            expect(error).toBeInstanceOf(FusionError);
            expect(error.message).toBe('Test error');
            expect(error.code).toBe('INVALID_PATH');
            expect(error.severity).toBe('error'); // Default severity
            expect(error.name).toBe('FusionError');
            expect(error.context).toBeUndefined();
        });
        
        it('should accept custom severity', () => {
            const errorSeverity = new FusionError('Error', 'INVALID_PATH', 'error');
            const warningSeverity = new FusionError('Warning', 'UNKNOWN_EXTENSION_GROUP', 'warning');
            const infoSeverity = new FusionError('Info', 'INVALID_PATH', 'info');
            
            expect(errorSeverity.severity).toBe('error');
            expect(warningSeverity.severity).toBe('warning');
            expect(infoSeverity.severity).toBe('info');
        });
        
        it('should accept context object', () => {
            const context = {
                path: '/test/file.txt',
                line: 42,
                details: 'Additional information'
            };
            
            const error = new FusionError(
                'Error with context',
                'INVALID_PATH',
                'error',
                context
            );
            
            expect(error.context).toEqual(context);
        });
        
        it('should have proper stack trace', () => {
            const error = new FusionError('Stack test', 'INVALID_PATH');
            
            expect(error.stack).toBeDefined();
            expect(error.stack).toContain('FusionError: Stack test');
            expect(error.stack).toContain('types.test.ts');
        });
    });
    
    describe('Error Codes', () => {
        it('should only accept valid error codes', () => {
            const validCodes: FusionErrorCode[] = [
                'INVALID_PATH',
                'UNKNOWN_EXTENSION_GROUP'
            ];
            
            validCodes.forEach(code => {
                const error = new FusionError('Test', code);
                expect(error.code).toBe(code);
            });
        });
        
        it('should maintain type safety for error codes', () => {
            // This should compile
            const error1 = new FusionError('Test', 'INVALID_PATH');
            const error2 = new FusionError('Test', 'UNKNOWN_EXTENSION_GROUP');
            
            expect(error1.code).toBe('INVALID_PATH');
            expect(error2.code).toBe('UNKNOWN_EXTENSION_GROUP');
            
            // TypeScript should prevent invalid codes at compile time
            // @ts-expect-error Invalid error code
            const invalidError = new FusionError('Test', 'INVALID_CODE');
        });
    });
    
    describe('Error Severity', () => {
        it('should only accept valid severity levels', () => {
            const validSeverities: FusionErrorSeverity[] = [
                'error',
                'warning',
                'info'
            ];
            
            validSeverities.forEach(severity => {
                const error = new FusionError('Test', 'INVALID_PATH', severity);
                expect(error.severity).toBe(severity);
            });
        });
        
        it('should maintain type safety for severity', () => {
            // Valid severities
            const error1 = new FusionError('Test', 'INVALID_PATH', 'error');
            const error2 = new FusionError('Test', 'INVALID_PATH', 'warning');
            const error3 = new FusionError('Test', 'INVALID_PATH', 'info');
            
            expect(error1.severity).toBe('error');
            expect(error2.severity).toBe('warning');
            expect(error3.severity).toBe('info');
            
            // TypeScript should prevent invalid severity at compile time
            // @ts-expect-error Invalid severity
            const invalidError = new FusionError('Test', 'INVALID_PATH', 'critical');
        });
    });
    
    describe('Error Usage Patterns', () => {
        it('should be catchable as FusionError', () => {
            try {
                throw new FusionError('Catchable error', 'INVALID_PATH');
            } catch (error) {
                expect(error).toBeInstanceOf(FusionError);
                if (error instanceof FusionError) {
                    expect(error.code).toBe('INVALID_PATH');
                    expect(error.severity).toBe('error');
                }
            }
        });
        
        it('should be catchable as generic Error', () => {
            try {
                throw new FusionError('Generic error', 'UNKNOWN_EXTENSION_GROUP');
            } catch (error) {
                expect(error).toBeInstanceOf(Error);
                if (error instanceof Error) {
                    expect(error.message).toBe('Generic error');
                }
            }
        });
        
        it('should support error chaining with context', () => {
            const originalError = new Error('Original error');
            
            const fusionError = new FusionError(
                'Wrapped error: ' + originalError.message,
                'INVALID_PATH',
                'error',
                { originalError: originalError.message, timestamp: Date.now() }
            );
            
            expect(fusionError.message).toContain('Original error');
            expect(fusionError.context).toHaveProperty('originalError');
            expect(fusionError.context?.originalError).toBe('Original error');
        });
        
        it('should be serializable', () => {
            const error = new FusionError(
                'Serializable error',
                'INVALID_PATH',
                'warning',
                { data: 'test' }
            );
            
            const serialized = JSON.stringify({
                message: error.message,
                code: error.code,
                severity: error.severity,
                context: error.context
            });
            
            const deserialized = JSON.parse(serialized);
            
            expect(deserialized.message).toBe('Serializable error');
            expect(deserialized.code).toBe('INVALID_PATH');
            expect(deserialized.severity).toBe('warning');
            expect(deserialized.context).toEqual({ data: 'test' });
        });
    });
    
    describe('Integration with createFilePath', () => {
        it('should throw FusionError with correct code', () => {
            try {
                createFilePath('');
            } catch (error) {
                expect(error).toBeInstanceOf(FusionError);
                if (error instanceof FusionError) {
                    expect(error.code).toBe('INVALID_PATH');
                    expect(error.severity).toBe('error');
                    expect(error.message).toBe('Invalid file path provided');
                }
            }
        });
    });
});
```

## üìÑ tests/utils.test.ts

```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs-extra';
import path from 'path';
import { 
  getMarkdownLanguage, 
  getExtensionsFromGroups, 
  formatTimestamp,
  formatLocalTimestamp,
  loadConfig,
  writeLog,
  ensureDirectoryExists,
  writeFileContent,
  readFileContent
} from '../src/utils.js';
import { defaultConfig } from '../src/utils.js';

describe('utils', () => {
  describe('getMarkdownLanguage', () => {
    it('should return correct language for file extensions', () => {
      expect(getMarkdownLanguage('.ts')).toBe('typescript');
      expect(getMarkdownLanguage('.js')).toBe('javascript');
      expect(getMarkdownLanguage('.py')).toBe('python');
      expect(getMarkdownLanguage('.json')).toBe('json');
    });

    it('should return correct language for files without extensions', () => {
      expect(getMarkdownLanguage('Dockerfile')).toBe('dockerfile');
      expect(getMarkdownLanguage('Makefile')).toBe('makefile');
      expect(getMarkdownLanguage('Jenkinsfile')).toBe('groovy');
    });

    it('should return text for unknown extensions', () => {
      expect(getMarkdownLanguage('.unknown')).toBe('text');
      expect(getMarkdownLanguage('UnknownFile')).toBe('text');
    });

    it('should handle case insensitive extensions', () => {
      expect(getMarkdownLanguage('.TS')).toBe('typescript');
      expect(getMarkdownLanguage('.JS')).toBe('javascript');
    });
  });

  describe('getExtensionsFromGroups', () => {
    it('should return all extensions when no groups specified', () => {
      const extensions = getExtensionsFromGroups(defaultConfig);
      expect(extensions.length).toBeGreaterThan(0);
      expect(extensions).toContain('.js');
      expect(extensions).toContain('.py');
      expect(extensions).toContain('.json');
    });

    it('should return extensions for specific groups', () => {
      const extensions = getExtensionsFromGroups(defaultConfig, ['web']);
      expect(extensions).toContain('.js');
      expect(extensions).toContain('.ts');
      expect(extensions).toContain('.html');
      expect(extensions).not.toContain('.py');
    });

    it('should return extensions for multiple groups', () => {
      const extensions = getExtensionsFromGroups(defaultConfig, ['web', 'backend']);
      expect(extensions).toContain('.js');
      expect(extensions).toContain('.py');
      expect(extensions).toContain('.go');
    });

    it('should handle unknown groups gracefully', () => {
      expect(() => {
        getExtensionsFromGroups(defaultConfig, ['unknown']);
      }).toThrow('Extension group \'unknown\' not found in config');
    });
  });

  describe('formatTimestamp', () => {
    it('should format current date when no date provided', () => {
      const timestamp = formatTimestamp();
      expect(timestamp).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/);
    });

    it('should format provided date', () => {
      const date = new Date('2025-01-01T12:00:00.000Z');
      const timestamp = formatTimestamp(date);
      expect(timestamp).toBe('2025-01-01T12:00:00.000Z');
    });
  });

  describe('formatLocalTimestamp', () => {
    it('should format current date when no date provided', () => {
      const timestamp = formatLocalTimestamp();
      expect(timestamp).toMatch(/^\d{2}\/\d{2}\/\d{4} \d{2}:\d{2}:\d{2}/);
    });

    it('should format provided date', () => {
      const date = new Date('2025-01-01T12:00:00.000Z');
      const timestamp = formatLocalTimestamp(date);
      expect(timestamp).toContain('01/01/2025');
    });
  });

  describe('file operations', () => {
    const testDir = path.resolve('./temp/test-utils');
    const testFile = path.join(testDir, 'test.txt');

    beforeEach(async () => {
      await fs.ensureDir(testDir);
    });

    afterEach(async () => {
      await fs.remove(testDir);
    });

    describe('ensureDirectoryExists', () => {
      it('should create directory if it does not exist', async () => {
        const newDir = path.join(testDir, 'new-dir');
        expect(await fs.pathExists(newDir)).toBe(false);
        
        await ensureDirectoryExists(newDir);
        expect(await fs.pathExists(newDir)).toBe(true);
      });

      it('should not fail if directory already exists', async () => {
        await ensureDirectoryExists(testDir);
        // Should not throw
        await ensureDirectoryExists(testDir);
        expect(await fs.pathExists(testDir)).toBe(true);
      });
    });

    describe('writeFileContent', () => {
      it('should write content to file', async () => {
        const content = 'Hello World!';
        await writeFileContent(testFile, content);
        
        expect(await fs.pathExists(testFile)).toBe(true);
        const readContent = await fs.readFile(testFile, 'utf8');
        expect(readContent).toBe(content);
      });

      it('should create directory if it does not exist', async () => {
        const nestedFile = path.join(testDir, 'nested', 'deep', 'file.txt');
        const content = 'Nested content';
        
        await writeFileContent(nestedFile, content);
        expect(await fs.pathExists(nestedFile)).toBe(true);
        const readContent = await fs.readFile(nestedFile, 'utf8');
        expect(readContent).toBe(content);
      });
    });

    describe('readFileContent', () => {
      it('should read file content', async () => {
        const content = 'Test content';
        await fs.writeFile(testFile, content);
        
        const readContent = await readFileContent(testFile);
        expect(readContent).toBe(content);
      });

      it('should throw error for non-existent file', async () => {
        const nonExistentFile = path.join(testDir, 'does-not-exist.txt');
        await expect(readFileContent(nonExistentFile)).rejects.toThrow();
      });
    });

    describe('writeLog', () => {
      it('should write log content to file', async () => {
        const logFile = path.join(testDir, 'test.log');
        const logContent = 'Log entry';
        
        await writeLog(logFile, logContent);
        expect(await fs.pathExists(logFile)).toBe(true);
        const content = await fs.readFile(logFile, 'utf8');
        expect(content).toBe(logContent + '\n');
      });

      it('should append log content when append is true', async () => {
        const logFile = path.join(testDir, 'test.log');
        const firstEntry = 'First entry';
        const secondEntry = 'Second entry';
        
        await writeLog(logFile, firstEntry);
        await writeLog(logFile, secondEntry, true);
        
        const content = await fs.readFile(logFile, 'utf8');
        expect(content).toBe(firstEntry + '\n' + secondEntry + '\n');
      });

      it('should overwrite log content when append is false', async () => {
        const logFile = path.join(testDir, 'test.log');
        const firstEntry = 'First entry';
        const secondEntry = 'Second entry';
        
        await writeLog(logFile, firstEntry);
        await writeLog(logFile, secondEntry, false);
        
        const content = await fs.readFile(logFile, 'utf8');
        expect(content).toBe(secondEntry + '\n');
      });
    });
  });

  describe('loadConfig', () => {
    const testDir = path.resolve('./temp/test-config');
    const configFile = path.join(testDir, 'project-fusion.json');

    beforeEach(async () => {
      await fs.ensureDir(testDir);
      // Set working directory to test directory
      process.chdir(testDir);
    });

    afterEach(async () => {
      // Restore original working directory
      process.chdir(path.resolve('./../../'));
      await fs.remove(testDir);
    });

    it('should return default config when no config file exists', async () => {
      const config = await loadConfig();
      expect(config).toEqual(defaultConfig);
    });

    it('should load valid config from file', async () => {
      const validConfig = {
        schemaVersion: 1,
        generatedFileName: 'custom-fusion',
        copyToClipboard: true,
        generateText: true,
        generateMarkdown: false,
        generateHtml: true,
        parsedFileExtensions: {
          web: ['.js', '.ts']
        },
        parseSubDirectories: false,
        rootDirectory: '.',
        maxFileSizeKB: 512,
        ignorePatterns: ['*.log'],
        useGitIgnoreForExcludes: false
      };

      await fs.writeJson(configFile, validConfig);
      const config = await loadConfig();
      // Config will be merged with defaults, so just check our specific values
      expect(config.schemaVersion).toBe(validConfig.schemaVersion);
      expect(config.generatedFileName).toBe(validConfig.generatedFileName);
      expect(config.copyToClipboard).toBe(validConfig.copyToClipboard);
      expect(config.generateText).toBe(validConfig.generateText);
      expect(config.generateMarkdown).toBe(validConfig.generateMarkdown);
      expect(config.generateHtml).toBe(validConfig.generateHtml);
      expect(config.parsedFileExtensions.web).toEqual(validConfig.parsedFileExtensions.web);
      expect(config.parseSubDirectories).toBe(validConfig.parseSubDirectories);
      expect(config.rootDirectory).toBe(validConfig.rootDirectory);
      expect(config.maxFileSizeKB).toBe(validConfig.maxFileSizeKB);
      expect(config.ignorePatterns).toEqual(validConfig.ignorePatterns);
      expect(config.useGitIgnoreForExcludes).toBe(validConfig.useGitIgnoreForExcludes);
    });

    it('should return default config for invalid JSON', async () => {
      await fs.writeFile(configFile, 'invalid json {');
      const config = await loadConfig();
      expect(config).toEqual(defaultConfig);
    });

    it('should return default config for invalid schema', async () => {
      const invalidConfig = {
        schemaVersion: 'invalid',
        invalidField: true
      };

      await fs.writeJson(configFile, invalidConfig);
      const config = await loadConfig();
      expect(config).toEqual(defaultConfig);
    });
  });
});
```

## üìÑ TODO.md

```markdown
- [ ] Script `npm pack --dry-run` dans DEVELOPMENT.md
- [ ] Script `npm publish --dry-run` 
- [ ] Guide complet de publication
```

## üìÑ tsconfig.json

```json
{
    "compilerOptions": {
        "target": "ES2022",
        "module": "NodeNext",
        "moduleResolution": "NodeNext",
        "esModuleInterop": true,
        "resolveJsonModule": true,
        "strict": true,
        "declaration": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "noUncheckedIndexedAccess": true,
        "exactOptionalPropertyTypes": true,
        "verbatimModuleSyntax": true,
        "useUnknownInCatchVariables": true,
        "noPropertyAccessFromIndexSignature": true,
        "outDir": "./dist",
        "rootDir": "./src"
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "dist"]
}
```

## üìÑ vitest.config.ts

```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      reportsDirectory: './coverage',
      include: ['src/**/*.ts'],
      exclude: [
        'src/**/*.d.ts',
        'src/cli.ts', // CLI entry point - harder to test
        'node_modules/**'
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      }
    }
  },
});
```

