# Generated Project Fusion File

**Project:** project-fusion v0.0.1

**Generated:** 17/08/2025 00:58:47 UTC‚àí4

**UTC:** 2025-08-17T04:58:47.575Z

**Files:** 23

**Generated by:** [project-fusion](https://github.com/the99studio/project-fusion)

---

## üìÅ Table of Contents

- [CHANGELOG.md](#changelog-md)
- [CLAUDE.md](#claude-md)
- [CONTRIBUTING.md](#contributing-md)
- [DEVELOPMENT.md](#development-md)
- [eslint.config.js](#eslint-config-js)
- [package.json](#package-json)
- [project-fusioned.html](#project-fusioned-html)
- [README.md](#readme-md)
- [src/benchmark.ts](#src-benchmark-ts)
- [src/cli.ts](#src-cli-ts)
- [src/clicommands.ts](#src-clicommands-ts)
- [src/fusion.ts](#src-fusion-ts)
- [src/index.ts](#src-index-ts)
- [src/schema.ts](#src-schema-ts)
- [src/types.ts](#src-types-ts)
- [src/utils.ts](#src-utils-ts)
- [tests/formats.test.ts](#tests-formats-test-ts)
- [tests/integration.test.ts](#tests-integration-test-ts)
- [tests/schema.test.ts](#tests-schema-test-ts)
- [tests/utils.test.ts](#tests-utils-test-ts)
- [TODO.md](#todo-md)
- [tsconfig.json](#tsconfig-json)
- [vitest.config.ts](#vitest-config-ts)

---

## üìÑ CHANGELOG.md

```markdown
TODO
```

## üìÑ CLAUDE.md

```markdown
# Project Fusion - AI Context

> üìñ **For Human Development**: See [DEVELOPMENT.md](./DEVELOPMENT.md) for detailed development workflows, testing procedures, and npm publication guide.

## Project Overview
Project Fusion merges multiple project files into a single file for easy sharing and collaboration.

## Essential Architecture
- **TypeScript 5.9.2** ESM project with strict type checking
- **CLI tool** built with Commander.js that generates .txt and .md fusion files
- **Configuration-driven** with Zod validation and default fallbacks
- **Multi-format output** with syntax highlighting and filtering

## Core Files Structure
```
src/
‚îú‚îÄ‚îÄ cli.ts              # CLI entry point
‚îú‚îÄ‚îÄ clicommands.ts      # Command implementations  
‚îú‚îÄ‚îÄ fusion.ts           # Core fusion logic
‚îú‚îÄ‚îÄ types.ts            # Type definitions (branded types)
‚îú‚îÄ‚îÄ schema.ts           # Zod validation schemas
‚îú‚îÄ‚îÄ utils.ts            # File operations & utilities
‚îî‚îÄ‚îÄ index.ts            # Main exports
```

## Key Commands
```bash
npm run build           # Build TypeScript ‚Üí JavaScript
npm run typecheck       # Type checking only
project-fusion init     # Initialize config
project-fusion fusion   # Run fusion process
```

## Testing Directory
**‚ö†Ô∏è Important**: All testing and temporary files MUST be created in `temp/` directory at project root. This includes:
- Package testing: `temp/package/`
- File generation tests: `temp/test-files/`
- Any temporary artifacts: `temp/artifacts/`

The `temp/` directory is gitignored and safe for any testing activities.

## Configuration Schema
```typescript
{
  schemaVersion: 1
  copyToClipboard: boolean
  generatedFileName: string
  generateHtml: boolean
  generateMarkdown: boolean
  generateText: boolean
  maxFileSizeKB: number
  parseSubDirectories: boolean
  parsedFileExtensions: {
    web: string[]       // .js, .ts, .tsx, .vue, etc.
    backend: string[]   // .py, .go, .java, .rs, etc. 
    config: string[]    // .json, .yaml, .toml, etc.
    cpp: string[]       // .c, .cpp, .h, .hpp
    scripts: string[]   // .sh, .bat, .ps1
    godot: string[]     // .gd, .tscn, .tres
    doc: string[]       // .md, .rst, .adoc
  }
  rootDirectory: string
  ignorePatterns: string[]
  useGitIgnoreForExcludes: boolean
}
```

## Core Workflow
1. Load `project-fusion.json` config with Zod validation
2. Scan files by extensions, apply .gitignore + custom ignore patterns
3. Generate dual output:
   - `project-fusioned.txt` - Plain text with separators
   - `project-fusioned.md` - Markdown with syntax highlighting + TOC

## Key Implementation Details
- **Branded types** (FilePath) prevent string confusion
- **Discriminated unions** (FusionResult) for type-safe error handling  
- **ESM modules** with strict TypeScript
- **Configuration fallbacks** - uses defaults if config missing/invalid

## Quick Reference
- **Add extensions**: Update `src/schema.ts` + `src/utils.ts` default config
- **Add commands**: Register in `src/cli.ts`, implement in `src/clicommands.ts`
- **Modify output**: Edit `src/fusion.ts` processing logic
```

## üìÑ CONTRIBUTING.md

```markdown
# Contributing to Project Fusion

Thanks for your interest! This guide explains how to propose changes and report issues.

## Code of Conduct
Be respectful and constructive. By participating, you agree to foster an open and welcoming environment.

## How to contribute
1. **Fork** the repo and create a branch: `feat/<short-name>` or `fix/<short-name>`.
2. See [DEVELOPMENT.md](./DEVELOPMENT.md) for detailed development workflows, testing procedures, and npm publication guide.
3. Open a Pull Request with a clear description and checklist.

## PR checklist
- [ ] Feature/bugfix tested
- [ ] No regressions
- [ ] Docs/README updated if necessary
- [ ] Notable changes added to `CHANGELOG.md`

```

## üìÑ DEVELOPMENT.md

```markdown
# Project Fusion - Development Guide

> üìã **For Claude AI Context**: See [CLAUDE.md](./CLAUDE.md) for essential project information needed for development assistance.

## üöÄ Development Workflow

### Initial Setup
```bash
git clone https://github.com/the99studio/project-fusion.git
cd project-fusion
npm install
npm run build
```

### Claude Code Integration
The project includes `.claude/settings.local.json` which configures Claude Code permissions for smoother development. This file provides:

**Allowed Operations:**
- NPM commands: install, build, typecheck, test, clean, pack
- Project CLI: `project-fusion` and `node dist/cli.js` commands
- Git operations: status, diff, log, branch, add, commit, push, pull
- Safe file operations: Limited to `temp/` directory for rm/cp operations
- Search capabilities: find, grep, rg, ls, cat, head, tail for code exploration
- Package management: npm list, outdated, view

**Security Features:**
- File deletions restricted to `temp/` directory only
- No arbitrary Node.js code execution (only specific CLI commands)
- Explicit deny list for dangerous operations (sudo, eval, etc.)
- No system-wide file modifications allowed

These permissions eliminate repetitive authorization prompts while maintaining security boundaries.

### Testing the CLI
Use VS Code launch configurations (F5) for easy testing:
- **"Fusion (Default)"** - Default behavior (runs fusion)
- **"Fusion (Web)"** - Test web extensions only
- **"Help"** - Test CLI help
- **"Init"** - Test project initialization

### Testing with Real Package
For testing as if it were the real published package, see the [NPM Package Testing](#-npm-package-management) section below.

## üì¶ NPM Package Management

### Pre-Publication Testing

Use the **"Test NPM Package"** launch configuration in VS Code (F5) which automatically:
- Builds the project
- Creates and extracts test package to `temp/package/`
- Installs dependencies and tests CLI functionality

#### Manual Package Verification
```bash
# Preview what will be published
npm pack --dry-run

# Create test package (if not using VS Code)
npm pack  # Creates project-fusion-x.x.x.tgz
```

#### Testing with Real Package Installation
```bash
# Install the test package globally
npm install -g ./temp/package/ # start line with sudo if you need admin rights

# Test commands (acts like real published package)
project-fusion --help
project-fusion --version
project-fusion init
project-fusion # Default: runs fusion

# Uninstall when done testing
npm uninstall -g project-fusion # start line with sudo if you need admin rights
```

### Publication Process

```bash
# 1. Final verification
npm pack --dry-run

# 2. Simulate publication (verifies authentication, package validity)
npm publish --dry-run

# 3. Create npm account and login (first time only)
# Visit https://www.npmjs.com/signup to create account
npm login

# 4. Publish to npm
npm publish

# 5. Verify publication
npm view project-fusion
```

## üõ†Ô∏è Development Patterns

### Adding New File Extensions
1. Update `src/schema.ts` - add to `ParsedFileExtensionsSchema`
2. Update default config in `src/utils.ts` 
3. Test with various projects

### Adding New CLI Commands
1. Register command in `src/cli.ts` (Commander.js)
2. Implement in `src/clicommands.ts`
3. Update help text and documentation

### Modifying Fusion Output
1. Edit `src/fusion.ts` processing logic
2. Update types in `src/types.ts` if needed
3. Test both .txt and .md output formats

## üß™ Testing Strategy

### Manual Testing Checklist
- [ ] `npm run build` - clean build
- [ ] `npm run typecheck` - no type errors
- [ ] CLI help works: `project-fusion --help`
- [ ] Init works: `project-fusion init`
- [ ] Fusion works: `project-fusion fusion`
- [ ] Extension filtering works
- [ ] .gitignore integration works
- [ ] Output files are properly formatted
- [ ] Package builds and installs correctly

### Test Projects
Use these types of projects for testing:
- **Node.js/TypeScript** (like this project)
- **Python projects** (test backend extensions)
- **React/Vue projects** (test web extensions)
- **Mixed projects** (multiple extension types)

## üîß Troubleshooting

### Common Issues

**Build Errors:**
```bash
npm run clean && npm run build
```

**Package Contains Wrong Files:**
- Check `package.json` `files` field
- Use `npm pack --dry-run` to verify

**TypeScript Errors:**
```bash
npm run typecheck
# Fix errors in src/ files
```

## üìÅ Directory Structure

```
project-fusion/
‚îú‚îÄ‚îÄ src/                    # TypeScript source
‚îÇ   ‚îú‚îÄ‚îÄ cli.ts             # CLI entry point
‚îÇ   ‚îú‚îÄ‚îÄ clicommands.ts     # Command implementations
‚îÇ   ‚îú‚îÄ‚îÄ fusion.ts          # Core fusion logic
‚îÇ   ‚îú‚îÄ‚îÄ types.ts           # Type definitions
‚îÇ   ‚îú‚îÄ‚îÄ schema.ts          # Zod schemas
‚îÇ   ‚îú‚îÄ‚îÄ utils.ts           # Utilities
‚îÇ   ‚îî‚îÄ‚îÄ index.ts           # Main exports
‚îú‚îÄ‚îÄ dist/                  # Compiled JavaScript (gitignored)
‚îú‚îÄ‚îÄ temp/                  # Testing directory (gitignored)
‚îú‚îÄ‚îÄ CLAUDE.md              # AI context (essential info)
‚îú‚îÄ‚îÄ DEVELOPMENT.md         # This file (human development)
‚îú‚îÄ‚îÄ package.json           # NPM configuration
‚îî‚îÄ‚îÄ tsconfig.json          # TypeScript configuration
```

## üîó Important Files

- **CLAUDE.md** - Essential project context for AI assistance
- **package.json** - NPM package configuration and scripts
- **tsconfig.json** - TypeScript compilation settings
- **.gitignore** - Git ignore patterns (includes `temp/`)
- **.vscode/launch.json** - VS Code debugging/testing configurations
```

## üìÑ eslint.config.js

```javascript
import js from '@eslint/js';
import tseslint from '@typescript-eslint/eslint-plugin';
import tsparser from '@typescript-eslint/parser';
import importPlugin from 'eslint-plugin-import';
import unicorn from 'eslint-plugin-unicorn';

export default [
  js.configs.recommended,
  {
    files: ['src/**/*.ts'],
    languageOptions: {
      parser: tsparser,
      parserOptions: {
        ecmaVersion: 2022,
        sourceType: 'module',
        project: './tsconfig.json'
      },
      globals: {
        console: 'readonly',
        process: 'readonly',
        Buffer: 'readonly',
        __dirname: 'readonly',
        __filename: 'readonly',
        NodeJS: 'readonly'
      }
    },
    plugins: {
      '@typescript-eslint': tseslint,
      'import': importPlugin,
      'unicorn': unicorn
    },
    rules: {
      // TypeScript strict rules
      '@typescript-eslint/no-explicit-any': 'error',
      '@typescript-eslint/no-unused-vars': 'error',
      '@typescript-eslint/prefer-readonly': 'error',
      '@typescript-eslint/explicit-function-return-type': 'error',
      '@typescript-eslint/explicit-module-boundary-types': 'error',
      '@typescript-eslint/no-inferrable-types': 'error',
      '@typescript-eslint/no-unnecessary-type-assertion': 'error',
      '@typescript-eslint/prefer-nullish-coalescing': 'error',
      '@typescript-eslint/prefer-optional-chain': 'error',
      '@typescript-eslint/prefer-string-starts-ends-with': 'error',
      '@typescript-eslint/prefer-includes': 'error',
      '@typescript-eslint/no-floating-promises': 'error',
      '@typescript-eslint/await-thenable': 'error',
      '@typescript-eslint/no-misused-promises': 'error',
      '@typescript-eslint/require-await': 'error',

      // General code quality
      'no-console': 'off', // CLI app needs console output
      'no-debugger': 'error',
      'no-alert': 'error',
      'no-var': 'error',
      'prefer-const': 'error',
      'prefer-arrow-callback': 'error',
      'prefer-template': 'error',
      'object-shorthand': 'error',
      'quote-props': ['error', 'as-needed'],
      'no-duplicate-imports': 'error',
      
      // Import rules
      'import/order': [
        'error',
        {
          'groups': [
            'builtin',
            'external', 
            'internal',
            'parent',
            'sibling',
            'index'
          ],
          'newlines-between': 'never',
          'alphabetize': {
            'order': 'asc',
            'caseInsensitive': true
          }
        }
      ],
      'import/no-duplicates': 'error',

      // Unicorn rules for modern JS practices
      'unicorn/prefer-node-protocol': 'error',
      'unicorn/prefer-module': 'error',
      'unicorn/prefer-ternary': 'warn',
      'unicorn/prefer-logical-operator-over-ternary': 'error',
      'unicorn/no-array-for-each': 'warn',
      'unicorn/prefer-array-some': 'error',
      'unicorn/prefer-array-find': 'error',
      'unicorn/prefer-array-flat': 'error',
      'unicorn/prefer-object-from-entries': 'error',
      'unicorn/prefer-set-has': 'error',
      'unicorn/prefer-string-slice': 'error',
      'unicorn/prefer-number-properties': 'error',
      'unicorn/numeric-separators-style': 'error',
      'unicorn/better-regex': 'error',
      'unicorn/catch-error-name': 'error',
      'unicorn/custom-error-definition': 'error',
      'unicorn/error-message': 'error',
      'unicorn/escape-case': 'error',
      'unicorn/explicit-length-check': 'error',
      'unicorn/filename-case': [
        'error',
        {
          'cases': {
            'camelCase': true,
            'pascalCase': true,
            'kebabCase': true
          }
        }
      ],
      'unicorn/new-for-builtins': 'error',
      'unicorn/no-abusive-eslint-disable': 'error',
      'unicorn/no-array-push-push': 'error',
      'unicorn/no-console-spaces': 'error',
      'unicorn/no-hex-escape': 'error',
      'unicorn/no-instanceof-array': 'error',
      'unicorn/no-new-buffer': 'error',
      'unicorn/no-unnecessary-await': 'error',
      'unicorn/no-useless-length-check': 'error',
      'unicorn/no-useless-spread': 'error',
      'unicorn/no-zero-fractions': 'error',
      'unicorn/number-literal-case': 'error',
      'unicorn/prefer-add-event-listener': 'error',
      'unicorn/prefer-array-index-of': 'error',
      'unicorn/prefer-date-now': 'error',
      'unicorn/prefer-default-parameters': 'error',
      'unicorn/prefer-includes': 'error',
      'unicorn/prefer-math-trunc': 'error',
      'unicorn/prefer-negative-index': 'error',
      'unicorn/prefer-optional-catch-binding': 'error',
      'unicorn/prefer-prototype-methods': 'error',
      'unicorn/prefer-reflect-apply': 'error',
      'unicorn/prefer-regexp-test': 'error',
      'unicorn/prefer-spread': 'error',
      'unicorn/prefer-string-replace-all': 'error',
      'unicorn/prefer-string-trim-start-end': 'error',
      'unicorn/prefer-switch': 'error',
      'unicorn/prefer-type-error': 'error',
      'unicorn/throw-new-error': 'error'
    }
  },
  {
    files: ['tests/**/*', '**/*.test.ts', '**/*.spec.ts'],
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/explicit-function-return-type': 'off',
      'no-console': 'off'
    }
  }
];
```

## üìÑ package.json

```json
{
    "name": "project-fusion",
    "version": "0.0.1",
    "description": "CLI tool for merging project files into a single file for easy sharing",
    "main": "dist/index.js",
    "types": "dist/index.d.ts",
    "type": "module",
    "bin": {
        "project-fusion": "dist/cli.js"
    },
    "exports": {
        ".": {
            "types": "./dist/index.d.ts",
            "import": "./dist/index.js"
        },
        "./package.json": "./package.json"
    },
    "files": [
        "dist/**/*",
        "README.md",
        "LICENSE",
        "CHANGELOG.md"
    ],
    "sideEffects": false,
    "scripts": {
        "build": "tsc",
        "clean": "rm -rf dist",
        "dev": "tsc --watch",
        "lint": "eslint src/**/*.ts",
        "lint:fix": "eslint src/**/*.ts --fix",
        "prepublishOnly": "npm run clean && npm run build",
        "test": "vitest",
        "test:coverage": "vitest run --coverage",
        "test:ui": "vitest --ui",
        "typecheck": "tsc --noEmit"
    },
    "keywords": [
        "cli",
        "code",
        "collaboration",
        "files",
        "fusion",
        "merge",
        "sharing"
    ],
    "author": "the99studio",
    "license": "MIT",
    "engines": {
        "node": ">=18.0.0"
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/the99studio/project-fusion.git"
    },
    "bugs": {
        "url": "https://github.com/the99studio/project-fusion/issues"
    },
    "homepage": "https://github.com/the99studio/project-fusion#readme",
    "dependencies": {
        "chalk": "^5.5.0",
        "clipboardy": "^4.0.0",
        "commander": "^14.0.0",
        "fs-extra": "^11.3.1",
        "glob": "^11.0.3",
        "ignore": "^7.0.5",
        "zod": "^4.0.17"
    },
    "devDependencies": {
        "@types/fs-extra": "^11.0.4",
        "@types/node": "^24.2.1",
        "@typescript-eslint/eslint-plugin": "^8.39.1",
        "@typescript-eslint/parser": "^8.39.1",
        "@vitest/coverage-v8": "^2.1.9",
        "eslint": "^9.33.0",
        "eslint-plugin-import": "^2.32.0",
        "eslint-plugin-node": "^11.1.0",
        "eslint-plugin-unicorn": "^60.0.0",
        "typescript": "^5.9.2",
        "vitest": "^2.1.6"
    }
}

```

## üìÑ project-fusioned.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Fusion - project-fusion v0.0.1</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { border-bottom: 2px solid #eee; padding-bottom: 20px; margin-bottom: 30px; }
        .file-section { margin-bottom: 40px; border: 1px solid #ddd; border-radius: 8px; padding: 20px; }
        .file-title { background: #f5f5f5; margin: -20px -20px 20px -20px; padding: 15px 20px; border-radius: 8px 8px 0 0; }
        pre { background: #f8f9fa; padding: 15px; border-radius: 6px; overflow-x: auto; }
        code { font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; }
        .toc { background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 30px; }
        .toc ul { margin: 0; padding-left: 20px; }
        .toc a { text-decoration: none; color: #0366d6; }
        .toc a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Generated Project Fusion File</h1>
        <p><strong>Project:</strong> project-fusion v0.0.1</p>
        <p><strong>Generated:</strong> 17/08/2025 00:58:47 UTC‚àí4</p>
        <p><strong>UTC:</strong> 2025-08-17T04:58:47.575Z</p>
        <p><strong>Files:</strong> 23</p>
        <p><strong>Generated by:</strong> <a href="https://github.com/the99studio/project-fusion">project-fusion</a></p>
    </div>
    <div class="toc">
        <h2>üìÅ Table of Contents</h2>
        <ul>
            <li><a href="#changelog-md">CHANGELOG.md</a></li>
            <li><a href="#claude-md">CLAUDE.md</a></li>
            <li><a href="#contributing-md">CONTRIBUTING.md</a></li>
            <li><a href="#development-md">DEVELOPMENT.md</a></li>
            <li><a href="#eslint-config-js">eslint.config.js</a></li>
            <li><a href="#package-json">package.json</a></li>
            <li><a href="#project-fusioned-html">project-fusioned.html</a></li>
            <li><a href="#readme-md">README.md</a></li>
            <li><a href="#src-benchmark-ts">src/benchmark.ts</a></li>
            <li><a href="#src-cli-ts">src/cli.ts</a></li>
            <li><a href="#src-clicommands-ts">src/clicommands.ts</a></li>
            <li><a href="#src-fusion-ts">src/fusion.ts</a></li>
            <li><a href="#src-index-ts">src/index.ts</a></li>
            <li><a href="#src-schema-ts">src/schema.ts</a></li>
            <li><a href="#src-types-ts">src/types.ts</a></li>
            <li><a href="#src-utils-ts">src/utils.ts</a></li>
            <li><a href="#tests-formats-test-ts">tests/formats.test.ts</a></li>
            <li><a href="#tests-integration-test-ts">tests/integration.test.ts</a></li>
            <li><a href="#tests-schema-test-ts">tests/schema.test.ts</a></li>
            <li><a href="#tests-utils-test-ts">tests/utils.test.ts</a></li>
            <li><a href="#todo-md">TODO.md</a></li>
            <li><a href="#tsconfig-json">tsconfig.json</a></li>
            <li><a href="#vitest-config-ts">vitest.config.ts</a></li>
        </ul>
    </div>    <div class="file-section" id="changelog-md">
        <div class="file-title">
            <h2>üìÑ CHANGELOG.md</h2>
        </div>
        <pre><code class="markdown">TODO</code></pre>
    </div>

    <div class="file-section" id="claude-md">
        <div class="file-title">
            <h2>üìÑ CLAUDE.md</h2>
        </div>
        <pre><code class="markdown"># Project Fusion - AI Context

&gt; üìñ **For Human Development**: See [DEVELOPMENT.md](./DEVELOPMENT.md) for detailed development workflows, testing procedures, and npm publication guide.

## Project Overview
Project Fusion merges multiple project files into a single file for easy sharing and collaboration.

## Essential Architecture
- **TypeScript 5.9.2** ESM project with strict type checking
- **CLI tool** built with Commander.js that generates .txt and .md fusion files
- **Configuration-driven** with Zod validation and default fallbacks
- **Multi-format output** with syntax highlighting and filtering

## Core Files Structure
```
src/
‚îú‚îÄ‚îÄ cli.ts              # CLI entry point
‚îú‚îÄ‚îÄ clicommands.ts      # Command implementations  
‚îú‚îÄ‚îÄ fusion.ts           # Core fusion logic
‚îú‚îÄ‚îÄ types.ts            # Type definitions (branded types)
‚îú‚îÄ‚îÄ schema.ts           # Zod validation schemas
‚îú‚îÄ‚îÄ utils.ts            # File operations &amp; utilities
‚îî‚îÄ‚îÄ index.ts            # Main exports
```

## Key Commands
```bash
npm run build           # Build TypeScript ‚Üí JavaScript
npm run typecheck       # Type checking only
project-fusion init     # Initialize config
project-fusion fusion   # Run fusion process
```

## Testing Directory
**‚ö†Ô∏è Important**: All testing and temporary files MUST be created in `temp/` directory at project root. This includes:
- Package testing: `temp/package/`
- File generation tests: `temp/test-files/`
- Any temporary artifacts: `temp/artifacts/`

The `temp/` directory is gitignored and safe for any testing activities.

## Configuration Schema
```typescript
{
  schemaVersion: 1
  copyToClipboard: boolean
  generatedFileName: string
  generateHtml: boolean
  generateMarkdown: boolean
  generateText: boolean
  maxFileSizeKB: number
  parseSubDirectories: boolean
  parsedFileExtensions: {
    web: string[]       // .js, .ts, .tsx, .vue, etc.
    backend: string[]   // .py, .go, .java, .rs, etc. 
    config: string[]    // .json, .yaml, .toml, etc.
    cpp: string[]       // .c, .cpp, .h, .hpp
    scripts: string[]   // .sh, .bat, .ps1
    godot: string[]     // .gd, .tscn, .tres
    doc: string[]       // .md, .rst, .adoc
  }
  rootDirectory: string
  ignorePatterns: string[]
  useGitIgnoreForExcludes: boolean
}
```

## Core Workflow
1. Load `project-fusion.json` config with Zod validation
2. Scan files by extensions, apply .gitignore + custom ignore patterns
3. Generate dual output:
   - `project-fusioned.txt` - Plain text with separators
   - `project-fusioned.md` - Markdown with syntax highlighting + TOC

## Key Implementation Details
- **Branded types** (FilePath) prevent string confusion
- **Discriminated unions** (FusionResult) for type-safe error handling  
- **ESM modules** with strict TypeScript
- **Configuration fallbacks** - uses defaults if config missing/invalid

## Quick Reference
- **Add extensions**: Update `src/schema.ts` + `src/utils.ts` default config
- **Add commands**: Register in `src/cli.ts`, implement in `src/clicommands.ts`
- **Modify output**: Edit `src/fusion.ts` processing logic</code></pre>
    </div>

    <div class="file-section" id="contributing-md">
        <div class="file-title">
            <h2>üìÑ CONTRIBUTING.md</h2>
        </div>
        <pre><code class="markdown"># Contributing to Project Fusion

Thanks for your interest! This guide explains how to propose changes and report issues.

## Code of Conduct
Be respectful and constructive. By participating, you agree to foster an open and welcoming environment.

## How to contribute
1. **Fork** the repo and create a branch: `feat/&lt;short-name&gt;` or `fix/&lt;short-name&gt;`.
2. See [DEVELOPMENT.md](./DEVELOPMENT.md) for detailed development workflows, testing procedures, and npm publication guide.
3. Open a Pull Request with a clear description and checklist.

## PR checklist
- [ ] Feature/bugfix tested
- [ ] No regressions
- [ ] Docs/README updated if necessary
- [ ] Notable changes added to `CHANGELOG.md`
</code></pre>
    </div>

    <div class="file-section" id="development-md">
        <div class="file-title">
            <h2>üìÑ DEVELOPMENT.md</h2>
        </div>
        <pre><code class="markdown"># Project Fusion - Development Guide

&gt; üìã **For Claude AI Context**: See [CLAUDE.md](./CLAUDE.md) for essential project information needed for development assistance.

## üöÄ Development Workflow

### Initial Setup
```bash
git clone https://github.com/the99studio/project-fusion.git
cd project-fusion
npm install
npm run build
```

### Claude Code Integration
The project includes `.claude/settings.local.json` which configures Claude Code permissions for smoother development. This file provides:

**Allowed Operations:**
- NPM commands: install, build, typecheck, test, clean, pack
- Project CLI: `project-fusion` and `node dist/cli.js` commands
- Git operations: status, diff, log, branch, add, commit, push, pull
- Safe file operations: Limited to `temp/` directory for rm/cp operations
- Search capabilities: find, grep, rg, ls, cat, head, tail for code exploration
- Package management: npm list, outdated, view

**Security Features:**
- File deletions restricted to `temp/` directory only
- No arbitrary Node.js code execution (only specific CLI commands)
- Explicit deny list for dangerous operations (sudo, eval, etc.)
- No system-wide file modifications allowed

These permissions eliminate repetitive authorization prompts while maintaining security boundaries.

### Testing the CLI
Use VS Code launch configurations (F5) for easy testing:
- **&quot;Fusion (Default)&quot;** - Default behavior (runs fusion)
- **&quot;Fusion (Web)&quot;** - Test web extensions only
- **&quot;Help&quot;** - Test CLI help
- **&quot;Init&quot;** - Test project initialization

### Testing with Real Package
For testing as if it were the real published package, see the [NPM Package Testing](#-npm-package-management) section below.

## üì¶ NPM Package Management

### Pre-Publication Testing

Use the **&quot;Test NPM Package&quot;** launch configuration in VS Code (F5) which automatically:
- Builds the project
- Creates and extracts test package to `temp/package/`
- Installs dependencies and tests CLI functionality

#### Manual Package Verification
```bash
# Preview what will be published
npm pack --dry-run

# Create test package (if not using VS Code)
npm pack  # Creates project-fusion-x.x.x.tgz
```

#### Testing with Real Package Installation
```bash
# Install the test package globally
npm install -g ./temp/package/ # start line with sudo if you need admin rights

# Test commands (acts like real published package)
project-fusion --help
project-fusion --version
project-fusion init
project-fusion # Default: runs fusion

# Uninstall when done testing
npm uninstall -g project-fusion # start line with sudo if you need admin rights
```

### Publication Process

```bash
# 1. Final verification
npm pack --dry-run

# 2. Simulate publication (verifies authentication, package validity)
npm publish --dry-run

# 3. Create npm account and login (first time only)
# Visit https://www.npmjs.com/signup to create account
npm login

# 4. Publish to npm
npm publish

# 5. Verify publication
npm view project-fusion
```

## üõ†Ô∏è Development Patterns

### Adding New File Extensions
1. Update `src/schema.ts` - add to `ParsedFileExtensionsSchema`
2. Update default config in `src/utils.ts` 
3. Test with various projects

### Adding New CLI Commands
1. Register command in `src/cli.ts` (Commander.js)
2. Implement in `src/clicommands.ts`
3. Update help text and documentation

### Modifying Fusion Output
1. Edit `src/fusion.ts` processing logic
2. Update types in `src/types.ts` if needed
3. Test both .txt and .md output formats

## üß™ Testing Strategy

### Manual Testing Checklist
- [ ] `npm run build` - clean build
- [ ] `npm run typecheck` - no type errors
- [ ] CLI help works: `project-fusion --help`
- [ ] Init works: `project-fusion init`
- [ ] Fusion works: `project-fusion fusion`
- [ ] Extension filtering works
- [ ] .gitignore integration works
- [ ] Output files are properly formatted
- [ ] Package builds and installs correctly

### Test Projects
Use these types of projects for testing:
- **Node.js/TypeScript** (like this project)
- **Python projects** (test backend extensions)
- **React/Vue projects** (test web extensions)
- **Mixed projects** (multiple extension types)

## üîß Troubleshooting

### Common Issues

**Build Errors:**
```bash
npm run clean &amp;&amp; npm run build
```

**Package Contains Wrong Files:**
- Check `package.json` `files` field
- Use `npm pack --dry-run` to verify

**TypeScript Errors:**
```bash
npm run typecheck
# Fix errors in src/ files
```

## üìÅ Directory Structure

```
project-fusion/
‚îú‚îÄ‚îÄ src/                    # TypeScript source
‚îÇ   ‚îú‚îÄ‚îÄ cli.ts             # CLI entry point
‚îÇ   ‚îú‚îÄ‚îÄ clicommands.ts     # Command implementations
‚îÇ   ‚îú‚îÄ‚îÄ fusion.ts          # Core fusion logic
‚îÇ   ‚îú‚îÄ‚îÄ types.ts           # Type definitions
‚îÇ   ‚îú‚îÄ‚îÄ schema.ts          # Zod schemas
‚îÇ   ‚îú‚îÄ‚îÄ utils.ts           # Utilities
‚îÇ   ‚îî‚îÄ‚îÄ index.ts           # Main exports
‚îú‚îÄ‚îÄ dist/                  # Compiled JavaScript (gitignored)
‚îú‚îÄ‚îÄ temp/                  # Testing directory (gitignored)
‚îú‚îÄ‚îÄ CLAUDE.md              # AI context (essential info)
‚îú‚îÄ‚îÄ DEVELOPMENT.md         # This file (human development)
‚îú‚îÄ‚îÄ package.json           # NPM configuration
‚îî‚îÄ‚îÄ tsconfig.json          # TypeScript configuration
```

## üîó Important Files

- **CLAUDE.md** - Essential project context for AI assistance
- **package.json** - NPM package configuration and scripts
- **tsconfig.json** - TypeScript compilation settings
- **.gitignore** - Git ignore patterns (includes `temp/`)
- **.vscode/launch.json** - VS Code debugging/testing configurations</code></pre>
    </div>

    <div class="file-section" id="eslint-config-js">
        <div class="file-title">
            <h2>üìÑ eslint.config.js</h2>
        </div>
        <pre><code class="javascript">import js from &#39;@eslint/js&#39;;
import tseslint from &#39;@typescript-eslint/eslint-plugin&#39;;
import tsparser from &#39;@typescript-eslint/parser&#39;;
import importPlugin from &#39;eslint-plugin-import&#39;;
import unicorn from &#39;eslint-plugin-unicorn&#39;;

export default [
  js.configs.recommended,
  {
    files: [&#39;src/**/*.ts&#39;],
    languageOptions: {
      parser: tsparser,
      parserOptions: {
        ecmaVersion: 2022,
        sourceType: &#39;module&#39;,
        project: &#39;./tsconfig.json&#39;
      },
      globals: {
        console: &#39;readonly&#39;,
        process: &#39;readonly&#39;,
        Buffer: &#39;readonly&#39;,
        __dirname: &#39;readonly&#39;,
        __filename: &#39;readonly&#39;,
        NodeJS: &#39;readonly&#39;
      }
    },
    plugins: {
      &#39;@typescript-eslint&#39;: tseslint,
      &#39;import&#39;: importPlugin,
      &#39;unicorn&#39;: unicorn
    },
    rules: {
      // TypeScript strict rules
      &#39;@typescript-eslint/no-explicit-any&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/no-unused-vars&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/prefer-readonly&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/explicit-function-return-type&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/explicit-module-boundary-types&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/no-inferrable-types&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/no-unnecessary-type-assertion&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/prefer-nullish-coalescing&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/prefer-optional-chain&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/prefer-string-starts-ends-with&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/prefer-includes&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/no-floating-promises&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/await-thenable&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/no-misused-promises&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/require-await&#39;: &#39;error&#39;,

      // General code quality
      &#39;no-console&#39;: &#39;off&#39;, // CLI app needs console output
      &#39;no-debugger&#39;: &#39;error&#39;,
      &#39;no-alert&#39;: &#39;error&#39;,
      &#39;no-var&#39;: &#39;error&#39;,
      &#39;prefer-const&#39;: &#39;error&#39;,
      &#39;prefer-arrow-callback&#39;: &#39;error&#39;,
      &#39;prefer-template&#39;: &#39;error&#39;,
      &#39;object-shorthand&#39;: &#39;error&#39;,
      &#39;quote-props&#39;: [&#39;error&#39;, &#39;as-needed&#39;],
      &#39;no-duplicate-imports&#39;: &#39;error&#39;,
      
      // Import rules
      &#39;import/order&#39;: [
        &#39;error&#39;,
        {
          &#39;groups&#39;: [
            &#39;builtin&#39;,
            &#39;external&#39;, 
            &#39;internal&#39;,
            &#39;parent&#39;,
            &#39;sibling&#39;,
            &#39;index&#39;
          ],
          &#39;newlines-between&#39;: &#39;never&#39;,
          &#39;alphabetize&#39;: {
            &#39;order&#39;: &#39;asc&#39;,
            &#39;caseInsensitive&#39;: true
          }
        }
      ],
      &#39;import/no-duplicates&#39;: &#39;error&#39;,

      // Unicorn rules for modern JS practices
      &#39;unicorn/prefer-node-protocol&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-module&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-ternary&#39;: &#39;warn&#39;,
      &#39;unicorn/prefer-logical-operator-over-ternary&#39;: &#39;error&#39;,
      &#39;unicorn/no-array-for-each&#39;: &#39;warn&#39;,
      &#39;unicorn/prefer-array-some&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-array-find&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-array-flat&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-object-from-entries&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-set-has&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-string-slice&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-number-properties&#39;: &#39;error&#39;,
      &#39;unicorn/numeric-separators-style&#39;: &#39;error&#39;,
      &#39;unicorn/better-regex&#39;: &#39;error&#39;,
      &#39;unicorn/catch-error-name&#39;: &#39;error&#39;,
      &#39;unicorn/custom-error-definition&#39;: &#39;error&#39;,
      &#39;unicorn/error-message&#39;: &#39;error&#39;,
      &#39;unicorn/escape-case&#39;: &#39;error&#39;,
      &#39;unicorn/explicit-length-check&#39;: &#39;error&#39;,
      &#39;unicorn/filename-case&#39;: [
        &#39;error&#39;,
        {
          &#39;cases&#39;: {
            &#39;camelCase&#39;: true,
            &#39;pascalCase&#39;: true,
            &#39;kebabCase&#39;: true
          }
        }
      ],
      &#39;unicorn/new-for-builtins&#39;: &#39;error&#39;,
      &#39;unicorn/no-abusive-eslint-disable&#39;: &#39;error&#39;,
      &#39;unicorn/no-array-push-push&#39;: &#39;error&#39;,
      &#39;unicorn/no-console-spaces&#39;: &#39;error&#39;,
      &#39;unicorn/no-hex-escape&#39;: &#39;error&#39;,
      &#39;unicorn/no-instanceof-array&#39;: &#39;error&#39;,
      &#39;unicorn/no-new-buffer&#39;: &#39;error&#39;,
      &#39;unicorn/no-unnecessary-await&#39;: &#39;error&#39;,
      &#39;unicorn/no-useless-length-check&#39;: &#39;error&#39;,
      &#39;unicorn/no-useless-spread&#39;: &#39;error&#39;,
      &#39;unicorn/no-zero-fractions&#39;: &#39;error&#39;,
      &#39;unicorn/number-literal-case&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-add-event-listener&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-array-index-of&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-date-now&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-default-parameters&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-includes&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-math-trunc&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-negative-index&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-optional-catch-binding&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-prototype-methods&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-reflect-apply&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-regexp-test&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-spread&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-string-replace-all&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-string-trim-start-end&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-switch&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-type-error&#39;: &#39;error&#39;,
      &#39;unicorn/throw-new-error&#39;: &#39;error&#39;
    }
  },
  {
    files: [&#39;tests/**/*&#39;, &#39;**/*.test.ts&#39;, &#39;**/*.spec.ts&#39;],
    rules: {
      &#39;@typescript-eslint/no-explicit-any&#39;: &#39;off&#39;,
      &#39;@typescript-eslint/explicit-function-return-type&#39;: &#39;off&#39;,
      &#39;no-console&#39;: &#39;off&#39;
    }
  }
];</code></pre>
    </div>

    <div class="file-section" id="package-json">
        <div class="file-title">
            <h2>üìÑ package.json</h2>
        </div>
        <pre><code class="json">{
    &quot;name&quot;: &quot;project-fusion&quot;,
    &quot;version&quot;: &quot;0.0.1&quot;,
    &quot;description&quot;: &quot;CLI tool for merging project files into a single file for easy sharing&quot;,
    &quot;main&quot;: &quot;dist/index.js&quot;,
    &quot;types&quot;: &quot;dist/index.d.ts&quot;,
    &quot;type&quot;: &quot;module&quot;,
    &quot;bin&quot;: {
        &quot;project-fusion&quot;: &quot;dist/cli.js&quot;
    },
    &quot;exports&quot;: {
        &quot;.&quot;: {
            &quot;types&quot;: &quot;./dist/index.d.ts&quot;,
            &quot;import&quot;: &quot;./dist/index.js&quot;
        },
        &quot;./package.json&quot;: &quot;./package.json&quot;
    },
    &quot;files&quot;: [
        &quot;dist/**/*&quot;,
        &quot;README.md&quot;,
        &quot;LICENSE&quot;,
        &quot;CHANGELOG.md&quot;
    ],
    &quot;sideEffects&quot;: false,
    &quot;scripts&quot;: {
        &quot;build&quot;: &quot;tsc&quot;,
        &quot;clean&quot;: &quot;rm -rf dist&quot;,
        &quot;dev&quot;: &quot;tsc --watch&quot;,
        &quot;lint&quot;: &quot;eslint src/**/*.ts&quot;,
        &quot;lint:fix&quot;: &quot;eslint src/**/*.ts --fix&quot;,
        &quot;prepublishOnly&quot;: &quot;npm run clean &amp;&amp; npm run build&quot;,
        &quot;test&quot;: &quot;vitest&quot;,
        &quot;test:coverage&quot;: &quot;vitest run --coverage&quot;,
        &quot;test:ui&quot;: &quot;vitest --ui&quot;,
        &quot;typecheck&quot;: &quot;tsc --noEmit&quot;
    },
    &quot;keywords&quot;: [
        &quot;cli&quot;,
        &quot;code&quot;,
        &quot;collaboration&quot;,
        &quot;files&quot;,
        &quot;fusion&quot;,
        &quot;merge&quot;,
        &quot;sharing&quot;
    ],
    &quot;author&quot;: &quot;the99studio&quot;,
    &quot;license&quot;: &quot;MIT&quot;,
    &quot;engines&quot;: {
        &quot;node&quot;: &quot;&gt;=18.0.0&quot;
    },
    &quot;repository&quot;: {
        &quot;type&quot;: &quot;git&quot;,
        &quot;url&quot;: &quot;https://github.com/the99studio/project-fusion.git&quot;
    },
    &quot;bugs&quot;: {
        &quot;url&quot;: &quot;https://github.com/the99studio/project-fusion/issues&quot;
    },
    &quot;homepage&quot;: &quot;https://github.com/the99studio/project-fusion#readme&quot;,
    &quot;dependencies&quot;: {
        &quot;chalk&quot;: &quot;^5.5.0&quot;,
        &quot;clipboardy&quot;: &quot;^4.0.0&quot;,
        &quot;commander&quot;: &quot;^14.0.0&quot;,
        &quot;fs-extra&quot;: &quot;^11.3.1&quot;,
        &quot;glob&quot;: &quot;^11.0.3&quot;,
        &quot;ignore&quot;: &quot;^7.0.5&quot;,
        &quot;zod&quot;: &quot;^4.0.17&quot;
    },
    &quot;devDependencies&quot;: {
        &quot;@types/fs-extra&quot;: &quot;^11.0.4&quot;,
        &quot;@types/node&quot;: &quot;^24.2.1&quot;,
        &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^8.39.1&quot;,
        &quot;@typescript-eslint/parser&quot;: &quot;^8.39.1&quot;,
        &quot;@vitest/coverage-v8&quot;: &quot;^2.1.9&quot;,
        &quot;eslint&quot;: &quot;^9.33.0&quot;,
        &quot;eslint-plugin-import&quot;: &quot;^2.32.0&quot;,
        &quot;eslint-plugin-node&quot;: &quot;^11.1.0&quot;,
        &quot;eslint-plugin-unicorn&quot;: &quot;^60.0.0&quot;,
        &quot;typescript&quot;: &quot;^5.9.2&quot;,
        &quot;vitest&quot;: &quot;^2.1.6&quot;
    }
}
</code></pre>
    </div>


```

## üìÑ README.md

```markdown
# Project Fusion

Project Fusion enables efficient project file management by merging multiple project files into a single file for easy sharing and collaboration. It generates plain text (.txt), .html and markdown (.md) versions with syntax highlighting for better readability.

## Prerequisites

- **Node.js** version 18.0.0 or higher

## Installation

Install Project Fusion globally with npm:

```bash
npm install -g project-fusion
```

## Quick Start

1. **Initialize** Project Fusion in your project directory if you want to be able to tweak the settings (optional):
   ```bash
   cd your-project-directory
   project-fusion init
   ```

2. **Create fusion files** containing all your project files (if init has not been done, it will use the default behaviour):
   ```bash
   project-fusion
   ```
   This creates two files:
   - `project-fusioned.txt` - Plain text format with clear file separators
   - `project-fusioned.md` - Markdown format with syntax highlighting and table of contents
   - `project-fusioned.html` - Html format with syntax highlighting and table of contents

3. **Share the fusion files** for collaboration or analysis (choose .txt for universal compatibility or .md for enhanced readability)

## Commands

- `project-fusion` - Create fusion files from project files (default action)
- `project-fusion init` - Create Project Fusion setting file (optional) in current directory
- `project-fusion config-check` - Validate configuration and show active settings
- `project-fusion --help` - Show help information

## Documentation

- **[CLAUDE.md](./CLAUDE.md)** - AI context and technical documentation for Claude AI
- **[DEVELOPMENT.md](./DEVELOPMENT.md)** - Development workflows, testing, and npm publication guide
- **[CONTRIBUTING.md](./CONTRIBUTING.md)** - How to contribute to the project
- **[LICENSE](./LICENSE)** - MIT License terms

## Usage Workflow

When sharing your code:

1. Run `project-fusion fusion` to create merged files
2. Choose the appropriate format:
   - **`.txt`** - Universal compatibility with clear HTML-style separators
   - **`.md`** - Enhanced readability with syntax highlighting, clickable table of contents
3. Share the fusion file with colleagues or collaborators
4. Use for code review, AI analysis, documentation, or project overview

The fusion files contain all your project files in a single, organized format that's easy to understand and work with.

## Configuration

Project Fusion creates a `project-fusion.json` configuration file when you run `init`. You can customize:
- File extensions to include (organized by category: web, backend, config, etc.)
- Directories to scan or ignore
- Output file names and locations
- Use of .gitignore patterns
- Clipboard copying behavior

### Supported File Extensions

Project Fusion supports 35+ file extensions organized by category:
- **Web**: .js, .jsx, .ts, .tsx, .html, .css, .vue, .svelte
- **Backend**: .py, .rb, .java, .cs, .go, .rs, .php
- **Config**: .json, .yaml, .yml, .toml, .xml
- **Scripts**: .sh, .bat, .ps1, .cmd
- **C/C++**: .c, .cpp, .h, .hpp
- **Godot**: .gd, .tscn, .tres, .cfg

The markdown output automatically applies appropriate syntax highlighting for each file type.

### HTML Output

Project Fusion can generate beautiful HTML files with:

- **Responsive Design**: Clean, modern styling optimized for viewing and sharing
- **Table of Contents**: Interactive navigation with anchor links to each file
- **Syntax Highlighting**: Code blocks with proper language detection
- **File Metadata**: Timestamps, project info, and file counts in header
- **Professional Layout**: Typography and spacing designed for readability

Enable HTML generation in your config:

```json
{
  "generateHtml": true
}
```

### Performance Features

- **File Size Limiting**: Configure `maxFileSizeKB` to skip large files (default: 1MB)
- **Streaming Support**: Large projects are processed with streaming to minimize memory usage
- **Performance Metrics**: Detailed benchmarks logged including throughput and memory usage
- **Smart Filtering**: Automatically ignores binary files, images, archives, and compiled files

## Distribution

- **GitHub**: [github.com/the99studio/project-fusion](https://github.com/the99studio/project-fusion)
- **NPM**: [npmjs.com/package/project-fusion](https://www.npmjs.com/package/project-fusion)

## License

This project is licensed under the MIT License - see the [LICENSE](./LICENSE) file for details.
```

## üìÑ src/benchmark.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Benchmark utilities for performance monitoring
 */
import { performance } from 'node:perf_hooks';
import process from 'node:process';

export interface BenchmarkMetrics {
    averageFileProcessingTime: number;
    duration: number;
    filesProcessed: number;
    memoryUsed: number;
    throughputMBps: number;
    totalSizeMB: number;
}

export class BenchmarkTracker {
    private readonly startTime: number;
    private readonly startMemory: NodeJS.MemoryUsage;
    private readonly fileTimings: number[] = [];
    private filesProcessed = 0;
    private totalBytes = 0;

    constructor() {
        this.startTime = performance.now();
        this.startMemory = process.memoryUsage();
    }

    /**
     * Record file processing metrics
     */
    markFileProcessed(sizeBytes: number, processingTimeMs?: number): void {
        this.filesProcessed++;
        this.totalBytes += sizeBytes;
        if (processingTimeMs !== undefined) {
            this.fileTimings.push(processingTimeMs);
        }
    }

    /**
     * Calculate and return performance metrics
     */
    getMetrics(): BenchmarkMetrics {
        const endTime = performance.now();
        const endMemory = process.memoryUsage();
        
        const duration = (endTime - this.startTime) / 1000; // seconds
        const memoryUsed = (endMemory.heapUsed - this.startMemory.heapUsed) / (1024 * 1024); // MB
        const totalSizeMB = this.totalBytes / (1024 * 1024);
        
        const averageFileProcessingTime = this.fileTimings.length > 0
            ? this.fileTimings.reduce((a, b) => a + b, 0) / this.fileTimings.length
            : 0;
        
        const throughputMBps = duration > 0 ? totalSizeMB / duration : 0;

        return {
            duration,
            memoryUsed,
            filesProcessed: this.filesProcessed,
            totalSizeMB,
            averageFileProcessingTime,
            throughputMBps
        };
    }

}
```

## üìÑ src/cli.ts

```typescript
#!/usr/bin/env node
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Command-line interface for Project Fusion
 */
import { Command } from 'commander';
import pkg from '../package.json' with { type: 'json' };
import {
    runConfigCheckCommand,
    runFusionCommand,
    runInitCommand
} from './clicommands.js';

const program = new Command();

program
    .name('project-fusion')
    .description('Project Fusion - Efficient project file management and sharing')
    .version(pkg.version, '-v, --version');

// Default command (fusion) - runs when no subcommand is specified
program
    .option('--extensions <groups>', 'Comma-separated list of extension groups (e.g., backend,web)')
    .option('--root <directory>', 'Root directory to start scanning from (defaults to current directory)')
    .action((options) => {
        // Default action is to run fusion
        void runFusionCommand(options);
    });


// Init command
program
    .command('init')
    .description('Initialize Project Fusion in the current directory')
    .option('--force', 'Force initialization even if configuration already exists')
    .action((options) => {
        void runInitCommand(options);
    });

// Config check command
program
    .command('config-check')
    .description('Validate project-fusion.json and display active groups/extensions')
    .action(() => {
        void runConfigCheckCommand();
    });

// Parse arguments with Commander.js
program.parse(process.argv);
```

## üìÑ src/clicommands.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * CLI commands implementation
 */
import path from 'node:path';
import chalk from 'chalk';
import clipboardy from 'clipboardy';
import fs from 'fs-extra';
import { processFusion } from './fusion.js';
import { ConfigSchemaV1 } from './schema.js';
import type { Config, FusionOptions } from './types.js';
import { defaultConfig, getExtensionsFromGroups, loadConfig } from './utils.js';

/**
 * Run the fusion command
 * @param options Command options
 */
export async function runFusionCommand(options: { extensions?: string, root?: string }): Promise<void> {
    try {
        console.log(chalk.blue('üîÑ Starting Fusion Process...'));

        const config = await loadConfig();

        if (options.root) {
            config.rootDirectory = options.root;
            console.log(chalk.yellow(`‚ÑπÔ∏è Using specified directory as root: ${options.root}`));
        }

        // Parse extension groups from command line (comma-separated)
        let extensionGroups: string[] | undefined;
        if (options.extensions) {
            extensionGroups = options.extensions.split(',').map(e => e.trim());
            console.log(chalk.blue(`Using extension groups: ${extensionGroups.join(', ')}`));
        }

        const fusionOptions: FusionOptions = extensionGroups ? { extensionGroups } : {};
        const result = await processFusion(config, fusionOptions);

        if (result.success) {
            console.log(chalk.green(`‚úÖ ${result.message}`));
            console.log(chalk.green(`üìÑ Generated files:`));
            
            if (config.generateText) {
                console.log(chalk.cyan(`   - ${config.generatedFileName}.txt`));
            }
            if (config.generateMarkdown) {
                console.log(chalk.cyan(`   - ${config.generatedFileName}.md`));
            }
            if (config.generateHtml) {
                console.log(chalk.cyan(`   - ${config.generatedFileName}.html`));
            }

            // Copy fusion content to clipboard if enabled (skip in CI/non-interactive environments)
            const isNonInteractive = process.env['CI'] === 'true' || !process.stdout.isTTY;
            if (config.copyToClipboard === true && result.fusionFilePath && !isNonInteractive) {
                try {
                    const fusionContent = await fs.readFile(result.fusionFilePath, 'utf8');
                    await clipboardy.write(fusionContent);
                    console.log(chalk.blue(`üìã Fusion content copied to clipboard`));
                } catch (clipboardError) {
                    console.warn(chalk.yellow(`‚ö†Ô∏è Could not copy to clipboard: ${clipboardError}`));
                }
            } else if (config.copyToClipboard === true && isNonInteractive) {
                console.log(chalk.gray(`üìã Clipboard copy skipped (non-interactive environment)`));
            }

            console.log(chalk.gray(`üìù Log file available at: ${result.logFilePath}`));
        } else {
            console.log(chalk.red(`‚ùå ${result.message}`));
            if (result.logFilePath) {
                console.log(chalk.gray(`üìù Check log file for details: ${result.logFilePath}`));
            }
        }
    } catch (error) {
        console.error(chalk.red(`‚ùå Fusion process failed: ${error}`));
        process.exit(1);
    }
}


/**
 * Run the init command to initialize the config
 */
export async function runInitCommand(options: { force?: boolean } = {}): Promise<void> {
    try {
        console.log(chalk.blue('üîÑ Initializing Project Fusion...'));

        const configPath = path.resolve('./project-fusion.json');
        if (await fs.pathExists(configPath)) {
            if (!options.force) {
                console.log(chalk.yellow('‚ö†Ô∏è project-fusion.json file already exists.'));
                console.log(chalk.yellow('Use --force to override or delete project-fusion.json and run init again.'));
                process.exit(1);
            } else {
                console.log(chalk.yellow('‚ö†Ô∏è Overriding existing configuration file with --force option.'));
            }
        }

        await fs.writeJson(configPath, defaultConfig, { spaces: 4 });

        console.log(chalk.green('‚úÖ Project Fusion initialized successfully!'));
        console.log(chalk.blue('üìÅ Created:'));
        console.log(chalk.cyan('  - ./project-fusion.json'));

        console.log(chalk.blue('\nüìù Next steps:'));
        console.log(chalk.cyan('  1. Review project-fusion.json and adjust as needed'));
        console.log(chalk.cyan('  2. Run fusion: project-fusion'));
    } catch (error) {
        console.error(chalk.red(`‚ùå Initialization failed: ${error}`));
        process.exit(1);
    }
}

/**
 * Run the config-check command to validate configuration
 */
export async function runConfigCheckCommand(): Promise<void> {
    try {
        console.log(chalk.blue('üîç Checking Project Fusion Configuration...'));

        const configPath = path.resolve('./project-fusion.json');
        
        // Verify configuration file exists
        if (!await fs.pathExists(configPath)) {
            console.log(chalk.yellow('‚ö†Ô∏è No project-fusion.json found.'));
            console.log(chalk.cyan('   Using default configuration.'));
            console.log(chalk.gray('   Run "project-fusion init" to create a configuration file.'));
            
            await displayConfigInfo(defaultConfig, true);
            return;
        }

        // Load and parse configuration
        let configContent: string;
        try {
            configContent = await fs.readFile(configPath, 'utf8');
        } catch (error) {
            console.log(chalk.red(`‚ùå Cannot read configuration file: ${error}`));
            process.exit(1);
        }

        let parsedConfig: unknown;
        try {
            parsedConfig = JSON.parse(configContent);
        } catch (error) {
            console.log(chalk.red(`‚ùå Invalid JSON in configuration file: ${error}`));
            process.exit(1);
        }

        // Validate configuration against schema
        const validation = ConfigSchemaV1.safeParse(parsedConfig);
        
        if (!validation.success) {
            console.log(chalk.red('‚ùå Configuration validation failed:'));
            
            // Show detailed validation errors
            // Display detailed validation errors with helpful context
            for (const [index, issue] of validation.error.issues.entries()) {
                const path = issue.path.length > 0 ? issue.path.join('.') : 'root';
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const value = issue.path.reduce((obj: any, key) => obj?.[key], parsedConfig);
                console.log(chalk.red(`   ${index + 1}. Path: ${chalk.yellow(path)}`));
                console.log(chalk.red(`      Error: ${issue.message}`));
                console.log(chalk.red(`      Current value: ${chalk.cyan(JSON.stringify(value))}`));
                if (issue.code === 'invalid_type') {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    console.log(chalk.red(`      Expected: ${chalk.green((issue as any).expected)}, received: ${chalk.magenta((issue as any).received)}`));
                }
            }
            
            console.log(chalk.yellow('\nüí° Suggestions:'));
            console.log(chalk.cyan('   - Check your configuration against the schema'));
            console.log(chalk.cyan('   - Run "project-fusion init --force" to reset to default config'));
            process.exit(1);
        }

        console.log(chalk.green('‚úÖ Configuration is valid!'));
        await displayConfigInfo(validation.data, false);

    } catch (error) {
        console.error(chalk.red(`‚ùå Config check failed: ${error}`));
        process.exit(1);
    }
}

/**
 * Display comprehensive configuration summary with preview
 */
async function displayConfigInfo(config: Config, isDefault: boolean): Promise<void> {
    console.log(chalk.blue('\nüìã Configuration Summary:'));
    
    if (isDefault) {
        console.log(chalk.gray('   (Using default configuration)\n'));
    } else {
        console.log('');
    }

    // Core configuration settings
    console.log(chalk.cyan('üîß Basic Settings:'));
    console.log(`   Schema Version: ${config.schemaVersion}`);
    console.log(`   Root Directory: ${config.rootDirectory}`);
    console.log(`   Scan Subdirectories: ${config.parseSubDirectories ? 'Yes' : 'No'}`);
    console.log(`   Use .gitignore: ${config.useGitIgnoreForExcludes ? 'Yes' : 'No'}`);
    console.log(`   Copy to Clipboard: ${config.copyToClipboard ? 'Yes' : 'No'}`);
    console.log(`   Max File Size: ${config.maxFileSizeKB} KB`);

    // File generation options
    console.log(chalk.cyan('\nüìÑ Output Generation:'));
    console.log(`   Generated File Name: ${config.generatedFileName}`);
    console.log(`   Generate Text: ${config.generateText ? 'Yes' : 'No'}`);
    console.log(`   Generate Markdown: ${config.generateMarkdown ? 'Yes' : 'No'}`);
    console.log(`   Generate HTML: ${config.generateHtml ? 'Yes' : 'No'}`);
    console.log(`   Log File: project-fusion.log`);

    // File type configuration
    console.log(chalk.cyan('\nüìÅ File Extension Groups:'));
    const totalExtensions = getExtensionsFromGroups(config);
    
    for (const [group, extensions] of Object.entries(config.parsedFileExtensions)) {
        if (extensions) {
            console.log(`   ${group}: ${extensions.length} extensions (${extensions.join(', ')})`);
        }
    }
    
    console.log(chalk.gray(`   Total: ${totalExtensions.length} unique extensions`));

    // Pattern exclusions
    console.log(chalk.cyan('\nüö´ Ignore Patterns:'));
    if (config.ignorePatterns.length === 0) {
        console.log('   None defined');
    } else {
        for (const pattern of config.ignorePatterns.slice(0, 10)) {
            console.log(`   ${pattern}`);
        }
        if (config.ignorePatterns.length > 10) {
            console.log(chalk.gray(`   ... and ${config.ignorePatterns.length - 10} more`));
        }
    }

    // Preview matching files using current configuration
    console.log(chalk.cyan('\nüîç File Discovery Preview:'));
    try {
        const { glob } = await import('glob');
        const rootDir = path.resolve(config.rootDirectory);
        
        // Create glob pattern to preview file discovery
        const allExtensionsPattern = totalExtensions.map(ext => ext.startsWith('.') ? ext : `.${ext}`);
        const pattern = config.parseSubDirectories
            ? `${rootDir}/**/*@(${allExtensionsPattern.join('|')})` // Recursive search
            : `${rootDir}/*@(${allExtensionsPattern.join('|')})`; // Root-only search

        const filePaths = await glob(pattern, { 
            nodir: true,
            follow: false
        });

        console.log(`   Pattern: ${pattern}`);
        console.log(`   Files found: ${filePaths.length}`);
        
        if (filePaths.length > 0) {
            console.log(`   Sample files:`);
            for (const file of filePaths.slice(0, 5)) {
                const relativePath = path.relative(rootDir, file);
                console.log(`     ${relativePath}`);
            }
            if (filePaths.length > 5) {
                console.log(chalk.gray(`     ... and ${filePaths.length - 5} more`));
            }
        }
    } catch (error) {
        console.log(chalk.yellow(`   Could not preview files: ${error}`));
    }
}
```

## üìÑ src/fusion.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Fusion functionality - Optimized single-file-in-memory approach
 */
import { createWriteStream } from 'node:fs';
import path from 'node:path';
import fs from 'fs-extra';
import { glob } from 'glob';
import ignoreLib from 'ignore';
import { BenchmarkTracker } from './benchmark.js';
import { createFilePath, type Config, type FusionOptions, type FusionResult } from './types.js';
import {
    ensureDirectoryExists,
    formatLocalTimestamp,
    formatTimestamp,
    getExtensionsFromGroups,
    getMarkdownLanguage,
    logConfigSummary,
    writeLog
} from './utils.js';

/**
 * Process fusion of files - Optimized memory-efficient version
 * @param config Configuration
 * @param options Fusion options
 * @returns Fusion result
 */
export async function processFusion(
    config: Config,
    options: FusionOptions = {}
): Promise<FusionResult> {
    const benchmark = new BenchmarkTracker();
    
    try {
        // Note: parsing properties are now directly in config (flattened structure)
        const logFilePath = createFilePath(path.resolve('project-fusion.log'));
        const fusionFilePath = createFilePath(path.resolve(`${config.generatedFileName}.txt`));
        const mdFilePath = createFilePath(path.resolve(`${config.generatedFileName}.md`));
        const htmlFilePath = createFilePath(path.resolve(`${config.generatedFileName}.html`));
        const startTime = new Date();

        await fs.writeFile(logFilePath, '');
        await logConfigSummary(logFilePath, config);

        const extensions = getExtensionsFromGroups(config, options.extensionGroups);
        console.log(`Processing ${extensions.length} file extensions from ${Object.keys(config.parsedFileExtensions).length} categories`);
        
        if (extensions.length === 0) {
            const message = 'No file extensions to process.';
            await writeLog(logFilePath, `Status: Fusion failed\nReason: ${message}`, true);
            return { success: false, message, logFilePath };
        }

        // Initialize ignore handler for filtering files based on patterns
        const ig = ignoreLib();
        const rootDir = path.resolve(config.rootDirectory);

        // Load ignore patterns from .gitignore and custom config
        if (config.useGitIgnoreForExcludes) {
            const gitIgnorePath = path.join(rootDir, '.gitignore');
            if (await fs.pathExists(gitIgnorePath)) {
                const gitIgnoreContent = await fs.readFile(gitIgnorePath, 'utf8');
                ig.add(gitIgnoreContent);
            }
        }

        if (config.ignorePatterns.length > 0) {
            const patterns = config.ignorePatterns
                .filter(pattern => pattern.trim() !== '' && !pattern.startsWith('#'))
                .join('\n');
            ig.add(patterns);
        }

        // Create file discovery pattern based on extensions and subdirectory settings
        // Build glob pattern for file discovery: ensure extensions start with '.' and handle subdirectory option
        const allExtensionsPattern = extensions.map(ext => ext.startsWith('.') ? ext : `.${ext}`);
        const pattern = config.parseSubDirectories
            ? `${rootDir}/**/*@(${allExtensionsPattern.join('|')})` // Recursive pattern
            : `${rootDir}/*@(${allExtensionsPattern.join('|')})`; // Root-only pattern

        let filePaths = await glob(pattern, { 
            nodir: true,
            follow: false
        });
        const originalFileCount = filePaths.length;
        filePaths = filePaths.filter(file => {
            const relativePath = path.relative(rootDir, file);
            return !ig.ignores(relativePath);
        });
        console.log(`Found ${originalFileCount} files, ${filePaths.length} after filtering (${((originalFileCount - filePaths.length) / originalFileCount * 100).toFixed(1)}% filtered)`);

        if (filePaths.length === 0) {
            const message = 'No files found to process.';
            const endTime = new Date();
            await writeLog(logFilePath, `Status: Fusion failed\nReason: ${message}\nStart time: ${formatTimestamp(startTime)}\nEnd time: ${formatTimestamp(endTime)}\nDuration: ${((endTime.getTime() - startTime.getTime()) / 1000).toFixed(2)}s`, true);
            return { success: false, message, logFilePath };
        }

        // Extract project metadata for the fusion header
        const projectName = path.basename(process.cwd());
        let packageName = "";
        let projectVersion = "";
        const packageJsonPath = path.join(process.cwd(), 'package.json');
        if (await fs.pathExists(packageJsonPath)) {
            try {
                const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));
                if (packageJson.name) {
                    packageName = packageJson.name;
                }
                if (packageJson.version) {
                    projectVersion = packageJson.version;
                }
            } catch (error) {
                console.warn('Error reading package.json:', error);
            }
        }

        // Sort files alphabetically for consistent output across runs
        filePaths.sort((a, b) => path.relative(rootDir, a).localeCompare(path.relative(rootDir, b)));

        // Track extension usage for comprehensive reporting
        const foundExtensions = new Set<string>();
        const otherExtensions = new Set<string>();
        const allFilesPattern = config.parseSubDirectories ? `${rootDir}/**/*.*` : `${rootDir}/*.*`;
        const allFiles = await glob(allFilesPattern, { nodir: true, follow: false });

        const allConfiguredExtensions = Object.values(config.parsedFileExtensions).flat();
        const configuredExtensionSet = new Set(allConfiguredExtensions);
        // Discover unconfigured extensions for comprehensive reporting
        for (const file of allFiles) {
            const relativePath = path.relative(rootDir, file);
            const ext = path.extname(file).toLowerCase();

            // Track extensions found in project but not configured for processing
            if (ext && !ig.ignores(relativePath) && !configuredExtensionSet.has(ext)) {
                otherExtensions.add(ext);
            }
        }

        // Pre-process files: validate sizes and collect metadata
        const maxFileSizeKB = config.maxFileSizeKB;
        const filesToProcess: { path: string; relativePath: string; size: number }[] = [];
        const skippedFiles: string[] = [];
        let skippedCount = 0;
        let totalSizeBytes = 0;

        for (const filePath of filePaths) {
            const relativePath = path.relative(rootDir, filePath);
            const fileExt = path.extname(filePath).toLowerCase();
            foundExtensions.add(fileExt);

            try {
                const stats = await fs.stat(filePath);
                const sizeKB = stats.size / 1024;
                totalSizeBytes += stats.size;

                if (sizeKB > maxFileSizeKB) {
                    skippedCount++;
                    skippedFiles.push(relativePath);
                    await writeLog(logFilePath, `Skipped large file: ${relativePath} (${sizeKB.toFixed(2)} KB)`, true);
                } else {
                    filesToProcess.push({ path: filePath, relativePath, size: stats.size });
                }
            } catch (error) {
                await writeLog(logFilePath, `Error checking file ${filePath}: ${error}`, true);
                console.error(`Error checking file ${filePath}:`, error);
            }
        }

        // Create output directories for enabled formats
        if (config.generateText) await ensureDirectoryExists(path.dirname(fusionFilePath));
        if (config.generateMarkdown) await ensureDirectoryExists(path.dirname(mdFilePath));
        if (config.generateHtml) await ensureDirectoryExists(path.dirname(htmlFilePath));

        // Initialize write streams for concurrent file generation
        const txtStream = config.generateText ? createWriteStream(fusionFilePath) : null;
        const mdStream = config.generateMarkdown ? createWriteStream(mdFilePath) : null;
        const htmlStream = config.generateHtml ? createWriteStream(htmlFilePath) : null;
        

        // Generate format-specific headers with project metadata
        const projectTitle = packageName && packageName.toLowerCase() !== projectName.toLowerCase() 
            ? `${projectName} / ${packageName}` 
            : projectName;
        const versionInfo = projectVersion ? ` v${projectVersion}` : '';
        
        const txtHeader = `# Generated Project Fusion File\n` +
            `# Project: ${projectTitle}${versionInfo}\n` +
            `# Generated: ${formatLocalTimestamp()}\n` +
            `# UTC: ${formatTimestamp()}\n` +
            `# Files: ${filesToProcess.length}\n` +
            `# Generated by: project-fusion\n\n`;

        const mdHeader = `# Generated Project Fusion File\n\n` +
            `**Project:** ${projectTitle}${versionInfo}\n\n` +
            `**Generated:** ${formatLocalTimestamp()}\n\n` +
            `**UTC:** ${formatTimestamp()}\n\n` +
            `**Files:** ${filesToProcess.length}\n\n` +
            `**Generated by:** [project-fusion](https://github.com/the99studio/project-fusion)\n\n` +
            `---\n\n## üìÅ Table of Contents\n\n`;

        const htmlHeader = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Fusion - ${projectTitle}${versionInfo}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { border-bottom: 2px solid #eee; padding-bottom: 20px; margin-bottom: 30px; }
        .file-section { margin-bottom: 40px; border: 1px solid #ddd; border-radius: 8px; padding: 20px; }
        .file-title { background: #f5f5f5; margin: -20px -20px 20px -20px; padding: 15px 20px; border-radius: 8px 8px 0 0; }
        pre { background: #f8f9fa; padding: 15px; border-radius: 6px; overflow-x: auto; }
        code { font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; }
        .toc { background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 30px; }
        .toc ul { margin: 0; padding-left: 20px; }
        .toc a { text-decoration: none; color: #0366d6; }
        .toc a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Generated Project Fusion File</h1>
        <p><strong>Project:</strong> ${projectTitle}${versionInfo}</p>
        <p><strong>Generated:</strong> ${formatLocalTimestamp()}</p>
        <p><strong>UTC:</strong> ${formatTimestamp()}</p>
        <p><strong>Files:</strong> ${filesToProcess.length}</p>
        <p><strong>Generated by:</strong> <a href="https://github.com/the99studio/project-fusion">project-fusion</a></p>
    </div>
    <div class="toc">
        <h2>üìÅ Table of Contents</h2>
        <ul>
${filesToProcess.map(fileInfo => `            <li><a href="#${fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, '-').toLowerCase()}">${fileInfo.relativePath}</a></li>`).join('\n')}
        </ul>
    </div>`;

        if (txtStream) txtStream.write(txtHeader);
        if (mdStream) mdStream.write(mdHeader);
        if (htmlStream) htmlStream.write(htmlHeader);
        
        // Generate table of contents for markdown format
        if (mdStream) {
            for (const fileInfo of filesToProcess) {
                mdStream.write(`- [${fileInfo.relativePath}](#${fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, '-').toLowerCase()})\n`);
            }
            mdStream.write(`\n---\n\n`);
        }

        // Stream-process files to maintain low memory footprint
        let processedCount = 0;
        for (const fileInfo of filesToProcess) {
            try {
                const content = await fs.readFile(fileInfo.path, 'utf8');
                const fileExt = path.extname(fileInfo.path).toLowerCase();
                const basename = path.basename(fileInfo.path);
                const language = getMarkdownLanguage(fileExt || basename);
                // Escape HTML entities for safe HTML output
                const escapedContent = content
                    .replaceAll('&', '&amp;')
                    .replaceAll('<', '&lt;')
                    .replaceAll('>', '&gt;')
                    .replaceAll('"', '&quot;')
                    .replaceAll('\'', '&#39;');
                
                // Generate plain text format with file separators
                if (txtStream) {
                    txtStream.write(`<!-- ============================================================ -->\n`);
                    txtStream.write(`<!-- FILE: ${fileInfo.relativePath.padEnd(54)} -->\n`);
                    txtStream.write(`<!-- ============================================================ -->\n`);
                    txtStream.write(`${content}\n\n`);
                }

                // Generate markdown format with syntax highlighting
                if (mdStream) {
                    mdStream.write(`## üìÑ ${fileInfo.relativePath}\n\n`);
                    mdStream.write(`\`\`\`${language}\n`);
                    mdStream.write(`${content}\n`);
                    mdStream.write(`\`\`\`\n\n`);
                }

                // Generate HTML format with styled code blocks
                if (htmlStream) {
                    // Create URL-safe anchor ID for navigation
                    const fileAnchor = fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, '-').toLowerCase();
                    htmlStream.write(`    <div class="file-section" id="${fileAnchor}">\n`);
                    htmlStream.write(`        <div class="file-title">\n`);
                    htmlStream.write(`            <h2>üìÑ ${fileInfo.relativePath}</h2>\n`);
                    htmlStream.write(`        </div>\n`);
                    htmlStream.write(`        <pre><code class="${language}">${escapedContent}</code></pre>\n`);
                    htmlStream.write(`    </div>\n\n`);
                }

                processedCount++;
                benchmark.markFileProcessed(fileInfo.size);
            } catch (error) {
                await writeLog(logFilePath, `Error processing file ${fileInfo.path}: ${error}`, true);
                console.error(`Error processing file ${fileInfo.path}:`, error);
            }
        }

        // Finalize HTML document structure
        if (htmlStream) {
            htmlStream.write(`</body>\n</html>`);
        }

        // Ensure all streams are properly closed before PDF generation
        if (txtStream) {
            await new Promise<void>((resolve, reject) => {
                txtStream.end((err?: Error | null) => err ? reject(err) : resolve());
            });
        }
        if (mdStream) {
            await new Promise<void>((resolve, reject) => {
                mdStream.end((err?: Error | null) => err ? reject(err) : resolve());
            });
        }
        if (htmlStream) {
            await new Promise<void>((resolve, reject) => {
                htmlStream.end((err?: Error | null) => err ? reject(err) : resolve());
            });
        }


        // Generate detailed completion report with metrics
        const message = `Fusion completed successfully. ${processedCount} files processed${skippedCount > 0 ? `, ${skippedCount} skipped` : ''}.`;
        const endTime = new Date();
        const duration = ((endTime.getTime() - startTime.getTime()) / 1000).toFixed(2);
        const totalSizeMB = (totalSizeBytes / (1024 * 1024)).toFixed(2);
        
        await writeLog(logFilePath, `Status: Fusion completed successfully`, true);
        await writeLog(logFilePath, `Start time: ${formatTimestamp(startTime)}`, true);
        await writeLog(logFilePath, `End time: ${formatTimestamp(endTime)}`, true);
        await writeLog(logFilePath, `Duration: ${duration}s`, true);
        await writeLog(logFilePath, `Total data processed: ${totalSizeMB} MB`, true);
        
        // Include performance benchmarks in log
        const metrics = benchmark.getMetrics();
        await writeLog(logFilePath, `\nPerformance Metrics:`, true);
        await writeLog(logFilePath, `  Memory Used: ${metrics.memoryUsed.toFixed(2)} MB`, true);
        await writeLog(logFilePath, `  Throughput: ${metrics.throughputMBps.toFixed(2)} MB/s`, true);
        await writeLog(logFilePath, `  Files/second: ${(metrics.filesProcessed / metrics.duration).toFixed(2)}`, true);
        
        await writeLog(logFilePath, `Files found: ${originalFileCount}`, true);
        await writeLog(logFilePath, `Files processed successfully: ${processedCount}`, true);
        await writeLog(logFilePath, `Files skipped (too large): ${skippedCount}`, true);
        await writeLog(logFilePath, `Files filtered out: ${originalFileCount - filePaths.length}`, true);
        
        await writeLog(logFilePath, `Max file size limit: ${maxFileSizeKB} KB`, true);
        
        if (skippedFiles.length > 0) {
            await writeLog(logFilePath, `Skipped files:`, true);
            for (const file of skippedFiles.slice(0, 10)) {
                await writeLog(logFilePath, `  ${file}`, true);
            }
            if (skippedFiles.length > 10) {
                await writeLog(logFilePath, `  ... and ${skippedFiles.length - 10} more`, true);
            }
        }
        
        await writeLog(logFilePath, `File extensions actually processed:`, true);
        const foundExtArray = [...foundExtensions].sort();
        for (const ext of foundExtArray) {
            await writeLog(logFilePath, `  ${ext}`, true);
        }
        
        const ignoredExtensions = extensions.filter(ext => ![...foundExtensions].includes(ext));
        if (ignoredExtensions.length > 0) {
            await writeLog(logFilePath, `Configured extensions with no matching files found:`, true);
            for (const ext of ignoredExtensions.sort()) {
                await writeLog(logFilePath, `  ${ext}`, true);
            }
        }
        
        if (otherExtensions.size > 0) {
            await writeLog(logFilePath, `File extensions found in project but not configured for processing:`, true);
            for (const ext of [...otherExtensions].sort()) {
                await writeLog(logFilePath, `  ${ext}`, true);
            }
        }
        
        const generatedFormats = [];
        if (config.generateText) generatedFormats.push('.txt');
        if (config.generateMarkdown) generatedFormats.push('.md');
        if (config.generateHtml) generatedFormats.push('.html');
        
        return {
            success: true,
            message: `${message} Generated formats: ${generatedFormats.join(', ')}.`,
            fusionFilePath: config.generateText ? fusionFilePath : mdFilePath,
            logFilePath
        };
    } catch (error) {
        const errorMessage = `Fusion process failed: ${error}`;
        console.error(errorMessage);

        try {
            const logFilePath = createFilePath(path.resolve('project-fusion.log'));
            const endTime = new Date();
            await writeLog(logFilePath, `Status: Fusion failed due to error\nError details: ${errorMessage}\nEnd time: ${formatTimestamp(endTime)}`, true);

            return {
                success: false,
                message: errorMessage,
                logFilePath,
                error: error as Error
            };
        } catch (logError) {
            console.error('Could not write to log file:', logError);
            return {
                success: false,
                message: errorMessage,
                error: error as Error
            };
        }
    }
}
```

## üìÑ src/index.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Entry point for Project Fusion
 */

export { BenchmarkTracker, type BenchmarkMetrics } from './benchmark.js';
export { processFusion } from './fusion.js';
export * from './schema.js';
export * from './types.js';
export * from './utils.js';

```

## üìÑ src/schema.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Configuration schema definitions for Project Fusion
 */
import { z } from 'zod';

/**
 * File extension groups with support for custom categories
 */
const ParsedFileExtensionsSchema = z.object({
    backend: z.array(z.string()).default([".cs", ".go", ".java", ".php", ".py", ".rb", ".rs"]),
    config: z.array(z.string()).default([".json", ".toml", ".xml", ".yaml", ".yml"]),
    cpp: z.array(z.string()).default([".c", ".cc", ".cpp", ".h", ".hpp"]),
    doc: z.array(z.string()).default([".adoc", ".md", ".rst"]),
    godot: z.array(z.string()).default([".cfg", ".cs", ".gd", ".import", ".tscn", ".tres"]),
    scripts: z.array(z.string()).default([".bat", ".cmd", ".ps1", ".sh"]),
    web: z.array(z.string()).default([".css", ".html", ".js", ".jsx", ".svelte", ".ts", ".tsx", ".vue"]),
}).and(z.record(z.string(), z.array(z.string())));

/**
 * Complete configuration schema for version 1
 */
export const ConfigSchemaV1 = z.object({
    copyToClipboard: z.boolean().default(false),
    generatedFileName: z.string().default("project-fusioned"),
    generateHtml: z.boolean().default(true),
    generateMarkdown: z.boolean().default(true),
    generateText: z.boolean().default(true),
    maxFileSizeKB: z.number().default(1024),
    parseSubDirectories: z.boolean().default(true),
    parsedFileExtensions: ParsedFileExtensionsSchema.default({
        backend: [".cs", ".go", ".java", ".php", ".py", ".rb", ".rs"],
        config: [".json", ".toml", ".xml", ".yaml", ".yml"],
        cpp: [".c", ".cc", ".cpp", ".h", ".hpp"],
        doc: [".adoc", ".md", ".rst"],
        godot: [".cfg", ".cs", ".gd", ".import", ".tscn", ".tres"],
        scripts: [".bat", ".cmd", ".ps1", ".sh"],
        web: [".css", ".html", ".js", ".jsx", ".svelte", ".ts", ".tsx", ".vue"]
    }),
    ignorePatterns: z.array(z.string()).default([
        "project-fusion.json",
        "project-fusion.log",
        "project-fusioned.*",
        "node_modules/",
        "package-lock.json",
        "pnpm-lock.yaml",
        "yarn.lock",
        "dist/",
        "build/",
        "*.min.js",
        "*.min.css",
        ".env",
        ".env.*",
        "*.key",
        "*.pem",
        "**/credentials/*",
        "**/secrets/*",
        "*.log",
        "logs/",
        ".DS_Store",
        "Thumbs.db",
        ".vscode/",
        ".idea/",
        "*.swp",
        "*.swo",
        "*.zip",
        "*.tar",
        "*.tgz",
        "*.gz",
        "*.7z",
        "*.rar",
        "*.png",
        "*.jpg",
        "*.jpeg",
        "*.gif",
        "*.bmp",
        "*.ico",
        "*.svg",
        "*.webp",
        "*.pdf",
        "*.doc",
        "*.docx",
        "*.xls",
        "*.xlsx",
        "*.ppt",
        "*.pptx",
        "*.mp3",
        "*.mp4",
        "*.avi",
        "*.mov",
        "*.wmv",
        "*.flv",
        "*.wav",
        "*.flac",
        "*.unitypackage",
        "*.uasset",
        "*.fbx",
        "*.obj",
        "*.blend",
        "*.exe",
        "*.dll",
        "*.so",
        "*.dylib",
        "*.a",
        "*.o",
        "*.pyc",
        "*.pyo",
        "*.class",
        "*.jar",
        "*.war"
    ]),
    rootDirectory: z.string().default("."),
    schemaVersion: z.literal(1).default(1),
    useGitIgnoreForExcludes: z.boolean().default(true),
});
```

## üìÑ src/types.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Type definitions for the fusion functionality
 */

// Branded types for type-safe handling
export type FilePath = string & { readonly __brand: unique symbol };

export const createFilePath = (path: string): FilePath => {
    if (!path || typeof path !== 'string') {
        throw new FusionError('Invalid file path provided', 'INVALID_PATH', 'error');
    }
    return path as FilePath;
};

// Enhanced error hierarchy with codes and severity
export type FusionErrorCode = 
    | 'INVALID_PATH'
    | 'UNKNOWN_EXTENSION_GROUP';

export type FusionErrorSeverity = 'error' | 'warning' | 'info';

export class FusionError extends Error {
    public readonly code: FusionErrorCode;
    public readonly severity: FusionErrorSeverity;
    public readonly context: Record<string, unknown> | undefined;

    constructor(
        message: string, 
        code: FusionErrorCode, 
        severity: FusionErrorSeverity = 'error',
        context?: Record<string, unknown>
    ) {
        super(message);
        this.name = 'FusionError';
        this.code = code;
        this.severity = severity;
        this.context = context;
    }
}

/**
 * Main configuration interface
 */
export interface Config {
    copyToClipboard: boolean;
    generatedFileName: string;
    generateHtml: boolean;
    generateMarkdown: boolean;
    generateText: boolean;
    ignorePatterns: string[];
    maxFileSizeKB: number;
    parseSubDirectories: boolean;
    parsedFileExtensions: {
        backend?: string[];
        config?: string[];
        cpp?: string[];
        doc?: string[];
        godot?: string[];
        scripts?: string[];
        web?: string[];
        [key: string]: string[] | undefined;
    };
    rootDirectory: string;
    schemaVersion: number;
    useGitIgnoreForExcludes: boolean;
}

/**
 * Information about a file for fusion
 */
export interface FileInfo {
    path: FilePath;
    content: string;
}

/**
 * Options for the fusion process
 */
export interface FusionOptions {
    extensionGroups?: string[];
}

/**
 * Type-safe fusion result with discriminated union for success/failure states
 */
export type FusionResult = 
    | {
        success: true;
        message: string;
        fusionFilePath: FilePath;
        logFilePath: FilePath;
    }
    | {
        success: false;
        message: string;
        logFilePath?: FilePath;
        error?: Error;
    };
```

## üìÑ src/utils.ts

```typescript
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Utilities for Project Fusion
 */
import path from 'node:path';
import fs from 'fs-extra';
import { z } from 'zod';
import { ConfigSchemaV1 } from './schema.js';
import { FusionError, type Config, type FilePath } from './types.js';


/**
 * Default configuration for Project Fusion
 */
export const defaultConfig = {
    copyToClipboard: false,
    generatedFileName: "project-fusioned",
    generateHtml: true,
    generateMarkdown: true,
    generateText: true,
    maxFileSizeKB: 1024,
    parseSubDirectories: true,
    parsedFileExtensions: {
        backend: [".cs", ".go", ".java", ".php", ".py", ".rb", ".rs"] as const,
        config: [".json", ".toml", ".xml", ".yaml", ".yml"] as const,
        cpp: [".c", ".cc", ".cpp", ".h", ".hpp"] as const,
        doc: [".adoc", ".md", ".rst"] as const,
        godot: [".cfg", ".cs", ".gd", ".import", ".tscn", ".tres"] as const,
        scripts: [".bat", ".cmd", ".ps1", ".sh"] as const,
        web: [".css", ".html", ".js", ".jsx", ".svelte", ".ts", ".tsx", ".vue"] as const
    },
    ignorePatterns: [
        "project-fusion.json",
        "project-fusion.log",
        "project-fusioned.*",
        "node_modules/",
        "package-lock.json",
        "pnpm-lock.yaml",
        "yarn.lock",
        "dist/",
        "build/",
        "*.min.js",
        "*.min.css",
        ".env",
        ".env.*",
        "*.key",
        "*.pem",
        "**/credentials/*",
        "**/secrets/*",
        "*.log",
        "logs/",
        ".DS_Store",
        "Thumbs.db",
        ".vscode/",
        ".idea/",
        "*.swp",
        "*.swo",
        // Binary files and archives
        "*.zip",
        "*.tar",
        "*.tgz",
        "*.gz",
        "*.7z",
        "*.rar",
        // Images
        "*.png",
        "*.jpg",
        "*.jpeg",
        "*.gif",
        "*.bmp",
        "*.ico",
        "*.svg",
        "*.webp",
        // Documents
        "*.pdf",
        "*.doc",
        "*.docx",
        "*.xls",
        "*.xlsx",
        "*.ppt",
        "*.pptx",
        // Media
        "*.mp3",
        "*.mp4",
        "*.avi",
        "*.mov",
        "*.wmv",
        "*.flv",
        "*.wav",
        "*.flac",
        // Game engine assets
        "*.unitypackage",
        "*.uasset",
        "*.fbx",
        "*.obj",
        "*.blend",
        // Compiled/Binary
        "*.exe",
        "*.dll",
        "*.so",
        "*.dylib",
        "*.a",
        "*.o",
        "*.pyc",
        "*.pyo",
        "*.class",
        "*.jar",
        "*.war"
    ],
    rootDirectory: ".",
    schemaVersion: 1,
    useGitIgnoreForExcludes: true
} as const satisfies Config;


/**
 * Load and validate configuration with fallback to defaults
 * @returns The loaded configuration or default config if invalid/missing
 */
export async function loadConfig(): Promise<Config> {
    try {
        const configPath = path.resolve('./project-fusion.json');
        
        let configContent: string;
        try {
            configContent = await fs.readFile(configPath, 'utf8');
        } catch {
            return defaultConfig;
        }

        const parsedConfig = JSON.parse(configContent);

        try {
            const validatedConfig = ConfigSchemaV1.parse(parsedConfig);
            return validatedConfig;
        } catch (zodError: unknown) {
            // Graceful degradation with detailed error reporting
            if (zodError instanceof z.ZodError) {
                console.error('Configuration validation failed (will use default config):');
                for (const [index, issue] of zodError.issues.entries()) {
                    const path = issue.path.length > 0 ? issue.path.join('.') : 'root';
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const value = issue.path.reduce((obj: any, key) => obj?.[key], parsedConfig);
                    console.error(`  ${index + 1}. Path: ${path}`);
                    console.error(`     Error: ${issue.message}`);
                    console.error(`     Current value: ${JSON.stringify(value)}`);
                    if (issue.code === 'invalid_type') {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        console.error(`     Expected type: ${(issue as any).expected}, received: ${(issue as any).received}`);
                    }
                }
            } else {
                console.error('Unknown validation error (will use default config):', zodError);
            }
            return defaultConfig;
        }
    } catch (error) {
        const typedError = error instanceof Error ? error : new Error(String(error));

        console.error('Error loading configuration, will use default configuration:', {
            message: typedError.message,
            stack: typedError.stack,
            context: 'loadConfig',
            configPath: path.resolve('./project-fusion.json')
        });

        return defaultConfig;
    }
}

/**
 * Create directory if it doesn't exist
 * @param directory Directory path
 */
export async function ensureDirectoryExists(directory: string): Promise<void> {
    await fs.ensureDir(directory);
}

/**
 * Write content to log file with optional console output
 * @param logFilePath Path to log file
 * @param content Content to log
 * @param append If true, append to existing file
 * @param consoleOutput If true, also display on console
 */
export async function writeLog(
    logFilePath: string,
    content: string,
    append = false,
    consoleOutput = false
): Promise<void> {
    try {
        await ensureDirectoryExists(path.dirname(logFilePath));
        await (append ? fs.appendFile(logFilePath, `${content  }\n`) : fs.writeFile(logFilePath, `${content  }\n`));

        if (consoleOutput) {
            console.log(content);
        }
    } catch (error) {
        console.error('Error writing log:', error);
    }
}


/**
 * Format a timestamp
 * @param date Optional date to format, defaults to current date
 * @returns Formatted timestamp
 */
export function formatTimestamp(date?: Date): string {
    return (date ?? new Date()).toISOString();
}

/**
 * Format a local timestamp for display
 * @param date Optional date to format, defaults to current date
 * @returns Formatted local timestamp
 */
export function formatLocalTimestamp(date?: Date): string {
    const now = date ?? new Date();
    return now.toLocaleString('fr-FR', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        timeZoneName: 'short'
    });
}

/**
 * Read file content
 * @param filePath Path to file
 * @returns File content
 */
export async function readFileContent(filePath: string): Promise<string> {
    try {
        return await fs.readFile(filePath, 'utf8');
    } catch (error) {
        console.error(`Error reading file ${filePath}:`, error);
        throw error;
    }
}

/**
 * Write detailed configuration summary to log for debugging
 * @param logFilePath Path to log file
 * @param config Configuration to log
 */
export async function logConfigSummary(logFilePath: FilePath, config: Config): Promise<void> {
    await writeLog(logFilePath, `Configuration Summary:`, true);
    await writeLog(logFilePath, `  Schema Version: ${config.schemaVersion}`, true);
    await writeLog(logFilePath, `  Root Directory: ${config.rootDirectory}`, true);
    await writeLog(logFilePath, `  Scan Subdirectories: ${config.parseSubDirectories ? 'Yes' : 'No'}`, true);
    await writeLog(logFilePath, `  Use .gitignore: ${config.useGitIgnoreForExcludes ? 'Yes' : 'No'}`, true);
    await writeLog(logFilePath, `  Copy to Clipboard: ${config.copyToClipboard ? 'Yes' : 'No'}`, true);
    await writeLog(logFilePath, `  Max File Size: ${config.maxFileSizeKB} KB`, true);
    
    // Output files
    await writeLog(logFilePath, `  Generated File Name: ${config.generatedFileName}`, true);
    await writeLog(logFilePath, `  Generate Text: ${config.generateText ? 'Yes' : 'No'}`, true);
    await writeLog(logFilePath, `  Generate Markdown: ${config.generateMarkdown ? 'Yes' : 'No'}`, true);
    await writeLog(logFilePath, `  Generate HTML: ${config.generateHtml ? 'Yes' : 'No'}`, true);
    
    // File type statistics
    const totalExtensions = getExtensionsFromGroups(config);
    await writeLog(logFilePath, `  Extension Groups: ${Object.keys(config.parsedFileExtensions).length} groups`, true);
    await writeLog(logFilePath, `  Total Extensions: ${totalExtensions.length}`, true);
    
    // Exclusion pattern count
    await writeLog(logFilePath, `  Ignore Patterns: ${config.ignorePatterns.length} patterns`, true);
    
    await writeLog(logFilePath, ``, true); // Empty line for separation
}

/**
 * Write content to file
 * @param filePath Path to file
 * @param content Content to write
 */
export async function writeFileContent(filePath: string, content: string): Promise<void> {
    try {
        await ensureDirectoryExists(path.dirname(filePath));
        await fs.writeFile(filePath, content);
    } catch (error) {
        console.error(`Error writing file ${filePath}:`, error);
        throw error;
    }
}

/**
 * Extract file extensions from configuration groups
 * @param config Config object
 * @param groups Extension groups to include (all if undefined)
 * @returns Array of file extensions
 */
export function getExtensionsFromGroups(
    config: Config,
    groups?: string[]
): string[] {
    // Return all extensions if no specific groups requested
    if (!groups || groups.length === 0) {
        return Object.values(config.parsedFileExtensions)
            .filter((extensions): extensions is string[] => Boolean(extensions))
            .flat();
    }

    // Collect extensions from specified groups with validation
    return groups.reduce((acc: string[], group: string) => {
        const extensions = config.parsedFileExtensions[group];
        if (extensions) {
            acc.push(...extensions);
        } else {
            throw new FusionError(
                `Extension group '${group}' not found in config`, 
                'UNKNOWN_EXTENSION_GROUP', 
                'warning',
                { group, availableGroups: Object.keys(config.parsedFileExtensions) }
            );
        }
        return acc;
    }, []);
}

/**
 * Map file extensions to syntax highlighting languages for markdown/HTML
 * @param extensionOrBasename File extension or special basename
 * @returns Language identifier for syntax highlighting
 */
export function getMarkdownLanguage(extensionOrBasename: string): string {
    // Comprehensive mapping for syntax highlighting across multiple formats
    const languageMap: Record<string, string> = {
        // Backend (alphabetized)
        '.cs': 'csharp',
        '.go': 'go',
        '.java': 'java',
        '.kt': 'kotlin',
        '.lua': 'lua',
        '.perl': 'perl',
        '.php': 'php',
        '.pl': 'perl',
        '.py': 'python',
        '.r': 'r',
        '.rb': 'ruby',
        '.rs': 'rust',
        '.scala': 'scala',
        '.swift': 'swift',
        
        // C/C++ (alphabetized)
        '.c': 'c',
        '.cc': 'cpp',
        '.cpp': 'cpp',
        '.cxx': 'cpp',
        '.h': 'c',
        '.hpp': 'cpp',
        '.hxx': 'cpp',
        
        // Config (alphabetized)
        '.env': 'bash',
        '.ini': 'ini',
        '.json': 'json',
        '.toml': 'toml',
        '.xml': 'xml',
        '.yaml': 'yaml',
        '.yml': 'yaml',
        
        // Database
        '.sql': 'sql',
        
        // Documentation (alphabetized)
        '.md': 'markdown',
        '.mdx': 'markdown',
        '.rst': 'rst',
        '.tex': 'latex',
        
        // Godot (alphabetized)
        '.cfg': 'ini',
        '.gd': 'gdscript',
        '.import': 'ini',
        '.tres': 'gdscript',
        '.tscn': 'gdscript',
        
        // Other (alphabetized)
        '.cmake': 'cmake',
        '.dockerfile': 'dockerfile',
        '.Dockerfile': 'dockerfile',
        '.gql': 'graphql',
        '.gradle': 'gradle',
        '.graphql': 'graphql',
        '.makefile': 'makefile',
        '.Makefile': 'makefile',
        '.proto': 'protobuf',
        
        // Shell/Scripts (alphabetized)
        '.bash': 'bash',
        '.bat': 'batch',
        '.cmd': 'batch',
        '.fish': 'bash',
        '.ps1': 'powershell',
        '.sh': 'bash',
        '.zsh': 'bash',
        
        // Web (alphabetized)
        '.css': 'css',
        '.html': 'html',
        '.js': 'javascript',
        '.jsx': 'jsx',
        '.less': 'less',
        '.sass': 'sass',
        '.scss': 'scss',
        '.svelte': 'svelte',
        '.ts': 'typescript',
        '.tsx': 'tsx',
        '.vue': 'vue',
        
        // Files without extensions (alphabetized by basename)
        '.gitattributes': 'text',
        '.gitignore': 'text',
        '.htaccess': 'apache',
        'Cargo.lock': 'toml',
        'Cargo.toml': 'toml',
        'CMakeLists.txt': 'cmake',
        dockerfile: 'dockerfile',
        Dockerfile: 'dockerfile',
        Gemfile: 'ruby',
        'go.mod': 'go',
        'go.sum': 'text',
        Jenkinsfile: 'groovy',
        makefile: 'makefile',
        Makefile: 'makefile',
        'nginx.conf': 'nginx',
        Rakefile: 'ruby',
        'requirements.txt': 'text',
        Vagrantfile: 'ruby',
    };
    
    // Case-insensitive lookup with fallback to 'text'
    const lang = languageMap[extensionOrBasename.toLowerCase()] ?? languageMap[extensionOrBasename];
    return lang ?? 'text';
}
```

## üìÑ tests/formats.test.ts

```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs-extra';
import path from 'path';
import { processFusion } from '../src/fusion.js';
import { Config } from '../src/types.js';

// Test configuration for multiple output formats
const testConfig: Config = {
  schemaVersion: 1,
  generatedFileName: 'test-output',
  copyToClipboard: false,
  generateText: true,
  generateMarkdown: true,
  generateHtml: true,
  parsedFileExtensions: {
    web: ['.js', '.ts'],
    doc: ['.md']
  },
  parseSubDirectories: false,
  rootDirectory: '.',
  maxFileSizeKB: 1024,
  ignorePatterns: [],
  useGitIgnoreForExcludes: false
};

const testDir = path.resolve('./temp/test-formats');
const originalCwd = process.cwd();

describe('Multiple Format Generation', () => {
  beforeEach(async () => {
    await fs.ensureDir(testDir);
    process.chdir(testDir);
    
    // Create test files
    await fs.writeFile(path.join(testDir, 'test.js'), `
console.log('Hello World');
function greet(name) {
  return \`Hello, \${name}!\`;
}
export { greet };
    `.trim());

    await fs.writeFile(path.join(testDir, 'README.md'), `
# Test Project

This is a **test** project with _markdown_ content.

## Features
- Feature 1
- Feature 2
    `.trim());
  });

  afterEach(async () => {
    process.chdir(originalCwd);
    await fs.remove(testDir);
  });

  it('should generate text format when enabled', async () => {
    const config = { ...testConfig, generateText: true, generateMarkdown: false, generateHtml: false };
    const result = await processFusion(config);
    
    expect(result.success).toBe(true);
    expect(await fs.pathExists('test-output.txt')).toBe(true);
    expect(await fs.pathExists('test-output.md')).toBe(false);
    expect(await fs.pathExists('test-output.html')).toBe(false);
  });

  it('should generate markdown format when enabled', async () => {
    const config = { ...testConfig, generateText: false, generateMarkdown: true, generateHtml: false };
    const result = await processFusion(config);
    
    expect(result.success).toBe(true);
    expect(await fs.pathExists('test-output.txt')).toBe(false);
    expect(await fs.pathExists('test-output.md')).toBe(true);
    expect(await fs.pathExists('test-output.html')).toBe(false);
  });

  it('should generate HTML format when enabled', async () => {
    const config = { ...testConfig, generateText: false, generateMarkdown: false, generateHtml: true };
    const result = await processFusion(config);
    
    expect(result.success).toBe(true);
    expect(await fs.pathExists('test-output.txt')).toBe(false);
    expect(await fs.pathExists('test-output.md')).toBe(false);
    expect(await fs.pathExists('test-output.html')).toBe(true);
  });

  it('should generate multiple formats when enabled', async () => {
    const result = await processFusion(testConfig);
    
    expect(result.success).toBe(true);
    expect(await fs.pathExists('test-output.txt')).toBe(true);
    expect(await fs.pathExists('test-output.md')).toBe(true);
    expect(await fs.pathExists('test-output.html')).toBe(true);
  });

  it('should include proper HTML structure', async () => {
    const result = await processFusion(testConfig);
    
    expect(result.success).toBe(true);
    const htmlContent = await fs.readFile('test-output.html', 'utf8');
    
    expect(htmlContent).toContain('<!DOCTYPE html>');
    expect(htmlContent).toContain('<html lang="en">');
    expect(htmlContent).toContain('<title>Project Fusion - test-formats</title>');
    expect(htmlContent).toContain('üìÅ Table of Contents');
    expect(htmlContent).toContain('üìÑ test.js');
    expect(htmlContent).toContain('üìÑ README.md');
    expect(htmlContent).toContain('</body>');
    expect(htmlContent).toContain('</html>');
  });

  it('should escape HTML in code content', async () => {
    // Add a file with HTML-like content
    await fs.writeFile('html-test.js', `
const html = '<div>Hello & <span>World</span></div>';
console.log(html);
    `.trim());

    const result = await processFusion(testConfig);
    
    expect(result.success).toBe(true);
    const htmlContent = await fs.readFile('test-output.html', 'utf8');
    
    expect(htmlContent).toContain('&lt;div&gt;Hello &amp; &lt;span&gt;World&lt;/span&gt;&lt;/div&gt;');
  });


  it('should include proper metadata in generated files', async () => {
    // Create a package.json with version info
    await fs.writeFile('package.json', JSON.stringify({
      name: 'test-package',
      version: '1.0.0'
    }, null, 2));

    const configWithPackage = {
      ...testConfig,
      parsedFileExtensions: { ...testConfig.parsedFileExtensions, config: ['.json'] }
    };

    const result = await processFusion(configWithPackage);
    
    expect(result.success).toBe(true);
    const txtContent = await fs.readFile('test-output.txt', 'utf8');
    const mdContent = await fs.readFile('test-output.md', 'utf8');
    
    expect(txtContent).toContain('# Generated Project Fusion File');
    expect(txtContent).toContain('# Project: test-formats / test-package v1.0.0');
    expect(txtContent).toContain('# Generated by: project-fusion');
    
    expect(mdContent).toContain('# Generated Project Fusion File');
    expect(mdContent).toContain('**Project:** test-formats / test-package v1.0.0');
    expect(mdContent).toContain('[project-fusion](https://github.com/the99studio/project-fusion)');
  });
});
```

## üìÑ tests/integration.test.ts

```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs-extra';
import path from 'path';
import { processFusion } from '../src/fusion.js';
import { defaultConfig } from '../src/utils.js';
import { Config } from '../src/types.js';

describe('integration', () => {
  const testDir = path.join(process.cwd(), 'temp', 'test-integration');
  const originalCwd = process.cwd();

  beforeEach(async () => {
    // Clean up and create test directory
    await fs.remove(testDir);
    await fs.ensureDir(testDir);
    
    // Change to test directory
    process.chdir(testDir);
  });

  afterEach(async () => {
    // Restore original directory
    process.chdir(originalCwd);
    
    // Clean up test directory
    await fs.remove(testDir);
  });

  describe('processFusion', () => {
    it('should process fusion successfully with test files', async () => {
      // Create test files
      await fs.writeFile('test.js', 'console.log("Hello World");');
      await fs.writeFile('test.ts', 'const message: string = "TypeScript";');
      await fs.writeFile('Dockerfile', 'FROM node:18\nCOPY . .\nRUN npm install');
      
      // Create config for test
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        parsedFileExtensions: {
          web: ['.js', '.ts']
        }
      };

      const result = await processFusion(testConfig);

      expect(result.success).toBe(true);
      expect(result.message).toContain('2 files processed');
      expect(result.fusionFilePath).toBeDefined();
      
      // Check if fusion files were created
      expect(await fs.pathExists(result.fusionFilePath!)).toBe(true);
      expect(await fs.pathExists(result.fusionFilePath!.replace('.txt', '.md'))).toBe(true);
      
      // Check content of fusion file
      const fusionContent = await fs.readFile(result.fusionFilePath!, 'utf8');
      expect(fusionContent).toContain('test.js');
      expect(fusionContent).toContain('test.ts');
      expect(fusionContent).toContain('console.log("Hello World");');
      expect(fusionContent).toContain('const message: string = "TypeScript";');
      expect(fusionContent).not.toContain('Dockerfile'); // Not in web extensions
    });

    it('should handle empty directory gracefully', async () => {
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false
      };

      const result = await processFusion(testConfig);

      expect(result.success).toBe(false);
      expect(result.message).toContain('No files found to process');
    });

    it('should respect ignore patterns', async () => {
      // Create test files
      await fs.writeFile('test.js', 'console.log("Hello World");');
      await fs.writeFile('ignored.js', 'console.log("Should be ignored");');
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        parsedFileExtensions: {
          web: ['.js']
        },
        ignorePatterns: ['ignored.js']
      };

      const result = await processFusion(testConfig);

      expect(result.success).toBe(true);
      expect(result.message).toContain('1 files processed'); // Only test.js
      
      const fusionContent = await fs.readFile(result.fusionFilePath!, 'utf8');
      expect(fusionContent).toContain('test.js');
      expect(fusionContent).not.toContain('ignored.js');
    });

    it('should filter files by extensions correctly', async () => {
      // Create test files with different extensions
      await fs.writeFile('app.js', 'console.log("JavaScript");');
      await fs.writeFile('app.ts', 'const app: string = "TypeScript";');
      await fs.writeFile('app.py', 'print("Python")');
      await fs.writeFile('config.json', '{"test": true}');
      
      // Test web extensions only
      const webConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        parsedFileExtensions: {
          web: ['.js', '.ts']
        }
      };

      const webResult = await processFusion(webConfig);
      expect(webResult.success).toBe(true);
      expect(webResult.message).toContain('2 files processed');
      
      const webContent = await fs.readFile(webResult.fusionFilePath!, 'utf8');
      expect(webContent).toContain('app.js');
      expect(webContent).toContain('app.ts');
      expect(webContent).not.toContain('app.py');
      expect(webContent).not.toContain('config.json');

      // Test backend extensions only
      const backendConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        parsedFileExtensions: {
          backend: ['.py']
        }
      };

      const backendResult = await processFusion(backendConfig);
      expect(backendResult.success).toBe(true);
      expect(backendResult.message).toContain('1 files processed');
      
      const backendContent = await fs.readFile(backendResult.fusionFilePath!, 'utf8');
      expect(backendContent).toContain('app.py');
      expect(backendContent).not.toContain('app.js');
      expect(backendContent).not.toContain('app.ts');
    });

    it('should respect .gitignore patterns', async () => {
      // Create test files
      await fs.writeFile('app.js', 'console.log("main app");');
      await fs.writeFile('build.js', 'console.log("build file");');
      await fs.ensureDir('node_modules');
      await fs.writeFile('node_modules/lib.js', 'console.log("dependency");');
      await fs.ensureDir('dist');
      await fs.writeFile('dist/output.js', 'console.log("compiled");');
      
      // Create .gitignore
      await fs.writeFile('.gitignore', 'node_modules/\ndist/\nbuild.js');
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: true,
        useGitIgnoreForExcludes: true,
        parsedFileExtensions: {
          web: ['.js']
        }
      };

      const result = await processFusion(testConfig);
      expect(result.success).toBe(true);
      expect(result.message).toContain('1 files processed'); // Only app.js
      
      const fusionContent = await fs.readFile(result.fusionFilePath!, 'utf8');
      expect(fusionContent).toContain('app.js');
      expect(fusionContent).not.toContain('build.js');
      expect(fusionContent).not.toContain('node_modules');
      expect(fusionContent).not.toContain('dist');
    });

    it('should skip files larger than maxFileSizeKB', async () => {
      // Create small file
      await fs.writeFile('small.js', 'console.log("small");');
      
      // Create large file (2KB)
      const largeContent = 'console.log("large");' + 'x'.repeat(2000);
      await fs.writeFile('large.js', largeContent);
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        maxFileSizeKB: 1, // 1KB limit
        parsedFileExtensions: {
          web: ['.js']
        }
      };

      const result = await processFusion(testConfig);
      expect(result.success).toBe(true);
      expect(result.message).toContain('1 files processed'); // Only small.js
      
      const fusionContent = await fs.readFile(result.fusionFilePath!, 'utf8');
      expect(fusionContent).toContain('small.js');
      expect(fusionContent).not.toContain('large.js');
    });

    it('should respect non-recursive directory parsing', async () => {
      // Create files in root
      await fs.writeFile('root.js', 'console.log("root");');
      
      // Create files in subdirectory
      await fs.ensureDir('sub');
      await fs.writeFile('sub/nested.js', 'console.log("nested");');
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false, // Non-recursive
        parsedFileExtensions: {
          web: ['.js']
        }
      };

      const result = await processFusion(testConfig);
      expect(result.success).toBe(true);
      expect(result.message).toContain('1 files processed'); // Only root.js
      
      const fusionContent = await fs.readFile(result.fusionFilePath!, 'utf8');
      expect(fusionContent).toContain('root.js');
      expect(fusionContent).not.toContain('nested.js');
    });

    it('should generate HTML output when enabled', async () => {
      // Create test files
      await fs.writeFile('test.js', 'console.log("Hello HTML");');
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        generateHtml: true,
        parsedFileExtensions: {
          web: ['.js']
        }
      };

      const result = await processFusion(testConfig);
      expect(result.success).toBe(true);
      
      // Check HTML file was created
      const htmlPath = result.fusionFilePath!.replace('.txt', '.html');
      expect(await fs.pathExists(htmlPath)).toBe(true);
      
      const htmlContent = await fs.readFile(htmlPath, 'utf8');
      expect(htmlContent).toContain('<!DOCTYPE html>');
      expect(htmlContent).toContain('<html lang="en">');
      expect(htmlContent).toContain('test.js');
      expect(htmlContent).toContain('console.log(&quot;Hello HTML&quot;);');
    });
  });
});
```

## üìÑ tests/schema.test.ts

```typescript
import { describe, it, expect } from 'vitest';
import { ConfigSchemaV1 } from '../src/schema.js';
import { defaultConfig } from '../src/utils.js';

describe('schema', () => {
  describe('ConfigSchemaV1', () => {
    it('should validate default config', () => {
      const result = ConfigSchemaV1.safeParse(defaultConfig);
      expect(result.success).toBe(true);
    });

    it('should validate minimal valid config', () => {
      const minimalConfig = {
        schemaVersion: 1,
        generatedFileName: "test-fusion",
        copyToClipboard: false,
        generateText: true,
        generateMarkdown: true,
        generateHtml: false,
        parsedFileExtensions: {
          web: [".js", ".ts"]
        },
        rootDirectory: ".",
        parseSubDirectories: true,
        maxFileSizeKB: 1024,
        ignorePatterns: [],
        useGitIgnoreForExcludes: true
      };

      const result = ConfigSchemaV1.safeParse(minimalConfig);
      expect(result.success).toBe(true);
    });

    it('should reject config with invalid schema version', () => {
      const invalidConfig = {
        ...defaultConfig,
        schemaVersion: 2
      };

      const result = ConfigSchemaV1.safeParse(invalidConfig);
      expect(result.success).toBe(false);
    });

    it('should reject config with missing required fields', () => {
      const invalidConfig = {
        schemaVersion: 1
        // All other fields have defaults, so this should actually pass
      };

      const result = ConfigSchemaV1.safeParse(invalidConfig);
      expect(result.success).toBe(true); // Schema has defaults for all fields
    });

    it('should reject config with invalid copyToClipboard type', () => {
      const invalidConfig = {
        ...defaultConfig,
        copyToClipboard: "true" // Should be boolean
      };

      const result = ConfigSchemaV1.safeParse(invalidConfig);
      expect(result.success).toBe(false);
    });

    it('should validate config with copyToClipboard true', () => {
      const validConfig = {
        ...defaultConfig,
        copyToClipboard: true
      };

      const result = ConfigSchemaV1.safeParse(validConfig);
      expect(result.success).toBe(true);
    });

    it('should validate config with HTML generation enabled', () => {
      const validConfig = {
        ...defaultConfig,
        generateHtml: true
      };

      const result = ConfigSchemaV1.safeParse(validConfig);
      expect(result.success).toBe(true);
    });

    it('should validate config with HTML generation enabled', () => {
      const validConfig = {
        ...defaultConfig,
        generateHtml: true
      };

      const result = ConfigSchemaV1.safeParse(validConfig);
      expect(result.success).toBe(true);
    });
  });
});
```

## üìÑ tests/utils.test.ts

```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs-extra';
import path from 'path';
import { 
  getMarkdownLanguage, 
  getExtensionsFromGroups, 
  formatTimestamp,
  formatLocalTimestamp,
  loadConfig,
  writeLog,
  ensureDirectoryExists,
  writeFileContent,
  readFileContent
} from '../src/utils.js';
import { defaultConfig } from '../src/utils.js';

describe('utils', () => {
  describe('getMarkdownLanguage', () => {
    it('should return correct language for file extensions', () => {
      expect(getMarkdownLanguage('.ts')).toBe('typescript');
      expect(getMarkdownLanguage('.js')).toBe('javascript');
      expect(getMarkdownLanguage('.py')).toBe('python');
      expect(getMarkdownLanguage('.json')).toBe('json');
    });

    it('should return correct language for files without extensions', () => {
      expect(getMarkdownLanguage('Dockerfile')).toBe('dockerfile');
      expect(getMarkdownLanguage('Makefile')).toBe('makefile');
      expect(getMarkdownLanguage('Jenkinsfile')).toBe('groovy');
    });

    it('should return text for unknown extensions', () => {
      expect(getMarkdownLanguage('.unknown')).toBe('text');
      expect(getMarkdownLanguage('UnknownFile')).toBe('text');
    });

    it('should handle case insensitive extensions', () => {
      expect(getMarkdownLanguage('.TS')).toBe('typescript');
      expect(getMarkdownLanguage('.JS')).toBe('javascript');
    });
  });

  describe('getExtensionsFromGroups', () => {
    it('should return all extensions when no groups specified', () => {
      const extensions = getExtensionsFromGroups(defaultConfig);
      expect(extensions.length).toBeGreaterThan(0);
      expect(extensions).toContain('.js');
      expect(extensions).toContain('.py');
      expect(extensions).toContain('.json');
    });

    it('should return extensions for specific groups', () => {
      const extensions = getExtensionsFromGroups(defaultConfig, ['web']);
      expect(extensions).toContain('.js');
      expect(extensions).toContain('.ts');
      expect(extensions).toContain('.html');
      expect(extensions).not.toContain('.py');
    });

    it('should return extensions for multiple groups', () => {
      const extensions = getExtensionsFromGroups(defaultConfig, ['web', 'backend']);
      expect(extensions).toContain('.js');
      expect(extensions).toContain('.py');
      expect(extensions).toContain('.go');
    });

    it('should handle unknown groups gracefully', () => {
      expect(() => {
        getExtensionsFromGroups(defaultConfig, ['unknown']);
      }).toThrow('Extension group \'unknown\' not found in config');
    });
  });

  describe('formatTimestamp', () => {
    it('should format current date when no date provided', () => {
      const timestamp = formatTimestamp();
      expect(timestamp).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/);
    });

    it('should format provided date', () => {
      const date = new Date('2025-01-01T12:00:00.000Z');
      const timestamp = formatTimestamp(date);
      expect(timestamp).toBe('2025-01-01T12:00:00.000Z');
    });
  });

  describe('formatLocalTimestamp', () => {
    it('should format current date when no date provided', () => {
      const timestamp = formatLocalTimestamp();
      expect(timestamp).toMatch(/^\d{2}\/\d{2}\/\d{4} \d{2}:\d{2}:\d{2}/);
    });

    it('should format provided date', () => {
      const date = new Date('2025-01-01T12:00:00.000Z');
      const timestamp = formatLocalTimestamp(date);
      expect(timestamp).toContain('01/01/2025');
    });
  });

  describe('file operations', () => {
    const testDir = path.resolve('./temp/test-utils');
    const testFile = path.join(testDir, 'test.txt');

    beforeEach(async () => {
      await fs.ensureDir(testDir);
    });

    afterEach(async () => {
      await fs.remove(testDir);
    });

    describe('ensureDirectoryExists', () => {
      it('should create directory if it does not exist', async () => {
        const newDir = path.join(testDir, 'new-dir');
        expect(await fs.pathExists(newDir)).toBe(false);
        
        await ensureDirectoryExists(newDir);
        expect(await fs.pathExists(newDir)).toBe(true);
      });

      it('should not fail if directory already exists', async () => {
        await ensureDirectoryExists(testDir);
        // Should not throw
        await ensureDirectoryExists(testDir);
        expect(await fs.pathExists(testDir)).toBe(true);
      });
    });

    describe('writeFileContent', () => {
      it('should write content to file', async () => {
        const content = 'Hello World!';
        await writeFileContent(testFile, content);
        
        expect(await fs.pathExists(testFile)).toBe(true);
        const readContent = await fs.readFile(testFile, 'utf8');
        expect(readContent).toBe(content);
      });

      it('should create directory if it does not exist', async () => {
        const nestedFile = path.join(testDir, 'nested', 'deep', 'file.txt');
        const content = 'Nested content';
        
        await writeFileContent(nestedFile, content);
        expect(await fs.pathExists(nestedFile)).toBe(true);
        const readContent = await fs.readFile(nestedFile, 'utf8');
        expect(readContent).toBe(content);
      });
    });

    describe('readFileContent', () => {
      it('should read file content', async () => {
        const content = 'Test content';
        await fs.writeFile(testFile, content);
        
        const readContent = await readFileContent(testFile);
        expect(readContent).toBe(content);
      });

      it('should throw error for non-existent file', async () => {
        const nonExistentFile = path.join(testDir, 'does-not-exist.txt');
        await expect(readFileContent(nonExistentFile)).rejects.toThrow();
      });
    });

    describe('writeLog', () => {
      it('should write log content to file', async () => {
        const logFile = path.join(testDir, 'test.log');
        const logContent = 'Log entry';
        
        await writeLog(logFile, logContent);
        expect(await fs.pathExists(logFile)).toBe(true);
        const content = await fs.readFile(logFile, 'utf8');
        expect(content).toBe(logContent + '\n');
      });

      it('should append log content when append is true', async () => {
        const logFile = path.join(testDir, 'test.log');
        const firstEntry = 'First entry';
        const secondEntry = 'Second entry';
        
        await writeLog(logFile, firstEntry);
        await writeLog(logFile, secondEntry, true);
        
        const content = await fs.readFile(logFile, 'utf8');
        expect(content).toBe(firstEntry + '\n' + secondEntry + '\n');
      });

      it('should overwrite log content when append is false', async () => {
        const logFile = path.join(testDir, 'test.log');
        const firstEntry = 'First entry';
        const secondEntry = 'Second entry';
        
        await writeLog(logFile, firstEntry);
        await writeLog(logFile, secondEntry, false);
        
        const content = await fs.readFile(logFile, 'utf8');
        expect(content).toBe(secondEntry + '\n');
      });
    });
  });

  describe('loadConfig', () => {
    const testDir = path.resolve('./temp/test-config');
    const configFile = path.join(testDir, 'project-fusion.json');

    beforeEach(async () => {
      await fs.ensureDir(testDir);
      // Set working directory to test directory
      process.chdir(testDir);
    });

    afterEach(async () => {
      // Restore original working directory
      process.chdir(path.resolve('./../../'));
      await fs.remove(testDir);
    });

    it('should return default config when no config file exists', async () => {
      const config = await loadConfig();
      expect(config).toEqual(defaultConfig);
    });

    it('should load valid config from file', async () => {
      const validConfig = {
        schemaVersion: 1,
        generatedFileName: 'custom-fusion',
        copyToClipboard: true,
        generateText: true,
        generateMarkdown: false,
        generateHtml: true,
        parsedFileExtensions: {
          web: ['.js', '.ts']
        },
        parseSubDirectories: false,
        rootDirectory: '.',
        maxFileSizeKB: 512,
        ignorePatterns: ['*.log'],
        useGitIgnoreForExcludes: false
      };

      await fs.writeJson(configFile, validConfig);
      const config = await loadConfig();
      // Config will be merged with defaults, so just check our specific values
      expect(config.schemaVersion).toBe(validConfig.schemaVersion);
      expect(config.generatedFileName).toBe(validConfig.generatedFileName);
      expect(config.copyToClipboard).toBe(validConfig.copyToClipboard);
      expect(config.generateText).toBe(validConfig.generateText);
      expect(config.generateMarkdown).toBe(validConfig.generateMarkdown);
      expect(config.generateHtml).toBe(validConfig.generateHtml);
      expect(config.parsedFileExtensions.web).toEqual(validConfig.parsedFileExtensions.web);
      expect(config.parseSubDirectories).toBe(validConfig.parseSubDirectories);
      expect(config.rootDirectory).toBe(validConfig.rootDirectory);
      expect(config.maxFileSizeKB).toBe(validConfig.maxFileSizeKB);
      expect(config.ignorePatterns).toEqual(validConfig.ignorePatterns);
      expect(config.useGitIgnoreForExcludes).toBe(validConfig.useGitIgnoreForExcludes);
    });

    it('should return default config for invalid JSON', async () => {
      await fs.writeFile(configFile, 'invalid json {');
      const config = await loadConfig();
      expect(config).toEqual(defaultConfig);
    });

    it('should return default config for invalid schema', async () => {
      const invalidConfig = {
        schemaVersion: 'invalid',
        invalidField: true
      };

      await fs.writeJson(configFile, invalidConfig);
      const config = await loadConfig();
      expect(config).toEqual(defaultConfig);
    });
  });
});
```

## üìÑ TODO.md

```markdown
- [ ] Script `npm pack --dry-run` dans DEVELOPMENT.md
- [ ] Script `npm publish --dry-run` 
- [ ] Guide complet de publication
- [ ] Passer en 1.0.0.0
- [ ] Compl√©ter `CHANGELOG.md` (format Keep a Changelog + SemVer)
- [ ] Finaliser le `package.json` (garder la structure moderne avec `exports`)
```

## üìÑ tsconfig.json

```json
{
    "compilerOptions": {
        "target": "ES2022",
        "module": "NodeNext",
        "moduleResolution": "NodeNext",
        "esModuleInterop": true,
        "resolveJsonModule": true,
        "strict": true,
        "declaration": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "noUncheckedIndexedAccess": true,
        "exactOptionalPropertyTypes": true,
        "verbatimModuleSyntax": true,
        "useUnknownInCatchVariables": true,
        "noPropertyAccessFromIndexSignature": true,
        "outDir": "./dist",
        "rootDir": "./src"
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "dist"]
}
```

## üìÑ vitest.config.ts

```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      reportsDirectory: './coverage',
      include: ['src/**/*.ts'],
      exclude: [
        'src/**/*.d.ts',
        'src/cli.ts', // CLI entry point - harder to test
        'node_modules/**'
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      }
    }
  },
});
```

