# Generated Project Fusion File
# Project: project-fusion v1.0.0
# Generated: 17/08/2025 20:35:49 UTC‚àí4
# UTC: 2025-08-18T00:35:49.088Z
# Files: 47
# Generated by: project-fusion

<!-- ============================================================ -->
<!-- FILE: CHANGELOG.md                                           -->
<!-- ============================================================ -->
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [1.0.0] - 2025-01-17

### Initial Release

Project Fusion is a CLI tool that merges multiple project files into a single file for easy sharing and collaboration. This initial release provides multiple output formats.

### Added

#### Core Features
- **Multi-format output generation** - Supports .txt, .md, and .html formats
  - Plain text (.txt) with file separators
  - Markdown (.md) with syntax highlighting and table of contents
  - HTML (.html) with responsive design and navigation
- **Configuration system** with JSON schema validation using Zod
  - Automatic configuration generation with `init` command
  - File extension support (35+ extensions) organized by category
  - Customizable ignore patterns with .gitignore integration
- **CLI interface** built with Commander.js
  - Simple command structure: `project-fusion`, `project-fusion init`, `project-fusion config-check`
  - Command-line options for dynamic configuration overrides
  - Version and help commands

#### File Extension Support (38 extensions)
- **Web Development**: .css, .html, .js, .jsx, .svelte, .ts, .tsx, .vue
- **Backend Languages**: .cs, .go, .java, .php, .py, .rb, .rs  
- **Configuration**: .json, .toml, .xml, .yaml, .yml
- **C/C++**: .c, .cc, .cpp, .h, .hpp
- **Scripts**: .bat, .cmd, .ps1, .sh
- **Godot Engine**: .cfg, .cs, .gd, .import, .tscn, .tres
- **Documentation**: .adoc, .md, .rst

#### Technical Features
- **TypeScript 5.9.2** with strict mode and ESM modules
- **Branded types** (FilePath) for type-safe path handling
- **Discriminated unions** for error handling (FusionResult)
- **Error handling** with FusionError class, error codes, and severity levels
- **Performance metrics** logging
- **Clipboard integration** with automatic fallback for CI environments

#### Testing and Quality
- **Test coverage** with Vitest integration tests
- **ESLint v9** flat configuration
- **SPDX license headers** in all source files
- **Modular architecture** with separation of concerns
- **Error boundaries** and failure handling

#### Configuration Features
- **Schema versioning** for future compatibility
- **Default values** with fallback configuration
- **gitignore integration**
- **Custom ignore patterns** with glob support
- **File size limits** to prevent memory issues
- **Subdirectory parsing** control

### Technical Implementation
- **Architecture** with separation between CLI, fusion logic, and utilities
- **Zod validation** for configuration validation
- **File scanning** with glob patterns and ignore filtering
- **File size limits** configurable per project
- **Cross-platform compatibility** (Windows, macOS, Linux)
- **Node.js 18+** requirement

### Security Features
- **Path traversal protection** - All file paths validated to remain within root directory
- **Symbolic link protection** - Symlinks detected and blocked by default with `follow: false` in glob operations
- **Binary file detection** - Automatic detection and skipping of binary files using null byte and non-printable character analysis
- **XSS prevention** - All HTML output properly escaped to prevent cross-site scripting attacks
- **Safe error handling** - Security-related errors logged without exposing sensitive path information
- **Comprehensive security testing** - 17 security tests covering path traversal, symlink attacks, and binary file handling

### Documentation
- README with quick start guide
- CLAUDE.md for AI context
- DEVELOPMENT.md for contributors
- CONTRIBUTING.md with guidelines
- MIT License

---

[1.0.0]: https://github.com/the99studio/project-fusion/releases/tag/v1.0.0

<!-- ============================================================ -->
<!-- FILE: CLAUDE.md                                              -->
<!-- ============================================================ -->
# Project Fusion - AI Context

> üìñ **For Human Development**: See [DEVELOPMENT.md](./DEVELOPMENT.md) for detailed development workflows, testing procedures, and npm publication guide.

## Project Overview
Project Fusion merges multiple project files into a single file for easy sharing and collaboration.

## Essential Architecture
- **TypeScript 5.9.2** ESM project with strict type checking
- **CLI tool** built with Commander.js that generates .txt, .md, and .html fusion files
- **Configuration-driven** with Zod validation and default fallbacks
- **Multi-format output** with syntax highlighting and filtering

## Core Files Structure
```
src/
‚îú‚îÄ‚îÄ cli.ts              # CLI entry point
‚îú‚îÄ‚îÄ clicommands.ts      # Command implementations  
‚îú‚îÄ‚îÄ fusion.ts           # Core fusion logic
‚îú‚îÄ‚îÄ types.ts            # Type definitions (branded types)
‚îú‚îÄ‚îÄ schema.ts           # Zod validation schemas
‚îú‚îÄ‚îÄ utils.ts            # File operations & utilities
‚îî‚îÄ‚îÄ index.ts            # Main exports
```

## Key Commands
```bash
npm run build           # Build TypeScript ‚Üí JavaScript
npm run typecheck       # Type checking only
project-fusion init     # Initialize config
project-fusion          # Run fusion process
```

## Testing Directory
**‚ö†Ô∏è Important**: All testing and temporary files MUST be created in `temp/` directory at project root. This includes:
- Package testing: `temp/package/`
- File generation tests: `temp/test-files/`
- Any temporary artifacts: `temp/artifacts/`

The `temp/` directory is gitignored and safe for any testing activities.

## Configuration Schema
```typescript
{
  schemaVersion: 1
  copyToClipboard: boolean
  generatedFileName: string
  generateHtml: boolean
  generateMarkdown: boolean
  generateText: boolean
  maxFileSizeKB: number
  parseSubDirectories: boolean
  parsedFileExtensions: {
    web: string[]       // .js, .ts, .tsx, .vue, etc.
    backend: string[]   // .py, .go, .java, .rs, etc. 
    config: string[]    // .json, .yaml, .toml, etc.
    cpp: string[]       // .c, .cpp, .h, .hpp
    scripts: string[]   // .sh, .bat, .ps1
    godot: string[]     // .gd, .tscn, .tres
    doc: string[]       // .md, .rst, .adoc
  }
  rootDirectory: string
  ignorePatterns: string[]
  useGitIgnoreForExcludes: boolean
}
```

## Core Workflow
1. Load `project-fusion.json` config with Zod validation
2. Scan files by extensions, apply .gitignore + custom ignore patterns
3. Generate triple output:
   - `project-fusioned.txt` - Plain text with separators
   - `project-fusioned.md` - Markdown with syntax highlighting + TOC
   - `project-fusioned.html` - HTML with responsive design + interactive TOC

## Key Implementation Details
- **Branded types** (FilePath) prevent string confusion
- **Discriminated unions** (FusionResult) for type-safe error handling  
- **ESM modules** with strict TypeScript
- **Configuration fallbacks** - uses defaults if config missing/invalid

## Quick Reference
- **Add extensions**: Update `src/schema.ts` + `src/utils.ts` default config
- **Add commands**: Register in `src/cli.ts`, implement in `src/clicommands.ts`
- **Modify output**: Edit `src/fusion.ts` processing logic

## Documentation Style Guide
- **Keep it simple and professional**: Avoid superlatives and marketing language
- **Be factual**: Describe features without overselling
- **Use neutral tone**: Focus on functionality rather than promotional phrases
- **No excessive adjectives**: Avoid words like "powerful", "beautiful", "smart", etc.

<!-- ============================================================ -->
<!-- FILE: CONTRIBUTING.md                                        -->
<!-- ============================================================ -->
# Contributing to Project Fusion

Thanks for your interest! This guide explains how to propose changes and report issues.

## Code of Conduct
Be respectful and constructive. By participating, you agree to foster an open and welcoming environment.

## How to contribute
1. **Fork** the repo and create a branch: `feat/<short-name>` or `fix/<short-name>`.
2. See [DEVELOPMENT.md](./DEVELOPMENT.md) for detailed development workflows, testing procedures, and npm publication guide.
3. Open a Pull Request with a clear description and checklist.

## PR checklist
- [ ] Feature/bugfix tested
- [ ] No regressions
- [ ] Docs/README updated if necessary
- [ ] Notable changes added to `CHANGELOG.md`


<!-- ============================================================ -->
<!-- FILE: DEVELOPMENT.md                                         -->
<!-- ============================================================ -->
# Project Fusion - Development Guide

> üìã **For Claude AI Context**: See [CLAUDE.md](./CLAUDE.md) for essential project information needed for development assistance.

## Development Workflow

### Initial Setup
```bash
git clone https://github.com/the99studio/project-fusion.git
cd project-fusion
npm install
npm run build
```

### Claude Code Integration
The project includes `.claude/settings.local.json` which configures Claude Code permissions for smoother development. This file provides:

**Allowed Operations:**
- NPM commands: install, build, typecheck, test, clean, pack
- Project CLI: `project-fusion` and `node dist/cli.js` commands
- Git operations: status, diff, log, branch, add, commit, push, pull
- Safe file operations: Limited to `temp/` directory for rm/cp operations
- Search capabilities: find, grep, rg, ls, cat, head, tail for code exploration
- Package management: npm list, outdated, view

**Security Features:**
- File deletions restricted to `temp/` directory only
- No arbitrary Node.js code execution (only specific CLI commands)
- Explicit deny list for dangerous operations (sudo, eval, etc.)
- No system-wide file modifications allowed

These permissions eliminate repetitive authorization prompts while maintaining security boundaries.

### Testing the CLI
Use VS Code launch configurations (F5) for easy testing:
- **"Fusion (Default)"** - Default behavior (runs fusion)
- **"Fusion (Web)"** - Test web extensions only
- **"Help"** - Test CLI help
- **"Init"** - Test project initialization

### Testing with Real Package
For testing as if it were the real published package, see the [NPM Package Testing](#-npm-package-management) section below.

## NPM Package Management

### Pre-Publication Testing

Use the **"Test NPM Package"** launch configuration in VS Code (F5) which automatically:
- Builds the project
- Creates and extracts test package to `temp/package/`
- Installs dependencies and tests CLI functionality

#### Manual Package Verification
```bash
# Preview what will be published
npm pack --dry-run

# Create test package (if not using VS Code)
npm pack  # Creates project-fusion-x.x.x.tgz
```

#### Testing with Real Package Installation
```bash
# Install the test package globally
npm install -g ./temp/package/ # start line with sudo if you need admin rights

# Test commands (acts like real published package)
project-fusion --help
project-fusion --version
project-fusion init
project-fusion # Default: runs fusion

# Uninstall when done testing
npm uninstall -g project-fusion # start line with sudo if you need admin rights
```

### Publication Process

```bash
# 1. Final verification
npm pack --dry-run

# 2. Simulate publication (verifies authentication, package validity)
npm publish --dry-run

# 3. Create npm account and login (first time only)
# Visit https://www.npmjs.com/signup to create account
npm login

# 4. Publish to npm
npm publish

# 5. Verify publication
npm view project-fusion
```

## üõ†Ô∏è Development Patterns

### Adding New File Extensions
1. Update `src/schema.ts` - add to `ParsedFileExtensionsSchema`
2. Update default config in `src/utils.ts` 
3. Test with various projects

### Adding New CLI Commands
1. Register command in `src/cli.ts` (Commander.js)
2. Implement in `src/clicommands.ts`
3. Update help text and documentation

### Modifying Fusion Output
1. Edit `src/fusion.ts` processing logic
2. Update types in `src/types.ts` if needed
3. Test both .txt and .md output formats

## Testing Strategy

### Manual Testing Checklist
- [ ] `npm run build` - clean build
- [ ] `npm run typecheck` - no type errors
- [ ] CLI help works: `project-fusion --help`
- [ ] Init works: `project-fusion init`
- [ ] Fusion works: `project-fusion`
- [ ] Extension filtering works
- [ ] .gitignore integration works
- [ ] Output files are properly formatted
- [ ] Package builds and installs correctly

### Test Projects
Use these types of projects for testing:
- **Node.js/TypeScript** (like this project)
- **Python projects** (test backend extensions)
- **React/Vue projects** (test web extensions)
- **Mixed projects** (multiple extension types)

## Troubleshooting

### Common Issues

**Build Errors:**
```bash
npm run clean && npm run build
```

**Package Contains Wrong Files:**
- Check `package.json` `files` field
- Use `npm pack --dry-run` to verify

**TypeScript Errors:**
```bash
npm run typecheck
# Fix errors in src/ files
```

## Directory Structure

```
project-fusion/
‚îú‚îÄ‚îÄ src/                    # TypeScript source
‚îÇ   ‚îú‚îÄ‚îÄ cli.ts             # CLI entry point
‚îÇ   ‚îú‚îÄ‚îÄ clicommands.ts     # Command implementations
‚îÇ   ‚îú‚îÄ‚îÄ fusion.ts          # Core fusion logic
‚îÇ   ‚îú‚îÄ‚îÄ types.ts           # Type definitions
‚îÇ   ‚îú‚îÄ‚îÄ schema.ts          # Zod schemas
‚îÇ   ‚îú‚îÄ‚îÄ utils.ts           # Utilities
‚îÇ   ‚îî‚îÄ‚îÄ index.ts           # Main exports
‚îú‚îÄ‚îÄ dist/                  # Compiled JavaScript (gitignored)
‚îú‚îÄ‚îÄ temp/                  # Testing directory (gitignored)
‚îú‚îÄ‚îÄ CLAUDE.md              # AI context (essential info)
‚îú‚îÄ‚îÄ DEVELOPMENT.md         # This file (human development)
‚îú‚îÄ‚îÄ package.json           # NPM configuration
‚îî‚îÄ‚îÄ tsconfig.json          # TypeScript configuration
```

## Important Files

- **CLAUDE.md** - Essential project context for AI assistance
- **package.json** - NPM package configuration and scripts
- **tsconfig.json** - TypeScript compilation settings
- **.gitignore** - Git ignore patterns (includes `temp/`)
- **.vscode/launch.json** - VS Code debugging/testing configurations

<!-- ============================================================ -->
<!-- FILE: eslint.config.js                                       -->
<!-- ============================================================ -->
import js from '@eslint/js';
import tseslint from '@typescript-eslint/eslint-plugin';
import tsparser from '@typescript-eslint/parser';
import importPlugin from 'eslint-plugin-import';
import unicorn from 'eslint-plugin-unicorn';

export default [
  js.configs.recommended,
  {
    files: ['src/**/*.ts'],
    languageOptions: {
      parser: tsparser,
      parserOptions: {
        ecmaVersion: 2022,
        sourceType: 'module',
        project: './tsconfig.json',
        tsconfigRootDir: process.cwd()
      },
      globals: {
        console: 'readonly',
        process: 'readonly',
        Buffer: 'readonly',
        __dirname: 'readonly',
        __filename: 'readonly',
        NodeJS: 'readonly'
      }
    },
    plugins: {
      '@typescript-eslint': tseslint,
      'import': importPlugin,
      'unicorn': unicorn
    },
    settings: {
      'import/resolver': {
        typescript: {
          alwaysTryTypes: true,
          project: './tsconfig.json'
        }
      }
    },
    rules: {
      // TypeScript recommended-type-checked rules
      ...tseslint.configs['recommended-type-checked'].rules,
      
      // Additional TypeScript strict rules
      '@typescript-eslint/no-explicit-any': 'error',
      '@typescript-eslint/no-unused-vars': 'error',
      '@typescript-eslint/prefer-readonly': 'error',
      '@typescript-eslint/explicit-function-return-type': 'error',
      '@typescript-eslint/explicit-module-boundary-types': 'error',
      '@typescript-eslint/no-inferrable-types': 'error',
      '@typescript-eslint/no-unnecessary-type-assertion': 'error',
      '@typescript-eslint/prefer-nullish-coalescing': 'error',
      '@typescript-eslint/prefer-optional-chain': 'error',
      '@typescript-eslint/prefer-string-starts-ends-with': 'error',
      '@typescript-eslint/prefer-includes': 'error',
      '@typescript-eslint/no-floating-promises': 'error',
      '@typescript-eslint/await-thenable': 'error',
      '@typescript-eslint/no-misused-promises': 'error',
      '@typescript-eslint/require-await': 'error',

      // General code quality
      'no-console': 'off', // CLI app needs console output
      'no-debugger': 'error',
      'no-alert': 'error',
      'no-var': 'error',
      'prefer-const': 'error',
      'prefer-arrow-callback': 'error',
      'prefer-template': 'error',
      'object-shorthand': 'error',
      'quote-props': ['error', 'as-needed'],
      'no-duplicate-imports': 'error',
      
      // Import rules with TypeScript resolver
      'import/order': [
        'error',
        {
          'groups': [
            'builtin',
            'external', 
            'internal',
            'parent',
            'sibling',
            'index'
          ],
          'newlines-between': 'never',
          'alphabetize': {
            'order': 'asc',
            'caseInsensitive': true
          }
        }
      ],
      'import/no-duplicates': 'error',
      'import/no-unresolved': 'error',
      'import/extensions': [
        'error',
        'always',
        {
          'ts': 'never',
          'tsx': 'never'
        }
      ],

      // Unicorn rules for modern JS practices
      'unicorn/prefer-node-protocol': 'error',
      'unicorn/prefer-module': 'error',
      'unicorn/prefer-ternary': 'warn',
      'unicorn/prefer-logical-operator-over-ternary': 'error',
      'unicorn/no-array-for-each': 'warn',
      'unicorn/prefer-array-some': 'error',
      'unicorn/prefer-array-find': 'error',
      'unicorn/prefer-array-flat': 'error',
      'unicorn/prefer-object-from-entries': 'error',
      'unicorn/prefer-set-has': 'error',
      'unicorn/prefer-string-slice': 'error',
      'unicorn/prefer-number-properties': 'error',
      'unicorn/numeric-separators-style': 'error',
      'unicorn/better-regex': 'error',
      'unicorn/catch-error-name': 'error',
      'unicorn/custom-error-definition': 'error',
      'unicorn/error-message': 'error',
      'unicorn/escape-case': 'error',
      'unicorn/explicit-length-check': 'error',
      'unicorn/filename-case': [
        'error',
        {
          'cases': {
            'camelCase': true,
            'pascalCase': true,
            'kebabCase': true
          }
        }
      ],
      'unicorn/new-for-builtins': 'error',
      'unicorn/no-abusive-eslint-disable': 'error',
      'unicorn/no-array-push-push': 'error',
      'unicorn/no-console-spaces': 'error',
      'unicorn/no-hex-escape': 'error',
      'unicorn/no-instanceof-array': 'error',
      'unicorn/no-new-buffer': 'error',
      'unicorn/no-unnecessary-await': 'error',
      'unicorn/no-useless-length-check': 'error',
      'unicorn/no-useless-spread': 'error',
      'unicorn/no-zero-fractions': 'error',
      'unicorn/number-literal-case': 'error',
      'unicorn/prefer-add-event-listener': 'error',
      'unicorn/prefer-array-index-of': 'error',
      'unicorn/prefer-date-now': 'error',
      'unicorn/prefer-default-parameters': 'error',
      'unicorn/prefer-includes': 'error',
      'unicorn/prefer-math-trunc': 'error',
      'unicorn/prefer-negative-index': 'error',
      'unicorn/prefer-optional-catch-binding': 'error',
      'unicorn/prefer-prototype-methods': 'error',
      'unicorn/prefer-reflect-apply': 'error',
      'unicorn/prefer-regexp-test': 'error',
      'unicorn/prefer-spread': 'error',
      'unicorn/prefer-string-replace-all': 'error',
      'unicorn/prefer-string-trim-start-end': 'error',
      'unicorn/prefer-switch': 'error',
      'unicorn/prefer-type-error': 'error',
      'unicorn/throw-new-error': 'error'
    }
  },
  {
    files: ['tests/**/*', '**/*.test.ts', '**/*.spec.ts'],
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/explicit-function-return-type': 'off',
      '@typescript-eslint/unbound-method': 'off',
      'no-console': 'off'
    }
  }
];

<!-- ============================================================ -->
<!-- FILE: examples/fluent-api-example.js                         -->
<!-- ============================================================ -->
#!/usr/bin/env node

// Example demonstrating the Fluent API for Project Fusion
import { projectFusion } from 'project-fusion';

async function basicExample() {
    console.log('üöÄ Basic Fluent API Example');
    
    try {
        const result = await projectFusion()
            .include(['web', 'backend'])
            .exclude(['*.test.ts', 'node_modules'])
            .maxSize('2MB')
            .output(['md', 'html'])
            .generate();

        if (result.success) {
            console.log('‚úÖ Fusion completed successfully!');
            console.log(`üìÑ Generated files: ${result.message}`);
        } else {
            console.log('‚ùå Fusion failed:', result.message);
        }
    } catch (error) {
        console.error('Error:', error.message);
    }
}

async function advancedExample() {
    console.log('\nüîß Advanced Fluent API Example');
    
    try {
        const result = await projectFusion()
            .root('./src')
            .include(['web', 'backend'])
            .exclude(['*.test.ts', '__tests__/', 'coverage/'])
            .maxSize('5MB')
            .output(['text', 'md', 'html'])
            .name('my-project-fusion')
            .subdirectories(true)
            .clipboard(false)
            .gitignore(true)
            .extensions('custom', ['.custom', '.special'])
            .configure((options) => {
                // Custom configuration function
                options.parseSubDirectories = true;
                options.useGitIgnoreForExcludes = true;
            })
            .generate();

        if (result.success) {
            console.log('‚úÖ Advanced fusion completed!');
            console.log(`üìÑ Generated files: ${result.message}`);
        } else {
            console.log('‚ùå Advanced fusion failed:', result.message);
        }
    } catch (error) {
        console.error('Error:', error.message);
    }
}

async function configInspection() {
    console.log('\nüîç Configuration Inspection Example');
    
    const builder = projectFusion()
        .root('./src')
        .include(['web'])
        .maxSize('1MB')
        .output(['md']);
    
    const config = builder.getConfig();
    console.log('Current configuration:', JSON.stringify(config, null, 2));
    
    // Reset and reconfigure
    builder.reset()
        .include(['backend'])
        .maxSize('500KB');
        
    const newConfig = builder.getConfig();
    console.log('After reset:', JSON.stringify(newConfig, null, 2));
}

// Run examples
async function runExamples() {
    await basicExample();
    await advancedExample();
    await configInspection();
}

runExamples().catch(console.error);

<!-- ============================================================ -->
<!-- FILE: package.json                                           -->
<!-- ============================================================ -->
{
    "name": "project-fusion",
    "version": "1.0.0",
    "description": "CLI tool for merging project files into a single file for easy sharing",
    "main": "dist/index.js",
    "types": "dist/index.d.ts",
    "type": "module",
    "bin": {
        "project-fusion": "dist/cli.js"
    },
    "exports": {
        ".": {
            "types": "./dist/index.d.ts",
            "import": "./dist/index.js"
        },
        "./package.json": "./package.json"
    },
    "files": [
        "dist/**/*",
        "README.md",
        "LICENSE",
        "CHANGELOG.md"
    ],
    "sideEffects": false,
    "scripts": {
        "build": "tsc",
        "clean": "rm -rf dist",
        "dev": "tsc --watch",
        "lint": "eslint src/**/*.ts",
        "lint:fix": "eslint src/**/*.ts --fix",
        "prepublishOnly": "npm run clean && npm run build",
        "test": "vitest run --coverage",
        "test:ui": "vitest --ui",
        "typecheck": "tsc --noEmit"
    },
    "keywords": [
        "cli",
        "code",
        "collaboration",
        "files",
        "fusion",
        "merge",
        "sharing"
    ],
    "author": "the99studio",
    "license": "MIT",
    "engines": {
        "node": ">=18.0.0"
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/the99studio/project-fusion.git"
    },
    "bugs": {
        "url": "https://github.com/the99studio/project-fusion/issues"
    },
    "homepage": "https://github.com/the99studio/project-fusion#readme",
    "publishConfig": {
        "access": "public"
    },
    "dependencies": {
        "chalk": "^5.5.0",
        "clipboardy": "^4.0.0",
        "commander": "^14.0.0",
        "fs-extra": "^11.3.1",
        "glob": "^11.0.3",
        "ignore": "^7.0.5",
        "zod": "^4.0.17"
    },
    "devDependencies": {
        "@types/fs-extra": "^11.0.4",
        "@types/node": "^24.2.1",
        "@typescript-eslint/eslint-plugin": "^8.39.1",
        "@typescript-eslint/parser": "^8.39.1",
        "@vitest/coverage-v8": "^2.1.9",
        "eslint": "^9.33.0",
        "eslint-import-resolver-typescript": "^4.4.4",
        "eslint-plugin-import": "^2.32.0",
        "eslint-plugin-node": "^11.1.0",
        "eslint-plugin-unicorn": "^60.0.0",
        "fast-check": "^4.2.0",
        "typescript": "^5.9.2",
        "vitest": "^2.1.6"
    }
}


<!-- ============================================================ -->
<!-- FILE: project-fusioned.html                                  -->
<!-- ============================================================ -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Fusion - project-fusion v1.0.0</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { border-bottom: 2px solid #eee; padding-bottom: 20px; margin-bottom: 30px; }
        .file-section { margin-bottom: 40px; border: 1px solid #ddd; border-radius: 8px; padding: 20px; }
        .file-title { background: #f5f5f5; margin: -20px -20px 20px -20px; padding: 15px 20px; border-radius: 8px 8px 0 0; }
        pre { background: #f8f9fa; padding: 15px; border-radius: 6px; overflow-x: auto; }
        code { font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; }
        .toc { background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 30px; }
        .toc ul { margin: 0; padding-left: 20px; }
        .toc a { text-decoration: none; color: #0366d6; }
        .toc a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Generated Project Fusion File</h1>
        <p><strong>Project:</strong> project-fusion v1.0.0</p>
        <p><strong>Generated:</strong> 17/08/2025 19:23:55 UTC‚àí4</p>
        <p><strong>UTC:</strong> 2025-08-17T23:23:55.142Z</p>
        <p><strong>Files:</strong> 45</p>
        <p><strong>Generated by:</strong> <a href="https://github.com/the99studio/project-fusion">project-fusion</a></p>
    </div>
    <div class="toc">
        <h2>üìÅ Table of Contents</h2>
        <ul>
            <li><a href="#changelog-md">CHANGELOG.md</a></li>
            <li><a href="#claude-md">CLAUDE.md</a></li>
            <li><a href="#contributing-md">CONTRIBUTING.md</a></li>
            <li><a href="#development-md">DEVELOPMENT.md</a></li>
            <li><a href="#eslint-config-js">eslint.config.js</a></li>
            <li><a href="#examples-fluent-api-example-js">examples/fluent-api-example.js</a></li>
            <li><a href="#package-json">package.json</a></li>
            <li><a href="#readme-md">README.md</a></li>
            <li><a href="#src-adapters-file-system-ts">src/adapters/file-system.ts</a></li>
            <li><a href="#src-api-ts">src/api.ts</a></li>
            <li><a href="#src-benchmark-ts">src/benchmark.ts</a></li>
            <li><a href="#src-cli-ts">src/cli.ts</a></li>
            <li><a href="#src-clicommands-ts">src/clicommands.ts</a></li>
            <li><a href="#src-fluent-ts">src/fluent.ts</a></li>
            <li><a href="#src-fusion-ts">src/fusion.ts</a></li>
            <li><a href="#src-index-ts">src/index.ts</a></li>
            <li><a href="#src-plugins-plugin-system-ts">src/plugins/plugin-system.ts</a></li>
            <li><a href="#src-schema-ts">src/schema.ts</a></li>
            <li><a href="#src-strategies-output-strategy-ts">src/strategies/output-strategy.ts</a></li>
            <li><a href="#src-types-ts">src/types.ts</a></li>
            <li><a href="#src-utils-ts">src/utils.ts</a></li>
            <li><a href="#tests-api-test-ts">tests/api.test.ts</a></li>
            <li><a href="#tests-architecture-test-ts">tests/architecture.test.ts</a></li>
            <li><a href="#tests-benchmark-test-ts">tests/benchmark.test.ts</a></li>
            <li><a href="#tests-cli-e2e-test-ts">tests/cli-e2e.test.ts</a></li>
            <li><a href="#tests-clicommands-test-ts">tests/clicommands.test.ts</a></li>
            <li><a href="#tests-file-security-test-ts">tests/file-security.test.ts</a></li>
            <li><a href="#tests-fluent-test-ts">tests/fluent.test.ts</a></li>
            <li><a href="#tests-formats-test-ts">tests/formats.test.ts</a></li>
            <li><a href="#tests-fusion-coverage-test-ts">tests/fusion-coverage.test.ts</a></li>
            <li><a href="#tests-index-test-ts">tests/index.test.ts</a></li>
            <li><a href="#tests-integration-test-ts">tests/integration.test.ts</a></li>
            <li><a href="#tests-memory-fs-test-ts">tests/memory-fs.test.ts</a></li>
            <li><a href="#tests-plugin-system-test-ts">tests/plugin-system.test.ts</a></li>
            <li><a href="#tests-property-based-test-ts">tests/property-based.test.ts</a></li>
            <li><a href="#tests-schema-test-ts">tests/schema.test.ts</a></li>
            <li><a href="#tests-security-test-ts">tests/security.test.ts</a></li>
            <li><a href="#tests-snapshots-test-ts">tests/snapshots.test.ts</a></li>
            <li><a href="#tests-types-test-ts">tests/types.test.ts</a></li>
            <li><a href="#tests-utility-types-test-ts">tests/utility-types.test.ts</a></li>
            <li><a href="#tests-utils-coverage-test-ts">tests/utils-coverage.test.ts</a></li>
            <li><a href="#tests-utils-test-ts">tests/utils.test.ts</a></li>
            <li><a href="#todo-md">TODO.md</a></li>
            <li><a href="#tsconfig-json">tsconfig.json</a></li>
            <li><a href="#vitest-config-ts">vitest.config.ts</a></li>
        </ul>
    </div>
    <div class="file-section" id="changelog-md">
        <div class="file-title">
            <h2>üìÑ CHANGELOG.md</h2>
        </div>
        <pre><code class="markdown"># Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [1.0.0] - 2025-01-17

### Initial Release

Project Fusion is a CLI tool that merges multiple project files into a single file for easy sharing and collaboration. This initial release provides multiple output formats.

### Added

#### Core Features
- **Multi-format output generation** - Supports .txt, .md, and .html formats
  - Plain text (.txt) with file separators
  - Markdown (.md) with syntax highlighting and table of contents
  - HTML (.html) with responsive design and navigation
- **Configuration system** with JSON schema validation using Zod
  - Automatic configuration generation with `init` command
  - File extension support (35+ extensions) organized by category
  - Customizable ignore patterns with .gitignore integration
- **CLI interface** built with Commander.js
  - Simple command structure: `project-fusion`, `project-fusion init`, `project-fusion config-check`
  - Command-line options for dynamic configuration overrides
  - Version and help commands

#### File Extension Support (38 extensions)
- **Web Development**: .css, .html, .js, .jsx, .svelte, .ts, .tsx, .vue
- **Backend Languages**: .cs, .go, .java, .php, .py, .rb, .rs  
- **Configuration**: .json, .toml, .xml, .yaml, .yml
- **C/C++**: .c, .cc, .cpp, .h, .hpp
- **Scripts**: .bat, .cmd, .ps1, .sh
- **Godot Engine**: .cfg, .cs, .gd, .import, .tscn, .tres
- **Documentation**: .adoc, .md, .rst

#### Technical Features
- **TypeScript 5.9.2** with strict mode and ESM modules
- **Branded types** (FilePath) for type-safe path handling
- **Discriminated unions** for error handling (FusionResult)
- **Error handling** with FusionError class, error codes, and severity levels
- **Performance metrics** logging
- **Clipboard integration** with automatic fallback for CI environments

#### Testing and Quality
- **Test coverage** with Vitest integration tests
- **ESLint v9** flat configuration
- **SPDX license headers** in all source files
- **Modular architecture** with separation of concerns
- **Error boundaries** and failure handling

#### Configuration Features
- **Schema versioning** for future compatibility
- **Default values** with fallback configuration
- **gitignore integration**
- **Custom ignore patterns** with glob support
- **File size limits** to prevent memory issues
- **Subdirectory parsing** control

### Technical Implementation
- **Architecture** with separation between CLI, fusion logic, and utilities
- **Zod validation** for configuration validation
- **File scanning** with glob patterns and ignore filtering
- **File size limits** configurable per project
- **Cross-platform compatibility** (Windows, macOS, Linux)
- **Node.js 18+** requirement

### Security Features
- **Path traversal protection** - All file paths validated to remain within root directory
- **Symbolic link protection** - Symlinks detected and blocked by default with `follow: false` in glob operations
- **Binary file detection** - Automatic detection and skipping of binary files using null byte and non-printable character analysis
- **XSS prevention** - All HTML output properly escaped to prevent cross-site scripting attacks
- **Safe error handling** - Security-related errors logged without exposing sensitive path information
- **Comprehensive security testing** - 17 security tests covering path traversal, symlink attacks, and binary file handling

### Documentation
- README with quick start guide
- CLAUDE.md for AI context
- DEVELOPMENT.md for contributors
- CONTRIBUTING.md with guidelines
- MIT License

---

[1.0.0]: https://github.com/the99studio/project-fusion/releases/tag/v1.0.0</code></pre>
    </div>

    <div class="file-section" id="claude-md">
        <div class="file-title">
            <h2>üìÑ CLAUDE.md</h2>
        </div>
        <pre><code class="markdown"># Project Fusion - AI Context

&gt; üìñ **For Human Development**: See [DEVELOPMENT.md](./DEVELOPMENT.md) for detailed development workflows, testing procedures, and npm publication guide.

## Project Overview
Project Fusion merges multiple project files into a single file for easy sharing and collaboration.

## Essential Architecture
- **TypeScript 5.9.2** ESM project with strict type checking
- **CLI tool** built with Commander.js that generates .txt, .md, and .html fusion files
- **Configuration-driven** with Zod validation and default fallbacks
- **Multi-format output** with syntax highlighting and filtering

## Core Files Structure
```
src/
‚îú‚îÄ‚îÄ cli.ts              # CLI entry point
‚îú‚îÄ‚îÄ clicommands.ts      # Command implementations  
‚îú‚îÄ‚îÄ fusion.ts           # Core fusion logic
‚îú‚îÄ‚îÄ types.ts            # Type definitions (branded types)
‚îú‚îÄ‚îÄ schema.ts           # Zod validation schemas
‚îú‚îÄ‚îÄ utils.ts            # File operations &amp; utilities
‚îî‚îÄ‚îÄ index.ts            # Main exports
```

## Key Commands
```bash
npm run build           # Build TypeScript ‚Üí JavaScript
npm run typecheck       # Type checking only
project-fusion init     # Initialize config
project-fusion          # Run fusion process
```

## Testing Directory
**‚ö†Ô∏è Important**: All testing and temporary files MUST be created in `temp/` directory at project root. This includes:
- Package testing: `temp/package/`
- File generation tests: `temp/test-files/`
- Any temporary artifacts: `temp/artifacts/`

The `temp/` directory is gitignored and safe for any testing activities.

## Configuration Schema
```typescript
{
  schemaVersion: 1
  copyToClipboard: boolean
  generatedFileName: string
  generateHtml: boolean
  generateMarkdown: boolean
  generateText: boolean
  maxFileSizeKB: number
  parseSubDirectories: boolean
  parsedFileExtensions: {
    web: string[]       // .js, .ts, .tsx, .vue, etc.
    backend: string[]   // .py, .go, .java, .rs, etc. 
    config: string[]    // .json, .yaml, .toml, etc.
    cpp: string[]       // .c, .cpp, .h, .hpp
    scripts: string[]   // .sh, .bat, .ps1
    godot: string[]     // .gd, .tscn, .tres
    doc: string[]       // .md, .rst, .adoc
  }
  rootDirectory: string
  ignorePatterns: string[]
  useGitIgnoreForExcludes: boolean
}
```

## Core Workflow
1. Load `project-fusion.json` config with Zod validation
2. Scan files by extensions, apply .gitignore + custom ignore patterns
3. Generate triple output:
   - `project-fusioned.txt` - Plain text with separators
   - `project-fusioned.md` - Markdown with syntax highlighting + TOC
   - `project-fusioned.html` - HTML with responsive design + interactive TOC

## Key Implementation Details
- **Branded types** (FilePath) prevent string confusion
- **Discriminated unions** (FusionResult) for type-safe error handling  
- **ESM modules** with strict TypeScript
- **Configuration fallbacks** - uses defaults if config missing/invalid

## Quick Reference
- **Add extensions**: Update `src/schema.ts` + `src/utils.ts` default config
- **Add commands**: Register in `src/cli.ts`, implement in `src/clicommands.ts`
- **Modify output**: Edit `src/fusion.ts` processing logic

## Documentation Style Guide
- **Keep it simple and professional**: Avoid superlatives and marketing language
- **Be factual**: Describe features without overselling
- **Use neutral tone**: Focus on functionality rather than promotional phrases
- **No excessive adjectives**: Avoid words like &quot;powerful&quot;, &quot;beautiful&quot;, &quot;smart&quot;, etc.</code></pre>
    </div>

    <div class="file-section" id="contributing-md">
        <div class="file-title">
            <h2>üìÑ CONTRIBUTING.md</h2>
        </div>
        <pre><code class="markdown"># Contributing to Project Fusion

Thanks for your interest! This guide explains how to propose changes and report issues.

## Code of Conduct
Be respectful and constructive. By participating, you agree to foster an open and welcoming environment.

## How to contribute
1. **Fork** the repo and create a branch: `feat/&lt;short-name&gt;` or `fix/&lt;short-name&gt;`.
2. See [DEVELOPMENT.md](./DEVELOPMENT.md) for detailed development workflows, testing procedures, and npm publication guide.
3. Open a Pull Request with a clear description and checklist.

## PR checklist
- [ ] Feature/bugfix tested
- [ ] No regressions
- [ ] Docs/README updated if necessary
- [ ] Notable changes added to `CHANGELOG.md`
</code></pre>
    </div>

    <div class="file-section" id="development-md">
        <div class="file-title">
            <h2>üìÑ DEVELOPMENT.md</h2>
        </div>
        <pre><code class="markdown"># Project Fusion - Development Guide

&gt; üìã **For Claude AI Context**: See [CLAUDE.md](./CLAUDE.md) for essential project information needed for development assistance.

## Development Workflow

### Initial Setup
```bash
git clone https://github.com/the99studio/project-fusion.git
cd project-fusion
npm install
npm run build
```

### Claude Code Integration
The project includes `.claude/settings.local.json` which configures Claude Code permissions for smoother development. This file provides:

**Allowed Operations:**
- NPM commands: install, build, typecheck, test, clean, pack
- Project CLI: `project-fusion` and `node dist/cli.js` commands
- Git operations: status, diff, log, branch, add, commit, push, pull
- Safe file operations: Limited to `temp/` directory for rm/cp operations
- Search capabilities: find, grep, rg, ls, cat, head, tail for code exploration
- Package management: npm list, outdated, view

**Security Features:**
- File deletions restricted to `temp/` directory only
- No arbitrary Node.js code execution (only specific CLI commands)
- Explicit deny list for dangerous operations (sudo, eval, etc.)
- No system-wide file modifications allowed

These permissions eliminate repetitive authorization prompts while maintaining security boundaries.

### Testing the CLI
Use VS Code launch configurations (F5) for easy testing:
- **&quot;Fusion (Default)&quot;** - Default behavior (runs fusion)
- **&quot;Fusion (Web)&quot;** - Test web extensions only
- **&quot;Help&quot;** - Test CLI help
- **&quot;Init&quot;** - Test project initialization

### Testing with Real Package
For testing as if it were the real published package, see the [NPM Package Testing](#-npm-package-management) section below.

## NPM Package Management

### Pre-Publication Testing

Use the **&quot;Test NPM Package&quot;** launch configuration in VS Code (F5) which automatically:
- Builds the project
- Creates and extracts test package to `temp/package/`
- Installs dependencies and tests CLI functionality

#### Manual Package Verification
```bash
# Preview what will be published
npm pack --dry-run

# Create test package (if not using VS Code)
npm pack  # Creates project-fusion-x.x.x.tgz
```

#### Testing with Real Package Installation
```bash
# Install the test package globally
npm install -g ./temp/package/ # start line with sudo if you need admin rights

# Test commands (acts like real published package)
project-fusion --help
project-fusion --version
project-fusion init
project-fusion # Default: runs fusion

# Uninstall when done testing
npm uninstall -g project-fusion # start line with sudo if you need admin rights
```

### Publication Process

```bash
# 1. Final verification
npm pack --dry-run

# 2. Simulate publication (verifies authentication, package validity)
npm publish --dry-run

# 3. Create npm account and login (first time only)
# Visit https://www.npmjs.com/signup to create account
npm login

# 4. Publish to npm
npm publish

# 5. Verify publication
npm view project-fusion
```

## üõ†Ô∏è Development Patterns

### Adding New File Extensions
1. Update `src/schema.ts` - add to `ParsedFileExtensionsSchema`
2. Update default config in `src/utils.ts` 
3. Test with various projects

### Adding New CLI Commands
1. Register command in `src/cli.ts` (Commander.js)
2. Implement in `src/clicommands.ts`
3. Update help text and documentation

### Modifying Fusion Output
1. Edit `src/fusion.ts` processing logic
2. Update types in `src/types.ts` if needed
3. Test both .txt and .md output formats

## Testing Strategy

### Manual Testing Checklist
- [ ] `npm run build` - clean build
- [ ] `npm run typecheck` - no type errors
- [ ] CLI help works: `project-fusion --help`
- [ ] Init works: `project-fusion init`
- [ ] Fusion works: `project-fusion`
- [ ] Extension filtering works
- [ ] .gitignore integration works
- [ ] Output files are properly formatted
- [ ] Package builds and installs correctly

### Test Projects
Use these types of projects for testing:
- **Node.js/TypeScript** (like this project)
- **Python projects** (test backend extensions)
- **React/Vue projects** (test web extensions)
- **Mixed projects** (multiple extension types)

## Troubleshooting

### Common Issues

**Build Errors:**
```bash
npm run clean &amp;&amp; npm run build
```

**Package Contains Wrong Files:**
- Check `package.json` `files` field
- Use `npm pack --dry-run` to verify

**TypeScript Errors:**
```bash
npm run typecheck
# Fix errors in src/ files
```

## Directory Structure

```
project-fusion/
‚îú‚îÄ‚îÄ src/                    # TypeScript source
‚îÇ   ‚îú‚îÄ‚îÄ cli.ts             # CLI entry point
‚îÇ   ‚îú‚îÄ‚îÄ clicommands.ts     # Command implementations
‚îÇ   ‚îú‚îÄ‚îÄ fusion.ts          # Core fusion logic
‚îÇ   ‚îú‚îÄ‚îÄ types.ts           # Type definitions
‚îÇ   ‚îú‚îÄ‚îÄ schema.ts          # Zod schemas
‚îÇ   ‚îú‚îÄ‚îÄ utils.ts           # Utilities
‚îÇ   ‚îî‚îÄ‚îÄ index.ts           # Main exports
‚îú‚îÄ‚îÄ dist/                  # Compiled JavaScript (gitignored)
‚îú‚îÄ‚îÄ temp/                  # Testing directory (gitignored)
‚îú‚îÄ‚îÄ CLAUDE.md              # AI context (essential info)
‚îú‚îÄ‚îÄ DEVELOPMENT.md         # This file (human development)
‚îú‚îÄ‚îÄ package.json           # NPM configuration
‚îî‚îÄ‚îÄ tsconfig.json          # TypeScript configuration
```

## Important Files

- **CLAUDE.md** - Essential project context for AI assistance
- **package.json** - NPM package configuration and scripts
- **tsconfig.json** - TypeScript compilation settings
- **.gitignore** - Git ignore patterns (includes `temp/`)
- **.vscode/launch.json** - VS Code debugging/testing configurations</code></pre>
    </div>

    <div class="file-section" id="eslint-config-js">
        <div class="file-title">
            <h2>üìÑ eslint.config.js</h2>
        </div>
        <pre><code class="javascript">import js from &#39;@eslint/js&#39;;
import tseslint from &#39;@typescript-eslint/eslint-plugin&#39;;
import tsparser from &#39;@typescript-eslint/parser&#39;;
import importPlugin from &#39;eslint-plugin-import&#39;;
import unicorn from &#39;eslint-plugin-unicorn&#39;;

export default [
  js.configs.recommended,
  {
    files: [&#39;src/**/*.ts&#39;],
    languageOptions: {
      parser: tsparser,
      parserOptions: {
        ecmaVersion: 2022,
        sourceType: &#39;module&#39;,
        project: &#39;./tsconfig.json&#39;,
        tsconfigRootDir: process.cwd()
      },
      globals: {
        console: &#39;readonly&#39;,
        process: &#39;readonly&#39;,
        Buffer: &#39;readonly&#39;,
        __dirname: &#39;readonly&#39;,
        __filename: &#39;readonly&#39;,
        NodeJS: &#39;readonly&#39;
      }
    },
    plugins: {
      &#39;@typescript-eslint&#39;: tseslint,
      &#39;import&#39;: importPlugin,
      &#39;unicorn&#39;: unicorn
    },
    settings: {
      &#39;import/resolver&#39;: {
        typescript: {
          alwaysTryTypes: true,
          project: &#39;./tsconfig.json&#39;
        }
      }
    },
    rules: {
      // TypeScript recommended-type-checked rules
      ...tseslint.configs[&#39;recommended-type-checked&#39;].rules,
      
      // Additional TypeScript strict rules
      &#39;@typescript-eslint/no-explicit-any&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/no-unused-vars&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/prefer-readonly&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/explicit-function-return-type&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/explicit-module-boundary-types&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/no-inferrable-types&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/no-unnecessary-type-assertion&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/prefer-nullish-coalescing&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/prefer-optional-chain&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/prefer-string-starts-ends-with&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/prefer-includes&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/no-floating-promises&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/await-thenable&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/no-misused-promises&#39;: &#39;error&#39;,
      &#39;@typescript-eslint/require-await&#39;: &#39;error&#39;,

      // General code quality
      &#39;no-console&#39;: &#39;off&#39;, // CLI app needs console output
      &#39;no-debugger&#39;: &#39;error&#39;,
      &#39;no-alert&#39;: &#39;error&#39;,
      &#39;no-var&#39;: &#39;error&#39;,
      &#39;prefer-const&#39;: &#39;error&#39;,
      &#39;prefer-arrow-callback&#39;: &#39;error&#39;,
      &#39;prefer-template&#39;: &#39;error&#39;,
      &#39;object-shorthand&#39;: &#39;error&#39;,
      &#39;quote-props&#39;: [&#39;error&#39;, &#39;as-needed&#39;],
      &#39;no-duplicate-imports&#39;: &#39;error&#39;,
      
      // Import rules with TypeScript resolver
      &#39;import/order&#39;: [
        &#39;error&#39;,
        {
          &#39;groups&#39;: [
            &#39;builtin&#39;,
            &#39;external&#39;, 
            &#39;internal&#39;,
            &#39;parent&#39;,
            &#39;sibling&#39;,
            &#39;index&#39;
          ],
          &#39;newlines-between&#39;: &#39;never&#39;,
          &#39;alphabetize&#39;: {
            &#39;order&#39;: &#39;asc&#39;,
            &#39;caseInsensitive&#39;: true
          }
        }
      ],
      &#39;import/no-duplicates&#39;: &#39;error&#39;,
      &#39;import/no-unresolved&#39;: &#39;error&#39;,
      &#39;import/extensions&#39;: [
        &#39;error&#39;,
        &#39;always&#39;,
        {
          &#39;ts&#39;: &#39;never&#39;,
          &#39;tsx&#39;: &#39;never&#39;
        }
      ],

      // Unicorn rules for modern JS practices
      &#39;unicorn/prefer-node-protocol&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-module&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-ternary&#39;: &#39;warn&#39;,
      &#39;unicorn/prefer-logical-operator-over-ternary&#39;: &#39;error&#39;,
      &#39;unicorn/no-array-for-each&#39;: &#39;warn&#39;,
      &#39;unicorn/prefer-array-some&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-array-find&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-array-flat&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-object-from-entries&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-set-has&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-string-slice&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-number-properties&#39;: &#39;error&#39;,
      &#39;unicorn/numeric-separators-style&#39;: &#39;error&#39;,
      &#39;unicorn/better-regex&#39;: &#39;error&#39;,
      &#39;unicorn/catch-error-name&#39;: &#39;error&#39;,
      &#39;unicorn/custom-error-definition&#39;: &#39;error&#39;,
      &#39;unicorn/error-message&#39;: &#39;error&#39;,
      &#39;unicorn/escape-case&#39;: &#39;error&#39;,
      &#39;unicorn/explicit-length-check&#39;: &#39;error&#39;,
      &#39;unicorn/filename-case&#39;: [
        &#39;error&#39;,
        {
          &#39;cases&#39;: {
            &#39;camelCase&#39;: true,
            &#39;pascalCase&#39;: true,
            &#39;kebabCase&#39;: true
          }
        }
      ],
      &#39;unicorn/new-for-builtins&#39;: &#39;error&#39;,
      &#39;unicorn/no-abusive-eslint-disable&#39;: &#39;error&#39;,
      &#39;unicorn/no-array-push-push&#39;: &#39;error&#39;,
      &#39;unicorn/no-console-spaces&#39;: &#39;error&#39;,
      &#39;unicorn/no-hex-escape&#39;: &#39;error&#39;,
      &#39;unicorn/no-instanceof-array&#39;: &#39;error&#39;,
      &#39;unicorn/no-new-buffer&#39;: &#39;error&#39;,
      &#39;unicorn/no-unnecessary-await&#39;: &#39;error&#39;,
      &#39;unicorn/no-useless-length-check&#39;: &#39;error&#39;,
      &#39;unicorn/no-useless-spread&#39;: &#39;error&#39;,
      &#39;unicorn/no-zero-fractions&#39;: &#39;error&#39;,
      &#39;unicorn/number-literal-case&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-add-event-listener&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-array-index-of&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-date-now&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-default-parameters&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-includes&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-math-trunc&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-negative-index&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-optional-catch-binding&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-prototype-methods&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-reflect-apply&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-regexp-test&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-spread&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-string-replace-all&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-string-trim-start-end&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-switch&#39;: &#39;error&#39;,
      &#39;unicorn/prefer-type-error&#39;: &#39;error&#39;,
      &#39;unicorn/throw-new-error&#39;: &#39;error&#39;
    }
  },
  {
    files: [&#39;tests/**/*&#39;, &#39;**/*.test.ts&#39;, &#39;**/*.spec.ts&#39;],
    rules: {
      &#39;@typescript-eslint/no-explicit-any&#39;: &#39;off&#39;,
      &#39;@typescript-eslint/explicit-function-return-type&#39;: &#39;off&#39;,
      &#39;@typescript-eslint/unbound-method&#39;: &#39;off&#39;,
      &#39;no-console&#39;: &#39;off&#39;
    }
  }
];</code></pre>
    </div>

    <div class="file-section" id="examples-fluent-api-example-js">
        <div class="file-title">
            <h2>üìÑ examples/fluent-api-example.js</h2>
        </div>
        <pre><code class="javascript">#!/usr/bin/env node

// Example demonstrating the Fluent API for Project Fusion
import { projectFusion } from &#39;project-fusion&#39;;

async function basicExample() {
    console.log(&#39;üöÄ Basic Fluent API Example&#39;);
    
    try {
        const result = await projectFusion()
            .include([&#39;web&#39;, &#39;backend&#39;])
            .exclude([&#39;*.test.ts&#39;, &#39;node_modules&#39;])
            .maxSize(&#39;2MB&#39;)
            .output([&#39;md&#39;, &#39;html&#39;])
            .generate();

        if (result.success) {
            console.log(&#39;‚úÖ Fusion completed successfully!&#39;);
            console.log(`üìÑ Generated files: ${result.message}`);
        } else {
            console.log(&#39;‚ùå Fusion failed:&#39;, result.message);
        }
    } catch (error) {
        console.error(&#39;Error:&#39;, error.message);
    }
}

async function advancedExample() {
    console.log(&#39;\nüîß Advanced Fluent API Example&#39;);
    
    try {
        const result = await projectFusion()
            .root(&#39;./src&#39;)
            .include([&#39;web&#39;, &#39;backend&#39;])
            .exclude([&#39;*.test.ts&#39;, &#39;__tests__/&#39;, &#39;coverage/&#39;])
            .maxSize(&#39;5MB&#39;)
            .output([&#39;text&#39;, &#39;md&#39;, &#39;html&#39;])
            .name(&#39;my-project-fusion&#39;)
            .subdirectories(true)
            .clipboard(false)
            .gitignore(true)
            .extensions(&#39;custom&#39;, [&#39;.custom&#39;, &#39;.special&#39;])
            .configure((options) =&gt; {
                // Custom configuration function
                options.parseSubDirectories = true;
                options.useGitIgnoreForExcludes = true;
            })
            .generate();

        if (result.success) {
            console.log(&#39;‚úÖ Advanced fusion completed!&#39;);
            console.log(`üìÑ Generated files: ${result.message}`);
        } else {
            console.log(&#39;‚ùå Advanced fusion failed:&#39;, result.message);
        }
    } catch (error) {
        console.error(&#39;Error:&#39;, error.message);
    }
}

async function configInspection() {
    console.log(&#39;\nüîç Configuration Inspection Example&#39;);
    
    const builder = projectFusion()
        .root(&#39;./src&#39;)
        .include([&#39;web&#39;])
        .maxSize(&#39;1MB&#39;)
        .output([&#39;md&#39;]);
    
    const config = builder.getConfig();
    console.log(&#39;Current configuration:&#39;, JSON.stringify(config, null, 2));
    
    // Reset and reconfigure
    builder.reset()
        .include([&#39;backend&#39;])
        .maxSize(&#39;500KB&#39;);
        
    const newConfig = builder.getConfig();
    console.log(&#39;After reset:&#39;, JSON.stringify(newConfig, null, 2));
}

// Run examples
async function runExamples() {
    await basicExample();
    await advancedExample();
    await configInspection();
}

runExamples().catch(console.error);</code></pre>
    </div>

    <div class="file-section" id="package-json">
        <div class="file-title">
            <h2>üìÑ package.json</h2>
        </div>
        <pre><code class="json">{
    &quot;name&quot;: &quot;project-fusion&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;description&quot;: &quot;CLI tool for merging project files into a single file for easy sharing&quot;,
    &quot;main&quot;: &quot;dist/index.js&quot;,
    &quot;types&quot;: &quot;dist/index.d.ts&quot;,
    &quot;type&quot;: &quot;module&quot;,
    &quot;bin&quot;: {
        &quot;project-fusion&quot;: &quot;dist/cli.js&quot;
    },
    &quot;exports&quot;: {
        &quot;.&quot;: {
            &quot;types&quot;: &quot;./dist/index.d.ts&quot;,
            &quot;import&quot;: &quot;./dist/index.js&quot;
        },
        &quot;./package.json&quot;: &quot;./package.json&quot;
    },
    &quot;files&quot;: [
        &quot;dist/**/*&quot;,
        &quot;README.md&quot;,
        &quot;LICENSE&quot;,
        &quot;CHANGELOG.md&quot;
    ],
    &quot;sideEffects&quot;: false,
    &quot;scripts&quot;: {
        &quot;build&quot;: &quot;tsc&quot;,
        &quot;clean&quot;: &quot;rm -rf dist&quot;,
        &quot;dev&quot;: &quot;tsc --watch&quot;,
        &quot;lint&quot;: &quot;eslint src/**/*.ts&quot;,
        &quot;lint:fix&quot;: &quot;eslint src/**/*.ts --fix&quot;,
        &quot;prepublishOnly&quot;: &quot;npm run clean &amp;&amp; npm run build&quot;,
        &quot;test&quot;: &quot;vitest run --coverage&quot;,
        &quot;test:ui&quot;: &quot;vitest --ui&quot;,
        &quot;typecheck&quot;: &quot;tsc --noEmit&quot;
    },
    &quot;keywords&quot;: [
        &quot;cli&quot;,
        &quot;code&quot;,
        &quot;collaboration&quot;,
        &quot;files&quot;,
        &quot;fusion&quot;,
        &quot;merge&quot;,
        &quot;sharing&quot;
    ],
    &quot;author&quot;: &quot;the99studio&quot;,
    &quot;license&quot;: &quot;MIT&quot;,
    &quot;engines&quot;: {
        &quot;node&quot;: &quot;&gt;=18.0.0&quot;
    },
    &quot;repository&quot;: {
        &quot;type&quot;: &quot;git&quot;,
        &quot;url&quot;: &quot;https://github.com/the99studio/project-fusion.git&quot;
    },
    &quot;bugs&quot;: {
        &quot;url&quot;: &quot;https://github.com/the99studio/project-fusion/issues&quot;
    },
    &quot;homepage&quot;: &quot;https://github.com/the99studio/project-fusion#readme&quot;,
    &quot;publishConfig&quot;: {
        &quot;access&quot;: &quot;public&quot;
    },
    &quot;dependencies&quot;: {
        &quot;chalk&quot;: &quot;^5.5.0&quot;,
        &quot;clipboardy&quot;: &quot;^4.0.0&quot;,
        &quot;commander&quot;: &quot;^14.0.0&quot;,
        &quot;fs-extra&quot;: &quot;^11.3.1&quot;,
        &quot;glob&quot;: &quot;^11.0.3&quot;,
        &quot;ignore&quot;: &quot;^7.0.5&quot;,
        &quot;zod&quot;: &quot;^4.0.17&quot;
    },
    &quot;devDependencies&quot;: {
        &quot;@types/fs-extra&quot;: &quot;^11.0.4&quot;,
        &quot;@types/node&quot;: &quot;^24.2.1&quot;,
        &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^8.39.1&quot;,
        &quot;@typescript-eslint/parser&quot;: &quot;^8.39.1&quot;,
        &quot;@vitest/coverage-v8&quot;: &quot;^2.1.9&quot;,
        &quot;eslint&quot;: &quot;^9.33.0&quot;,
        &quot;eslint-import-resolver-typescript&quot;: &quot;^4.4.4&quot;,
        &quot;eslint-plugin-import&quot;: &quot;^2.32.0&quot;,
        &quot;eslint-plugin-node&quot;: &quot;^11.1.0&quot;,
        &quot;eslint-plugin-unicorn&quot;: &quot;^60.0.0&quot;,
        &quot;fast-check&quot;: &quot;^4.2.0&quot;,
        &quot;typescript&quot;: &quot;^5.9.2&quot;,
        &quot;vitest&quot;: &quot;^2.1.6&quot;
    }
}
</code></pre>
    </div>

    <div class="file-section" id="readme-md">
        <div class="file-title">
            <h2>üìÑ README.md</h2>
        </div>
        <pre><code class="markdown"># Project Fusion

Project Fusion merges multiple project files into a single file for sharing and collaboration. It generates three output formats: plain text (.txt), markdown (.md), and HTML (.html) with syntax highlighting.

## Prerequisites

- **Node.js** version 18.0.0 or higher

## Installation

Install Project Fusion globally with npm:

```bash
npm install -g project-fusion
```

## Quick Start

1. **Initialize** Project Fusion in your project directory to customize settings (optional):
   ```bash
   cd your-project-directory
   project-fusion init
   ```

2. **Create fusion files** containing your project files:
   ```bash
   project-fusion
   ```
   This creates three files:
   - `project-fusioned.txt` - Plain text format with clear file separators and metadata header
   - `project-fusioned.md` - Markdown format with syntax highlighting, table of contents, and clickable navigation
   - `project-fusioned.html` - HTML format with responsive design, interactive table of contents, and styled code blocks

3. **Share the fusion files** for collaboration or analysis

## Commands

- `project-fusion` - Create fusion files from project files (default action)
- `project-fusion init` - Create Project Fusion setting file (optional) in current directory
- `project-fusion config-check` - Validate configuration and show active settings
- `project-fusion --help` - Show help information

## Documentation

- **[CLAUDE.md](./CLAUDE.md)** - AI context and technical documentation
- **[DEVELOPMENT.md](./DEVELOPMENT.md)** - Development workflows and testing
- **[CONTRIBUTING.md](./CONTRIBUTING.md)** - How to contribute to the project
- **[LICENSE](./LICENSE)** - MIT License terms

## Usage Workflow

When sharing your code:

1. Run `project-fusion` to create merged files
2. Choose the appropriate format:
   - **`.txt`** - Universal compatibility, plain text with clear file separators and metadata
   - **`.md`** - GitHub-compatible markdown with syntax highlighting and clickable table of contents
   - **`.html`** - Web-ready format with responsive design, interactive navigation, and styled code blocks
3. Share the fusion file with colleagues or collaborators
4. Use for code review, AI analysis, documentation, or project overview

The fusion files contain your project files in a single, organized format.

## Configuration

Project Fusion creates a `project-fusion.json` configuration file when you run `init`. You can customize:
- File extensions to include (organized by category: web, backend, config, etc.)
- Directories to scan or ignore
- Output file names and locations
- Use of .gitignore patterns
- Clipboard copying behavior

### Supported File Extensions

Project Fusion supports 38 file extensions organized by category:
- **Web**: .css, .html, .js, .jsx, .svelte, .ts, .tsx, .vue
- **Backend**: .cs, .go, .java, .php, .py, .rb, .rs
- **Config**: .json, .toml, .xml, .yaml, .yml
- **Scripts**: .bat, .cmd, .ps1, .sh
- **C/C++**: .c, .cc, .cpp, .h, .hpp
- **Godot**: .cfg, .cs, .gd, .import, .tscn, .tres
- **Documentation**: .adoc, .md, .rst

The markdown output applies syntax highlighting for each file type.

### Output Formats

Project Fusion generates three output formats simultaneously, each optimized for different use cases:

#### Text Format (`.txt`)
- **Purpose**: Universal compatibility for any text editor or system
- **Features**:
  - Clear file separators with descriptive headers (`&lt;!-- FILE: path/to/file.js --&gt;`)
  - Metadata header with project name, generation time, and file count
  - Raw code content without modification for maximum compatibility
  - Works with any text viewer, email, or system that supports plain text

#### Markdown Format (`.md`)
- **Purpose**: GitHub-compatible documentation with enhanced readability
- **Features**:
  - Automatic syntax highlighting based on file extensions
  - Interactive table of contents with anchor links to each file
  - Formatted headers and metadata for better visual presentation
  - Compatible with GitHub, GitLab, VS Code preview, and markdown renderers
  - Each file wrapped in appropriate code blocks (```language)

#### HTML Format (`.html`)
- **Purpose**: Web-ready sharing with professional presentation
- **Features**:
  - Responsive design for desktop and mobile devices
  - Interactive table of contents with smooth scrolling navigation
  - Styled code blocks with proper syntax highlighting
  - Professional typography and spacing for readability
  - Self-contained file with embedded CSS (no external dependencies)
  - Click-to-navigate between files with anchor links

### Format Configuration

You can control which formats are generated in your `project-fusion.json` configuration:

```json
{
  &quot;generateText&quot;: true,     // Enable .txt format
  &quot;generateMarkdown&quot;: true, // Enable .md format  
  &quot;generateHtml&quot;: true      // Enable .html format
}
```

All formats are enabled by default for flexibility.

### Performance Features

- **File Size Limiting**: Configure `maxFileSizeKB` to skip large files (default: 1MB)
- **Streaming Support**: Process large projects with reduced memory usage
- **Performance Metrics**: Benchmarks logged including throughput and memory usage
- **Filtering**: Ignores binary files, images, archives, and compiled files

### Security Features

Project Fusion implements several security measures to protect against common attack vectors:

- **Path Traversal Protection**: All file paths are validated to ensure they remain within the configured root directory, preventing `../../../etc/passwd` style attacks
- **Symbolic Link Protection**: Symbolic links are detected and blocked by default to prevent directory traversal and access to files outside the project scope
- **Binary File Detection**: Binary files are automatically detected and skipped during processing to prevent corruption and improve performance
- **XSS Prevention**: All HTML output is properly escaped to prevent cross-site scripting attacks when sharing HTML fusion files
- **File System Security**: Uses `follow: false` in glob patterns to prevent following symbolic links during file discovery
- **Safe Error Handling**: Security-related errors are logged but don&#39;t expose sensitive path information to end users

These security features are enabled by default and require no additional configuration. All security validations are tested with comprehensive security test suites.

## Programmatic API

Project Fusion can be used as a library in other Node.js projects, such as VS Code extensions or build tools.

### Installation as a Dependency

```bash
npm install project-fusion
```

### Basic Usage

```typescript
import { fusionAPI, createConfig, runFusion } from &#39;project-fusion&#39;;

// Method 1: Simple API with partial config
const result = await fusionAPI({
    rootDirectory: &#39;/path/to/project&#39;,
    generateHtml: false,
    parsedFileExtensions: {
        web: [&#39;.ts&#39;, &#39;.tsx&#39;],
        backend: [&#39;.py&#39;]
    }
});

// Method 2: Create config then run
const config = createConfig({
    generateHtml: false,
    maxFileSizeKB: 2048,
    ignorePatterns: [&#39;tests/&#39;, &#39;*.spec.ts&#39;]
});
const result = await runFusion(config);

// Method 3: Direct fusion with options
const result = await runFusion(
    { rootDirectory: &#39;/my/project&#39; },
    { extensionGroups: [&#39;web&#39;, &#39;backend&#39;] }
);
```

### VS Code Extension Example

```typescript
import * as vscode from &#39;vscode&#39;;
import { fusionAPI } from &#39;project-fusion&#39;;

export async function activate(context: vscode.ExtensionContext) {
    const disposable = vscode.commands.registerCommand(&#39;extension.fusionProject&#39;, async () =&gt; {
        const workspacePath = vscode.workspace.rootPath;
        
        if (!workspacePath) {
            vscode.window.showErrorMessage(&#39;No workspace folder open&#39;);
            return;
        }
        
        try {
            // Run fusion with dynamic config
            const result = await fusionAPI({
                rootDirectory: workspacePath,
                generateHtml: true,
                generateMarkdown: true,
                generateText: false,
                copyToClipboard: false,
                // Custom extensions for this workspace
                parsedFileExtensions: {
                    web: [&#39;.ts&#39;, &#39;.tsx&#39;, &#39;.jsx&#39;],
                    backend: [],
                    config: [&#39;.json&#39;],
                    cpp: [],
                    scripts: [],
                    godot: [],
                    doc: [&#39;.md&#39;]
                }
            });
            
            if (result.success) {
                vscode.window.showInformationMessage(`Fusion completed: ${result.filesProcessed} files processed`);
            }
        } catch (error) {
            vscode.window.showErrorMessage(`Fusion failed: ${error.message}`);
        }
    });
    
    context.subscriptions.push(disposable);
}
```

### Advanced Usage Examples

#### Building Tool Integration

```typescript
import { fusionAPI } from &#39;project-fusion&#39;;
import { readFileSync } from &#39;fs&#39;;

// Integrate with a build system
async function generateProjectDocumentation(projectPath: string) {
    const packageJson = JSON.parse(readFileSync(`${projectPath}/package.json`, &#39;utf8&#39;));
    
    const result = await fusionAPI({
        rootDirectory: projectPath,
        generatedFileName: `${packageJson.name}-docs`,
        generateText: false,        // Skip .txt for documentation
        generateMarkdown: true,     // Generate .md for GitHub
        generateHtml: true,         // Generate .html for hosting
        ignorePatterns: [
            &#39;node_modules/&#39;,
            &#39;dist/&#39;,
            &#39;*.test.*&#39;,
            &#39;coverage/&#39;
        ],
        parsedFileExtensions: {
            web: [&#39;.ts&#39;, &#39;.tsx&#39;, &#39;.js&#39;, &#39;.jsx&#39;],
            config: [&#39;.json&#39;],
            doc: [&#39;.md&#39;]
        }
    });
    
    if (result.success) {
        console.log(`Documentation generated for ${packageJson.name}`);
        return result.fusionFilePath;
    } else {
        throw new Error(`Failed to generate docs: ${result.message}`);
    }
}
```

#### CI/CD Pipeline Example

```typescript
import { runFusion } from &#39;project-fusion&#39;;

// Use in GitHub Actions or other CI systems
async function generateReleaseArtifacts() {
    const config = {
        rootDirectory: process.env.GITHUB_WORKSPACE || process.cwd(),
        generatedFileName: `release-${process.env.GITHUB_SHA?.slice(0, 7)}`,
        copyToClipboard: false,     // Disable in CI
        maxFileSizeKB: 2048,       // Allow larger files
        ignorePatterns: [
            &#39;.git/&#39;,
            &#39;node_modules/&#39;,
            &#39;*.log&#39;,
            &#39;temp/&#39;
        ]
    };
    
    const result = await runFusion(config, {
        extensionGroups: [&#39;web&#39;, &#39;backend&#39;, &#39;config&#39;, &#39;doc&#39;]
    });
    
    if (result.success) {
        // Upload to release assets or artifact storage
        console.log(`Generated release artifacts at ${result.fusionFilePath}`);
    }
    
    return result;
}
```

#### Monorepo Support

```typescript
import { fusionAPI } from &#39;project-fusion&#39;;
import { readdirSync, statSync } from &#39;fs&#39;;
import { join } from &#39;path&#39;;

// Process multiple packages in a monorepo
async function processMonorepo(monorepoPath: string) {
    const packages = readdirSync(join(monorepoPath, &#39;packages&#39;))
        .filter(dir =&gt; statSync(join(monorepoPath, &#39;packages&#39;, dir)).isDirectory());
    
    const results = await Promise.all(
        packages.map(async (packageName) =&gt; {
            const packagePath = join(monorepoPath, &#39;packages&#39;, packageName);
            
            return await fusionAPI({
                rootDirectory: packagePath,
                generatedFileName: `${packageName}-fusion`,
                generateHtml: false,
                parsedFileExtensions: {
                    web: [&#39;.ts&#39;, &#39;.tsx&#39;],
                    backend: [&#39;.js&#39;],
                    config: [&#39;.json&#39;, &#39;.yaml&#39;]
                },
                ignorePatterns: [
                    &#39;node_modules/&#39;,
                    &#39;dist/&#39;,
                    &#39;*.spec.*&#39;
                ]
            });
        })
    );
    
    const successful = results.filter(r =&gt; r.success);
    console.log(`Processed ${successful.length}/${packages.length} packages`);
    
    return results;
}
```

#### Custom File Processing

```typescript
import { createConfig, runFusion } from &#39;project-fusion&#39;;

// Create fusion for specific file types only
async function createTypescriptOnlyFusion(projectPath: string) {
    const config = createConfig({
        rootDirectory: projectPath,
        generatedFileName: &#39;typescript-only&#39;,
        generateText: true,
        generateMarkdown: false,
        generateHtml: false,
        parsedFileExtensions: {
            web: [&#39;.ts&#39;, &#39;.tsx&#39;],      // Only TypeScript files
            backend: [],               // No backend files
            config: [&#39;.json&#39;],         // Only JSON configs
            scripts: [],               // No scripts
            cpp: [],                   // No C++ files
            godot: [],                 // No Godot files
            doc: []                    // No documentation files
        },
        ignorePatterns: [
            &#39;*.test.ts&#39;,
            &#39;*.spec.ts&#39;,
            &#39;*.d.ts&#39;,                  // Skip type definitions
            &#39;node_modules/&#39;,
            &#39;dist/&#39;
        ]
    });
    
    return await runFusion(config);
}
```

### API Reference

#### `fusionAPI(options: ProgrammaticFusionOptions): Promise&lt;ProgrammaticFusionResult&gt;`
Main API function for programmatic use with partial configuration.

**Parameters:**
- `options.rootDirectory?: string` - Project root directory
- `options.extensionGroups?: string[]` - Extension groups to include
- `options.generateText?: boolean` - Enable .txt format (default: true)
- `options.generateMarkdown?: boolean` - Enable .md format (default: true)
- `options.generateHtml?: boolean` - Enable .html format (default: true)
- `options.ignorePatterns?: string[]` - Custom ignore patterns
- `options.maxFileSizeKB?: number` - Maximum file size limit

#### `createConfig(overrides: Partial&lt;Config&gt;): Config`
Creates a complete configuration object with defaults.

#### `runFusion(config: Partial&lt;Config&gt; | Config, options?: FusionOptions): Promise&lt;FusionResult&gt;`
Runs fusion with a configuration object (partial or complete).

**Returns:** Promise resolving to FusionResult with success status, file paths, and error details.

### Custom Extension Groups

You can define custom extension groups beyond the predefined categories:

```javascript
{
    parsedFileExtensions: {
        web: [&#39;.ts&#39;, &#39;.tsx&#39;, &#39;.js&#39;],
        backend: [&#39;.py&#39;, &#39;.go&#39;],
        // Add custom groups
        data: [&#39;.csv&#39;, &#39;.xlsx&#39;, &#39;.parquet&#39;],
        mobile: [&#39;.swift&#39;, &#39;.kt&#39;, &#39;.dart&#39;]
    }
}
```

## Distribution

- **GitHub**: [github.com/the99studio/project-fusion](https://github.com/the99studio/project-fusion)
- **NPM**: [npmjs.com/package/project-fusion](https://www.npmjs.com/package/project-fusion)

## License

This project is licensed under the MIT License - see the [LICENSE](./LICENSE) file for details.</code></pre>
    </div>

    <div class="file-section" id="src-adapters-file-system-ts">
        <div class="file-title">
            <h2>üìÑ src/adapters/file-system.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * File system abstraction layer for I/O operations
 */
import path from &#39;node:path&#39;;
import fs from &#39;fs-extra&#39;;
import { glob } from &#39;glob&#39;;
import { type FilePath, createFilePath } from &#39;../types.js&#39;;

export interface FileSystemStats {
    size: number;
    isDirectory: boolean;
    isFile: boolean;
    isSymbolicLink: boolean;
}

export interface FileSystemAdapter {
    readFile(filePath: FilePath): Promise&lt;string&gt;;
    writeFile(filePath: FilePath, content: string): Promise&lt;void&gt;;
    appendFile(filePath: FilePath, content: string): Promise&lt;void&gt;;
    stat(filePath: FilePath): Promise&lt;FileSystemStats&gt;;
    lstat(filePath: FilePath): Promise&lt;FileSystemStats&gt;;
    exists(filePath: FilePath): Promise&lt;boolean&gt;;
    ensureDir(dirPath: string): Promise&lt;void&gt;;
    glob(pattern: string, options?: { nodir?: boolean; follow?: boolean }): Promise&lt;FilePath[]&gt;;
    readBuffer(filePath: FilePath, options?: { encoding: null }): Promise&lt;Buffer&gt;;
}

export class DefaultFileSystemAdapter implements FileSystemAdapter {
    async readFile(filePath: FilePath): Promise&lt;string&gt; {
        return await fs.readFile(filePath, &#39;utf8&#39;);
    }

    async writeFile(filePath: FilePath, content: string): Promise&lt;void&gt; {
        await fs.writeFile(filePath, content);
    }

    async appendFile(filePath: FilePath, content: string): Promise&lt;void&gt; {
        await fs.appendFile(filePath, content);
    }

    async stat(filePath: FilePath): Promise&lt;FileSystemStats&gt; {
        const stats = await fs.stat(filePath);
        return {
            size: stats.size,
            isDirectory: stats.isDirectory(),
            isFile: stats.isFile(),
            isSymbolicLink: stats.isSymbolicLink()
        };
    }

    async lstat(filePath: FilePath): Promise&lt;FileSystemStats&gt; {
        const stats = await fs.lstat(filePath);
        return {
            size: stats.size,
            isDirectory: stats.isDirectory(),
            isFile: stats.isFile(),
            isSymbolicLink: stats.isSymbolicLink()
        };
    }

    async exists(filePath: FilePath): Promise&lt;boolean&gt; {
        return await fs.pathExists(filePath);
    }

    async ensureDir(dirPath: string): Promise&lt;void&gt; {
        await fs.ensureDir(dirPath);
    }

    async glob(pattern: string, options?: { nodir?: boolean; follow?: boolean }): Promise&lt;FilePath[]&gt; {
        const filePaths = await glob(pattern, options);
        return filePaths.map(createFilePath);
    }

    async readBuffer(filePath: FilePath, options?: { encoding: null }): Promise&lt;Buffer&gt; {
        return await fs.readFile(filePath, options);
    }
}

export class MemoryFileSystemAdapter implements FileSystemAdapter {
    private readonly files: Map&lt;string, string&gt; = new Map();
    private readonly directories: Set&lt;string&gt; = new Set();

    readFile(filePath: FilePath): Promise&lt;string&gt; {
        const content = this.files.get(filePath);
        if (content === undefined) {
            return Promise.reject(new Error(`File not found: ${filePath}`));
        }
        return Promise.resolve(content);
    }

    writeFile(filePath: FilePath, content: string): Promise&lt;void&gt; {
        const dir = path.dirname(filePath);
        this.directories.add(dir);
        this.files.set(filePath, content);
        return Promise.resolve();
    }

    async appendFile(filePath: FilePath, content: string): Promise&lt;void&gt; {
        const existing = this.files.get(filePath) ?? &#39;&#39;;
        await this.writeFile(filePath, existing + content);
    }

    stat(filePath: FilePath): Promise&lt;FileSystemStats&gt; {
        if (this.files.has(filePath)) {
            const content = this.files.get(filePath)!;
            return Promise.resolve({
                size: Buffer.byteLength(content, &#39;utf8&#39;),
                isDirectory: false,
                isFile: true,
                isSymbolicLink: false
            });
        }
        if (this.directories.has(filePath)) {
            return Promise.resolve({
                size: 0,
                isDirectory: true,
                isFile: false,
                isSymbolicLink: false
            });
        }
        return Promise.reject(new Error(`File not found: ${filePath}`));
    }

    async lstat(filePath: FilePath): Promise&lt;FileSystemStats&gt; {
        return this.stat(filePath);
    }

    exists(filePath: FilePath): Promise&lt;boolean&gt; {
        return Promise.resolve(this.files.has(filePath) || this.directories.has(filePath));
    }

    ensureDir(dirPath: string): Promise&lt;void&gt; {
        this.directories.add(dirPath);
        return Promise.resolve();
    }

    glob(pattern: string, options?: { nodir?: boolean; follow?: boolean }): Promise&lt;FilePath[]&gt; {
        const allPaths = [...this.files.keys(), ...this.directories.keys()];
        const result = allPaths
            .filter(p =&gt; {
                if (options?.nodir &amp;&amp; this.directories.has(p)) return false;
                return true;
            })
            .map(createFilePath);
        return Promise.resolve(result);
    }

    async readBuffer(filePath: FilePath): Promise&lt;Buffer&gt; {
        const content = await this.readFile(filePath);
        return Buffer.from(content, &#39;utf8&#39;);
    }

    addFile(filePath: string, content: string): void {
        this.files.set(filePath, content);
        const dir = path.dirname(filePath);
        this.ensureParentDirectory(dir);
        this.directories.add(dir);
    }

    private ensureParentDirectory(dirPath: string): void {
        const parent = path.dirname(dirPath);
        if (parent &amp;&amp; parent !== dirPath &amp;&amp; parent !== &#39;.&#39;) {
            this.ensureParentDirectory(parent);
            this.directories.add(parent);
        }
    }

    getFiles(): Map&lt;string, string&gt; {
        return new Map(this.files);
    }

    clear(): void {
        this.files.clear();
        this.directories.clear();
    }
}</code></pre>
    </div>

    <div class="file-section" id="src-api-ts">
        <div class="file-title">
            <h2>üìÑ src/api.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Programmatic API for Project Fusion
 * Allows external packages to use fusion functionality without config files
 */
import path from &#39;node:path&#39;;

import { processFusion } from &#39;./fusion.js&#39;;
import type { Config, FilePath, FusionOptions, FusionResult } from &#39;./types.js&#39;;
import { defaultConfig } from &#39;./utils.js&#39;;

/**
 * Options for programmatic fusion
 */
export interface ProgrammaticFusionOptions extends Partial&lt;Config&gt; {
    /** Working directory (defaults to process.cwd()) */
    cwd?: string;
    /** Extension groups to include */
    extensionGroups?: string[];
    /** Root directory override */
    rootDir?: string;
}

/**
 * Result from programmatic fusion
 */
export interface ProgrammaticFusionResult {
    /** Error object (if failed) */
    error?: Error | undefined;
    /** Number of files processed (if successful) */
    filesProcessed?: number;
    /** Path to the fusion file (if successful) */
    fusionFilePath?: FilePath;
    /** Path to the log file */
    logFilePath?: FilePath;
    /** Status message */
    message: string;
    /** Whether the fusion was successful */
    success: boolean;
}

/**
 * Merge partial config with defaults
 * @param partialConfig Partial configuration to merge
 * @param cwd Current working directory
 * @returns Complete configuration
 */
function mergeWithDefaults(partialConfig: Partial&lt;Config&gt;, cwd: string): Config {
    const rootDirectory = partialConfig.rootDirectory ?? cwd;
    
    return {
        copyToClipboard: partialConfig.copyToClipboard ?? defaultConfig.copyToClipboard,
        generatedFileName: partialConfig.generatedFileName ?? defaultConfig.generatedFileName,
        generateHtml: partialConfig.generateHtml ?? defaultConfig.generateHtml,
        generateMarkdown: partialConfig.generateMarkdown ?? defaultConfig.generateMarkdown,
        generateText: partialConfig.generateText ?? defaultConfig.generateText,
        ignorePatterns: partialConfig.ignorePatterns ?? defaultConfig.ignorePatterns,
        maxFileSizeKB: partialConfig.maxFileSizeKB ?? defaultConfig.maxFileSizeKB,
        parsedFileExtensions: partialConfig.parsedFileExtensions ?? defaultConfig.parsedFileExtensions,
        parseSubDirectories: partialConfig.parseSubDirectories ?? defaultConfig.parseSubDirectories,
        rootDirectory,
        schemaVersion: 1,
        useGitIgnoreForExcludes: partialConfig.useGitIgnoreForExcludes ?? defaultConfig.useGitIgnoreForExcludes
    };
}

/**
 * Process fusion programmatically without requiring a config file
 * @param options Options for fusion including partial config
 * @returns Fusion result with optional file contents
 * 
 * @example
 * ```typescript
 * import { fusionAPI } from &#39;project-fusion&#39;;
 * 
 * // Use with custom configuration
 * const result = await fusionAPI({
 *     rootDirectory: &#39;/path/to/project&#39;,
 *     generateHtml: false,
 *     parsedFileExtensions: {
 *         web: [&#39;.ts&#39;, &#39;.tsx&#39;],
 *         backend: [&#39;.py&#39;]
 *     },
 *     ignorePatterns: [&#39;tests/&#39;, &#39;*.spec.ts&#39;]
 * });
 * ```
 */
export async function fusionAPI(options: ProgrammaticFusionOptions = {}): Promise&lt;ProgrammaticFusionResult&gt; {
    const cwd = options.cwd ?? process.cwd();
    
    // Extract fusion options
    const { 
        extensionGroups,
        rootDir,
        ...configOptions 
    } = options;
    
    // Build complete configuration
    const config = mergeWithDefaults(configOptions, cwd);
    
    // Override rootDirectory if rootDir is provided in fusion options
    if (rootDir) {
        config.rootDirectory = path.resolve(cwd, rootDir);
    }
    
    // Process fusion with the merged configuration
    const fusionOptions: FusionOptions = extensionGroups 
        ? { extensionGroups }
        : {};
    
    const result = await processFusion(config, fusionOptions);
    
    // Convert FusionResult to ProgrammaticFusionResult
    if (result.success) {
        return {
            fusionFilePath: result.fusionFilePath,
            logFilePath: result.logFilePath,
            message: result.message,
            success: true
        };
    } else {
        const errorResult: ProgrammaticFusionResult = {
            message: result.message,
            success: false
        };
        if (result.logFilePath) {
            errorResult.logFilePath = result.logFilePath;
        }
        if (result.error) {
            errorResult.error = result.error;
        }
        return errorResult;
    }
}

/**
 * Create a custom configuration object for programmatic use
 * @param overrides Configuration overrides
 * @returns Complete configuration object
 * 
 * @example
 * ```typescript
 * import { createConfig, processFusion } from &#39;project-fusion&#39;;
 * 
 * const config = createConfig({
 *     generateHtml: false,
 *     maxFileSizeKB: 2048
 * });
 * 
 * const result = await processFusion(config);
 * ```
 */
export function createConfig(overrides: Partial&lt;Config&gt; = {}): Config {
    return mergeWithDefaults(overrides, process.cwd());
}

/**
 * Programmatically run fusion with a specific configuration
 * Useful for VS Code extensions and other integrations
 * 
 * @param config Complete or partial configuration
 * @param options Additional fusion options
 * @returns Fusion result
 * 
 * @example
 * ```typescript
 * import { runFusion } from &#39;project-fusion&#39;;
 * 
 * // With partial config (uses defaults for missing values)
 * const result = await runFusion({
 *     rootDirectory: &#39;/my/project&#39;,
 *     generateHtml: false
 * });
 * 
 * // With extension group filter
 * const result = await runFusion(
 *     { rootDirectory: &#39;/my/project&#39; },
 *     { extensionGroups: [&#39;web&#39;, &#39;backend&#39;] }
 * );
 * ```
 */
export async function runFusion(
    config: Partial&lt;Config&gt; | Config,
    options: FusionOptions = {}
): Promise&lt;FusionResult&gt; {
    // Check if config has all required fields
    const isCompleteConfig = (
        &#39;schemaVersion&#39; in config &amp;&amp;
        &#39;rootDirectory&#39; in config &amp;&amp;
        &#39;parsedFileExtensions&#39; in config
    );
    
    const fullConfig = isCompleteConfig 
        ? config as Config
        : mergeWithDefaults(config, config.rootDirectory ?? process.cwd());
    
    return await processFusion(fullConfig, options);
}</code></pre>
    </div>

    <div class="file-section" id="src-benchmark-ts">
        <div class="file-title">
            <h2>üìÑ src/benchmark.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Benchmark utilities for performance monitoring
 */
import process from &#39;node:process&#39;;

export interface BenchmarkMetrics {
    averageFileProcessingTime: number;
    duration: number;
    filesProcessed: number;
    memoryUsed: number;
    memoryUsedMB: number;
    processingTimeMs: number;
    throughputBytesPerSec: number;
    throughputMBps: number;
    totalBytesProcessed: number;
    totalSizeMB: number;
}

export class BenchmarkTracker {
    private readonly startTime: number;
    private readonly startMemory: NodeJS.MemoryUsage;
    private readonly fileTimings: number[] = [];
    private filesProcessed = 0;
    private totalBytes = 0;

    constructor() {
        this.startTime = Date.now();
        this.startMemory = process.memoryUsage();
    }

    /**
     * Record file processing metrics
     */
    markFileProcessed(sizeBytes: number, processingTimeMs?: number): void {
        this.filesProcessed++;
        this.totalBytes += sizeBytes;
        if (processingTimeMs !== undefined) {
            this.fileTimings.push(processingTimeMs);
        }
    }


    /**
     * Calculate and return performance metrics
     */
    getMetrics(): BenchmarkMetrics {
        const endTime = Date.now();
        const endMemory = process.memoryUsage();
        
        const processingTimeMs = endTime - this.startTime; // milliseconds
        const duration = processingTimeMs / 1000; // seconds
        const memoryUsed = (endMemory.heapUsed - this.startMemory.heapUsed) / (1024 * 1024); // MB
        const memoryUsedMB = endMemory.heapUsed / (1024 * 1024); // MB - current memory usage
        const totalSizeMB = this.totalBytes / (1024 * 1024);
        
        const averageFileProcessingTime = this.fileTimings.length &gt; 0
            ? this.fileTimings.reduce((a, b) =&gt; a + b, 0) / this.fileTimings.length
            : 0;
        
        const throughputMBps = duration &gt; 0 ? totalSizeMB / duration : 0;
        const throughputBytesPerSec = duration &gt; 0 ? this.totalBytes / duration : 0;

        return {
            duration,
            memoryUsed,
            memoryUsedMB,
            processingTimeMs,
            filesProcessed: this.filesProcessed,
            totalBytesProcessed: this.totalBytes,
            totalSizeMB,
            averageFileProcessingTime,
            throughputMBps,
            throughputBytesPerSec
        };
    }


}</code></pre>
    </div>

    <div class="file-section" id="src-cli-ts">
        <div class="file-title">
            <h2>üìÑ src/cli.ts</h2>
        </div>
        <pre><code class="typescript">#!/usr/bin/env node
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Command-line interface for Project Fusion
 */
import { Command } from &#39;commander&#39;;

import pkg from &#39;../package.json&#39; with { type: &#39;json&#39; };

import {
    runConfigCheckCommand,
    runFusionCommand,
    runInitCommand
} from &#39;./clicommands.js&#39;;

const program = new Command();

program
    .name(&#39;project-fusion&#39;)
    .description(&#39;Project Fusion - Efficient project file management and sharing&#39;)
    .version(pkg.version, &#39;-v, --version&#39;)
    .allowUnknownOption(false)
    .showHelpAfterError(true);

// Default command (fusion) - runs when no subcommand is specified
program
    .option(&#39;--extensions &lt;groups&gt;&#39;, &#39;Comma-separated list of extension groups (e.g., backend,web)&#39;)
    .option(&#39;--root &lt;directory&gt;&#39;, &#39;Root directory to start scanning from (defaults to current directory)&#39;)
    .action((options: { extensions?: string; root?: string }) =&gt; {
        // Default action is to run fusion
        void runFusionCommand(options);
    });


// Init command
program
    .command(&#39;init&#39;)
    .description(&#39;Initialize Project Fusion in the current directory&#39;)
    .option(&#39;--force&#39;, &#39;Force initialization even if configuration already exists&#39;)
    .action((options: { force?: boolean }) =&gt; {
        void runInitCommand(options);
    });

// Config check command
program
    .command(&#39;config-check&#39;)
    .description(&#39;Validate project-fusion.json and display active groups/extensions&#39;)
    .action(() =&gt; {
        void runConfigCheckCommand();
    });

// Parse arguments with Commander.js
program.parse(process.argv);</code></pre>
    </div>

    <div class="file-section" id="src-clicommands-ts">
        <div class="file-title">
            <h2>üìÑ src/clicommands.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * CLI commands implementation
 */
import path from &#39;node:path&#39;;

import chalk from &#39;chalk&#39;;
import clipboardy from &#39;clipboardy&#39;;
import fs from &#39;fs-extra&#39;;

import { processFusion } from &#39;./fusion.js&#39;;
import { ConfigSchemaV1 } from &#39;./schema.js&#39;;
import type { Config, FusionOptions } from &#39;./types.js&#39;;
import { defaultConfig, getExtensionsFromGroups, loadConfig } from &#39;./utils.js&#39;;

/**
 * Run the fusion command
 * @param options Command options
 */
export async function runFusionCommand(options: { extensions?: string, root?: string }): Promise&lt;void&gt; {
    try {
        console.log(chalk.blue(&#39;üîÑ Starting Fusion Process...&#39;));

        const config = await loadConfig();

        if (options.root) {
            config.rootDirectory = options.root;
            console.log(chalk.yellow(`‚ÑπÔ∏è Using specified directory as root: ${options.root}`));
        }

        // Parse extension groups from command line (comma-separated)
        let extensionGroups: string[] | undefined;
        if (options.extensions) {
            extensionGroups = options.extensions.split(&#39;,&#39;).map(e =&gt; e.trim());
            console.log(chalk.blue(`Using extension groups: ${extensionGroups.join(&#39;, &#39;)}`));
        }

        const fusionOptions: FusionOptions = extensionGroups ? { extensionGroups } : {};
        const result = await processFusion(config, fusionOptions);

        if (result.success) {
            console.log(chalk.green(`‚úÖ ${result.message}`));
            console.log(chalk.green(`üìÑ Generated files:`));
            
            if (config.generateText) {
                console.log(chalk.cyan(`   - ${config.generatedFileName}.txt`));
            }
            if (config.generateMarkdown) {
                console.log(chalk.cyan(`   - ${config.generatedFileName}.md`));
            }
            if (config.generateHtml) {
                console.log(chalk.cyan(`   - ${config.generatedFileName}.html`));
            }

            // Copy fusion content to clipboard if enabled (skip in CI/non-interactive environments)
            const isNonInteractive = process.env[&#39;CI&#39;] === &#39;true&#39; || !process.stdout.isTTY;
            if (config.copyToClipboard === true &amp;&amp; result.fusionFilePath &amp;&amp; !isNonInteractive) {
                try {
                    const fusionContent = await fs.readFile(result.fusionFilePath, &#39;utf8&#39;);
                    await clipboardy.write(fusionContent);
                    console.log(chalk.blue(`üìã Fusion content copied to clipboard`));
                } catch (clipboardError) {
                    console.warn(chalk.yellow(`‚ö†Ô∏è Could not copy to clipboard: ${String(clipboardError)}`));
                }
            } else if (config.copyToClipboard === true &amp;&amp; isNonInteractive) {
                console.log(chalk.gray(`üìã Clipboard copy skipped (non-interactive environment)`));
            }

            console.log(chalk.gray(`üìù Log file available at: ${result.logFilePath}`));
        } else {
            console.log(chalk.red(`‚ùå ${result.message}`));
            if (result.logFilePath) {
                console.log(chalk.gray(`üìù Check log file for details: ${result.logFilePath}`));
            }
        }
    } catch (error) {
        console.error(chalk.red(`‚ùå Fusion process failed: ${String(error)}`));
        process.exit(1);
    }
}


/**
 * Run the init command to initialize the config
 */
export async function runInitCommand(options: { force?: boolean } = {}): Promise&lt;void&gt; {
    try {
        console.log(chalk.blue(&#39;üîÑ Initializing Project Fusion...&#39;));

        const configPath = path.resolve(&#39;./project-fusion.json&#39;);
        if (await fs.pathExists(configPath)) {
            if (!options.force) {
                console.log(chalk.yellow(&#39;‚ö†Ô∏è project-fusion.json file already exists.&#39;));
                console.log(chalk.yellow(&#39;Use --force to override or delete project-fusion.json and run init again.&#39;));
                process.exit(1);
            } else {
                console.log(chalk.yellow(&#39;‚ö†Ô∏è Overriding existing configuration file with --force option.&#39;));
            }
        }

        await fs.writeJson(configPath, defaultConfig, { spaces: 4 });

        console.log(chalk.green(&#39;‚úÖ Project Fusion initialized successfully!&#39;));
        console.log(chalk.blue(&#39;üìÅ Created:&#39;));
        console.log(chalk.cyan(&#39;  - ./project-fusion.json&#39;));

        console.log(chalk.blue(&#39;\nüìù Next steps:&#39;));
        console.log(chalk.cyan(&#39;  1. Review project-fusion.json and adjust as needed&#39;));
        console.log(chalk.cyan(&#39;  2. Run fusion: project-fusion&#39;));
    } catch (error) {
        console.error(chalk.red(`‚ùå Initialization failed: ${String(error)}`));
        process.exit(1);
    }
}

/**
 * Run the config-check command to validate configuration
 */
export async function runConfigCheckCommand(): Promise&lt;void&gt; {
    try {
        console.log(chalk.blue(&#39;üîç Checking Project Fusion Configuration...&#39;));

        const configPath = path.resolve(&#39;./project-fusion.json&#39;);
        
        // Verify configuration file exists
        if (!await fs.pathExists(configPath)) {
            console.log(chalk.yellow(&#39;‚ö†Ô∏è No project-fusion.json found.&#39;));
            console.log(chalk.cyan(&#39;   Using default configuration.&#39;));
            console.log(chalk.gray(&#39;   Run &quot;project-fusion init&quot; to create a configuration file.&#39;));
            
            await displayConfigInfo(defaultConfig, true);
            return;
        }

        // Load and parse configuration
        let configContent: string;
        try {
            configContent = await fs.readFile(configPath, &#39;utf8&#39;);
        } catch (error) {
            console.log(chalk.red(`‚ùå Cannot read configuration file: ${String(error)}`));
            process.exit(1);
        }

        let parsedConfig: unknown;
        try {
            parsedConfig = JSON.parse(configContent);
        } catch (error) {
            console.log(chalk.red(`‚ùå Invalid JSON in configuration file: ${String(error)}`));
            process.exit(1);
        }

        // Validate configuration against schema
        const validation = ConfigSchemaV1.safeParse(parsedConfig);
        
        if (!validation.success) {
            console.log(chalk.red(&#39;‚ùå Configuration validation failed:&#39;));
            
            // Show detailed validation errors
            // Display detailed validation errors with helpful context
            for (const [index, issue] of validation.error.issues.entries()) {
                const path = issue.path.length &gt; 0 ? issue.path.join(&#39;.&#39;) : &#39;root&#39;;
                 
                const value = issue.path.reduce((obj: unknown, key) =&gt; {
                    if (typeof key === &#39;string&#39; &amp;&amp; obj &amp;&amp; typeof obj === &#39;object&#39;) {
                        return (obj as Record&lt;string, unknown&gt;)[key];
                    }
                    return undefined;
                }, parsedConfig);
                console.log(chalk.red(`   ${index + 1}. Path: ${chalk.yellow(path)}`));
                console.log(chalk.red(`      Error: ${issue.message}`));
                console.log(chalk.red(`      Current value: ${chalk.cyan(JSON.stringify(value))}`));
                if (issue.code === &#39;invalid_type&#39;) {
                     
                    console.log(chalk.red(`      Expected: ${chalk.green(String((issue as unknown as Record&lt;string, unknown&gt;)[&#39;expected&#39;]))}, received: ${chalk.magenta(String((issue as unknown as Record&lt;string, unknown&gt;)[&#39;received&#39;]))}`));
                }
            }
            
            console.log(chalk.yellow(&#39;\nüí° Suggestions:&#39;));
            console.log(chalk.cyan(&#39;   - Check your configuration against the schema&#39;));
            console.log(chalk.cyan(&#39;   - Run &quot;project-fusion init --force&quot; to reset to default config&#39;));
            process.exit(1);
        }

        console.log(chalk.green(&#39;‚úÖ Configuration is valid!&#39;));
        await displayConfigInfo(validation.data, false);

    } catch (error) {
        console.error(chalk.red(`‚ùå Config check failed: ${String(error)}`));
        process.exit(1);
    }
}

/**
 * Display comprehensive configuration summary with preview
 */
async function displayConfigInfo(config: Config, isDefault: boolean): Promise&lt;void&gt; {
    console.log(chalk.blue(&#39;\nüìã Configuration Summary:&#39;));
    
    if (isDefault) {
        console.log(chalk.gray(&#39;   (Using default configuration)\n&#39;));
    } else {
        console.log(&#39;&#39;);
    }

    // Core configuration settings
    console.log(chalk.cyan(&#39;üîß Basic Settings:&#39;));
    console.log(`   Schema Version: ${config.schemaVersion}`);
    console.log(`   Root Directory: ${config.rootDirectory}`);
    console.log(`   Scan Subdirectories: ${config.parseSubDirectories ? &#39;Yes&#39; : &#39;No&#39;}`);
    console.log(`   Use .gitignore: ${config.useGitIgnoreForExcludes ? &#39;Yes&#39; : &#39;No&#39;}`);
    console.log(`   Copy to Clipboard: ${config.copyToClipboard ? &#39;Yes&#39; : &#39;No&#39;}`);
    console.log(`   Max File Size: ${config.maxFileSizeKB} KB`);

    // File generation options
    console.log(chalk.cyan(&#39;\nüìÑ Output Generation:&#39;));
    console.log(`   Generated File Name: ${config.generatedFileName}`);
    console.log(`   Generate Text: ${config.generateText ? &#39;Yes&#39; : &#39;No&#39;}`);
    console.log(`   Generate Markdown: ${config.generateMarkdown ? &#39;Yes&#39; : &#39;No&#39;}`);
    console.log(`   Generate HTML: ${config.generateHtml ? &#39;Yes&#39; : &#39;No&#39;}`);
    console.log(`   Log File: project-fusion.log`);

    // File type configuration
    console.log(chalk.cyan(&#39;\nüìÅ File Extension Groups:&#39;));
    const totalExtensions = getExtensionsFromGroups(config);
    
    for (const [group, extensions] of Object.entries(config.parsedFileExtensions)) {
        if (extensions) {
            console.log(`   ${group}: ${extensions.length} extensions (${extensions.join(&#39;, &#39;)})`);
        }
    }
    
    console.log(chalk.gray(`   Total: ${totalExtensions.length} unique extensions`));

    // Pattern exclusions
    console.log(chalk.cyan(&#39;\nüö´ Ignore Patterns:&#39;));
    if (config.ignorePatterns.length === 0) {
        console.log(&#39;   None defined&#39;);
    } else {
        for (const pattern of config.ignorePatterns.slice(0, 10)) {
            console.log(`   ${pattern}`);
        }
        if (config.ignorePatterns.length &gt; 10) {
            console.log(chalk.gray(`   ... and ${config.ignorePatterns.length - 10} more`));
        }
    }

    // Preview matching files using current configuration
    console.log(chalk.cyan(&#39;\nüîç File Discovery Preview:&#39;));
    try {
        const { glob } = await import(&#39;glob&#39;);
        const rootDir = path.resolve(config.rootDirectory);
        
        // Create glob pattern to preview file discovery
        const allExtensionsPattern = totalExtensions.map(ext =&gt; ext.startsWith(&#39;.&#39;) ? ext : `.${ext}`);
        const pattern = config.parseSubDirectories
            ? `${rootDir}/**/*@(${allExtensionsPattern.join(&#39;|&#39;)})` // Recursive search
            : `${rootDir}/*@(${allExtensionsPattern.join(&#39;|&#39;)})`; // Root-only search

        const filePaths = await glob(pattern, { 
            nodir: true,
            follow: false
        });

        console.log(`   Pattern: ${pattern}`);
        console.log(`   Files found: ${filePaths.length}`);
        
        if (filePaths.length &gt; 0) {
            console.log(`   Sample files:`);
            for (const file of filePaths.slice(0, 5)) {
                const relativePath = path.relative(rootDir, file);
                console.log(`     ${relativePath}`);
            }
            if (filePaths.length &gt; 5) {
                console.log(chalk.gray(`     ... and ${filePaths.length - 5} more`));
            }
        }
    } catch (error) {
        console.log(chalk.yellow(`   Could not preview files: ${String(error)}`));
    }
}</code></pre>
    </div>

    <div class="file-section" id="src-fluent-ts">
        <div class="file-title">
            <h2>üìÑ src/fluent.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Fluent API for Project Fusion
 * Provides a chainable interface for better developer experience
 */
import { fusionAPI, type ProgrammaticFusionOptions, type ProgrammaticFusionResult } from &#39;./api.js&#39;;
import type { Config } from &#39;./types.js&#39;;
import { defaultConfig } from &#39;./utils.js&#39;;

/**
 * Fluent API builder for Project Fusion
 * 
 * @example
 * ```typescript
 * import { projectFusion } from &#39;project-fusion&#39;;
 * 
 * const result = await projectFusion()
 *   .include([&#39;web&#39;, &#39;backend&#39;])
 *   .exclude([&#39;*.test.ts&#39;, &#39;node_modules&#39;])
 *   .maxSize(&#39;2MB&#39;)
 *   .output([&#39;md&#39;, &#39;html&#39;])
 *   .generate();
 * ```
 */
export class ProjectFusionBuilder {
    private options: ProgrammaticFusionOptions = {};

    /**
     * Set the root directory to scan
     * @param path Root directory path
     */
    root(path: string): this {
        this.options.rootDirectory = path;
        return this;
    }

    /**
     * Set the working directory
     * @param path Working directory path
     */
    cwd(path: string): this {
        this.options.cwd = path;
        return this;
    }

    /**
     * Include specific extension groups
     * @param groups Array of extension group names (e.g., [&#39;web&#39;, &#39;backend&#39;])
     */
    include(groups: string[]): this {
        this.options.extensionGroups = groups;
        return this;
    }

    /**
     * Add ignore patterns
     * @param patterns Array of glob patterns to ignore
     */
    exclude(patterns: string[]): this {
        this.options.ignorePatterns = patterns;
        return this;
    }

    /**
     * Set maximum file size limit
     * @param size Size limit as string (e.g., &#39;1MB&#39;, &#39;512KB&#39;) or number in KB
     */
    maxSize(size: string | number): this {
        if (typeof size === &#39;string&#39;) {
            const match = size.match(/^(\d+(?:\.\d+)?)\s*(KB|MB|GB)?$/i);
            if (!match) {
                throw new Error(`Invalid size format: ${size}. Use format like &quot;1MB&quot;, &quot;512KB&quot;, or number in KB`);
            }
            
            const value = parseFloat(match[1] || &#39;0&#39;);
            const unit = (match[2] || &#39;KB&#39;).toUpperCase();
            
            const multipliers = { KB: 1, MB: 1024, GB: 1024 * 1024 };
            this.options.maxFileSizeKB = value * (multipliers[unit as keyof typeof multipliers] || 1);
        } else {
            this.options.maxFileSizeKB = size;
        }
        return this;
    }

    /**
     * Set output formats to generate
     * @param formats Array of format names (&#39;text&#39;, &#39;md&#39;, &#39;html&#39;)
     */
    output(formats: Array&lt;&#39;text&#39; | &#39;md&#39; | &#39;html&#39;&gt;): this {
        this.options.generateText = formats.includes(&#39;text&#39;);
        this.options.generateMarkdown = formats.includes(&#39;md&#39;);
        this.options.generateHtml = formats.includes(&#39;html&#39;);
        return this;
    }

    /**
     * Set the generated file name (without extension)
     * @param name Base name for generated files
     */
    name(name: string): this {
        this.options.generatedFileName = name;
        return this;
    }

    /**
     * Enable or disable subdirectory parsing
     * @param enabled Whether to parse subdirectories
     */
    subdirectories(enabled: boolean = true): this {
        this.options.parseSubDirectories = enabled;
        return this;
    }

    /**
     * Enable or disable clipboard copying
     * @param enabled Whether to copy result to clipboard
     */
    clipboard(enabled: boolean = true): this {
        this.options.copyToClipboard = enabled;
        return this;
    }

    /**
     * Enable or disable .gitignore usage
     * @param enabled Whether to use .gitignore for exclusions
     */
    gitignore(enabled: boolean = true): this {
        this.options.useGitIgnoreForExcludes = enabled;
        return this;
    }

    /**
     * Add custom file extensions for a specific group
     * @param group Extension group name (e.g., &#39;web&#39;, &#39;backend&#39;)
     * @param extensions Array of extensions (e.g., [&#39;.ts&#39;, &#39;.tsx&#39;])
     */
    extensions(group: string, extensions: string[]): this {
        if (!this.options.parsedFileExtensions) {
            this.options.parsedFileExtensions = { ...defaultConfig.parsedFileExtensions };
        }
        this.options.parsedFileExtensions[group] = extensions;
        return this;
    }

    /**
     * Set complete extension configuration
     * @param config Extension configuration object
     */
    allExtensions(config: Config[&#39;parsedFileExtensions&#39;]): this {
        this.options.parsedFileExtensions = config;
        return this;
    }

    /**
     * Apply a custom configuration function
     * @param configFn Function that receives and modifies options
     */
    configure(configFn: (options: ProgrammaticFusionOptions) =&gt; void): this {
        configFn(this.options);
        return this;
    }

    /**
     * Generate fusion files with the configured options
     * @returns Promise resolving to fusion result
     */
    async generate(): Promise&lt;ProgrammaticFusionResult&gt; {
        return await fusionAPI(this.options);
    }

    /**
     * Get the current configuration without generating
     * @returns Current configuration options
     */
    getConfig(): ProgrammaticFusionOptions {
        return { ...this.options };
    }

    /**
     * Reset the builder to default state
     */
    reset(): this {
        this.options = {};
        return this;
    }
}

/**
 * Create a new Project Fusion builder instance
 * 
 * @example
 * ```typescript
 * import { projectFusion } from &#39;project-fusion&#39;;
 * 
 * // Basic usage
 * const result = await projectFusion()
 *   .include([&#39;web&#39;])
 *   .generate();
 * 
 * // Advanced configuration
 * const result = await projectFusion()
 *   .root(&#39;./src&#39;)
 *   .include([&#39;web&#39;, &#39;backend&#39;])
 *   .exclude([&#39;*.test.ts&#39;, &#39;node_modules/&#39;, &#39;__tests__/&#39;])
 *   .maxSize(&#39;2MB&#39;)
 *   .output([&#39;md&#39;, &#39;html&#39;])
 *   .name(&#39;my-project-fusion&#39;)
 *   .clipboard(false)
 *   .generate();
 * ```
 */
export function projectFusion(): ProjectFusionBuilder {
    return new ProjectFusionBuilder();
}</code></pre>
    </div>

    <div class="file-section" id="src-fusion-ts">
        <div class="file-title">
            <h2>üìÑ src/fusion.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Fusion functionality - Refactored with new architecture patterns
 */
import path from &#39;node:path&#39;;

import ignoreLib from &#39;ignore&#39;;

import { type FileSystemAdapter, DefaultFileSystemAdapter } from &#39;./adapters/file-system.js&#39;;
import { BenchmarkTracker } from &#39;./benchmark.js&#39;;
import { PluginManager } from &#39;./plugins/plugin-system.js&#39;;
import { 
    type FileInfo, 
    type OutputContext,
    OutputStrategyManager
} from &#39;./strategies/output-strategy.js&#39;;
import { type Config, type FilePath, type FusionOptions, type FusionResult, createFilePath } from &#39;./types.js&#39;;
import {
    formatLocalTimestamp,
    formatTimestamp,
    getExtensionsFromGroups,
    isBinaryFile,
    validateNoSymlinks,
    validateSecurePath,
    writeLog
} from &#39;./utils.js&#39;;

export async function processFusion(
    config: Config,
    options: FusionOptions = {}
): Promise&lt;FusionResult&gt; {
    const benchmark = new BenchmarkTracker();
    const fs = options.fs || new DefaultFileSystemAdapter();
    const outputManager = new OutputStrategyManager();
    const pluginManager = new PluginManager(fs);

    try {
        const logFilePath = createFilePath(path.resolve(config.rootDirectory, `${config.generatedFileName}.log`));
        const startTime = new Date();

        await fs.writeFile(logFilePath, &#39;&#39;);

        if (options.pluginsDir) {
            await pluginManager.loadPluginsFromDirectory(options.pluginsDir);
        }

        if (options.enabledPlugins) {
            for (const pluginName of options.enabledPlugins) {
                pluginManager.configurePlugin(pluginName, { name: pluginName, enabled: true });
            }
        }

        await pluginManager.initializePlugins(config);

        const additionalStrategies = pluginManager.getAdditionalOutputStrategies();
        for (const strategy of additionalStrategies) {
            outputManager.registerStrategy(strategy);
        }

        const additionalExtensions = pluginManager.getAdditionalFileExtensions();
        const mergedConfig = {
            ...config,
            parsedFileExtensions: {
                ...config.parsedFileExtensions,
                ...additionalExtensions
            }
        };

        const extensions = getExtensionsFromGroups(mergedConfig, options.extensionGroups);
        console.log(`Processing ${extensions.length} file extensions from ${Object.keys(mergedConfig.parsedFileExtensions).length} categories`);
        
        if (extensions.length === 0) {
            const message = &#39;No file extensions to process.&#39;;
            await writeLog(logFilePath, `Status: Fusion failed\nReason: ${message}`, true);
            return { success: false, message, logFilePath };
        }

        const ig = ignoreLib();
        const rootDir = path.resolve(config.rootDirectory);

        if (config.useGitIgnoreForExcludes) {
            const gitIgnorePath = path.join(rootDir, &#39;.gitignore&#39;);
            if (await fs.exists(createFilePath(gitIgnorePath))) {
                const gitIgnoreContent = await fs.readFile(createFilePath(gitIgnorePath));
                ig.add(gitIgnoreContent);
            }
        }

        if (config.ignorePatterns.length &gt; 0) {
            const patterns = config.ignorePatterns
                .filter(pattern =&gt; pattern.trim() !== &#39;&#39; &amp;&amp; !pattern.startsWith(&#39;#&#39;))
                .join(&#39;\n&#39;);
            ig.add(patterns);
        }

        const allExtensionsPattern = extensions.map(ext =&gt; ext.startsWith(&#39;.&#39;) ? ext : `.${ext}`);
        const pattern = config.parseSubDirectories
            ? `${rootDir}/**/*@(${allExtensionsPattern.join(&#39;|&#39;)})`
            : `${rootDir}/*@(${allExtensionsPattern.join(&#39;|&#39;)})`;

        let filePaths = await fs.glob(pattern, { 
            nodir: true,
            follow: false
        });

        const originalFileCount = filePaths.length;
        filePaths = filePaths.filter(file =&gt; {
            const relativePath = path.relative(rootDir, file);
            return !ig.ignores(relativePath);
        });

        console.log(`Found ${originalFileCount} files, ${filePaths.length} after filtering (${((originalFileCount - filePaths.length) / originalFileCount * 100).toFixed(1)}% filtered)`);

        if (filePaths.length === 0) {
            const message = &#39;No files found to process.&#39;;
            const endTime = new Date();
            await writeLog(logFilePath, `Status: Fusion failed\nReason: ${message}\nStart time: ${formatTimestamp(startTime)}\nEnd time: ${formatTimestamp(endTime)}\nDuration: ${((endTime.getTime() - startTime.getTime()) / 1000).toFixed(2)}s`, true);
            return { success: false, message, logFilePath };
        }

        const projectName = path.basename(process.cwd());
        let packageName = &quot;&quot;;
        let projectVersion = &quot;&quot;;
        const packageJsonPath = path.join(process.cwd(), &#39;package.json&#39;);
        if (await fs.exists(createFilePath(packageJsonPath))) {
            try {
                const packageJsonContent = await fs.readFile(createFilePath(packageJsonPath));
                const packageJson = JSON.parse(packageJsonContent) as Record&lt;string, unknown&gt;;
                if (typeof packageJson[&#39;name&#39;] === &#39;string&#39;) {
                    packageName = packageJson[&#39;name&#39;];
                }
                if (typeof packageJson[&#39;version&#39;] === &#39;string&#39;) {
                    projectVersion = packageJson[&#39;version&#39;];
                }
            } catch (error) {
                console.warn(&#39;Error reading package.json:&#39;, error);
            }
        }

        filePaths.sort((a, b) =&gt; path.relative(rootDir, a).localeCompare(path.relative(rootDir, b)));

        const maxFileSizeKB = config.maxFileSizeKB;
        const filesToProcess: FileInfo[] = [];
        const skippedFiles: string[] = [];
        let skippedCount = 0;
        let totalSizeBytes = 0;

        for (const filePath of filePaths) {
            const relativePath = path.relative(rootDir, filePath);

            try {
                const stats = await fs.stat(filePath);
                const sizeKB = stats.size / 1024;
                totalSizeBytes += stats.size;

                if (sizeKB &gt; maxFileSizeKB) {
                    skippedCount++;
                    skippedFiles.push(relativePath);
                    await writeLog(logFilePath, `Skipped large file: ${relativePath} (${sizeKB.toFixed(2)} KB)`, true);
                } else {
                    const safePath = validateSecurePath(filePath, config.rootDirectory);
                    await validateNoSymlinks(createFilePath(safePath), false);
                    
                    if (await isBinaryFile(safePath)) {
                        await writeLog(logFilePath, `Skipping binary file: ${relativePath}`, true);
                        console.warn(`Skipping binary file: ${relativePath}`);
                        continue;
                    }
                    
                    const content = await fs.readFile(createFilePath(safePath));
                    
                    let fileInfo: FileInfo = {
                        content,
                        relativePath,
                        path: filePath,
                        size: stats.size
                    };

                    fileInfo = await pluginManager.executeBeforeFileProcessing(fileInfo, config) || fileInfo;
                    
                    if (fileInfo) {
                        filesToProcess.push(fileInfo);
                    }
                }
            } catch (error) {
                await writeLog(logFilePath, `Error checking file ${filePath}: ${String(error)}`, true);
                console.error(`Error checking file ${filePath}:`, error);
            }
        }

        const beforeFusionResult = await pluginManager.executeBeforeFusion(mergedConfig, filesToProcess);
        const finalConfig = beforeFusionResult.config;
        const finalFilesToProcess = beforeFusionResult.filesToProcess;

        const projectTitle = packageName &amp;&amp; packageName.toLowerCase() !== projectName.toLowerCase() 
            ? `${projectName} / ${packageName}` 
            : projectName;
        const versionInfo = projectVersion ? ` v${projectVersion}` : &#39;&#39;;

        const outputContext: OutputContext = {
            projectTitle,
            versionInfo,
            filesToProcess: finalFilesToProcess,
            config: finalConfig
        };

        const enabledStrategies = outputManager.getEnabledStrategies(finalConfig);
        const generatedPaths: FilePath[] = [];

        for (const strategy of enabledStrategies) {
            try {
                const outputPath = await outputManager.generateOutput(strategy, outputContext, fs);
                generatedPaths.push(outputPath);
                benchmark.markFileProcessed(0);
            } catch (error) {
                await writeLog(logFilePath, `Error generating ${strategy.name} output: ${String(error)}`, true);
                console.error(`Error generating ${strategy.name} output:`, error);
            }
        }

        const message = `Fusion completed successfully. ${finalFilesToProcess.length} files processed${skippedCount &gt; 0 ? `, ${skippedCount} skipped` : &#39;&#39;}.`;
        const endTime = new Date();
        const duration = ((endTime.getTime() - startTime.getTime()) / 1000).toFixed(2);
        const totalSizeMB = (totalSizeBytes / (1024 * 1024)).toFixed(2);
        
        await writeLog(logFilePath, `Status: Fusion completed successfully`, true);
        await writeLog(logFilePath, `Start time: ${formatTimestamp(startTime)}`, true);
        await writeLog(logFilePath, `End time: ${formatTimestamp(endTime)}`, true);
        await writeLog(logFilePath, `Duration: ${duration}s`, true);
        await writeLog(logFilePath, `Total data processed: ${totalSizeMB} MB`, true);
        
        const metrics = benchmark.getMetrics();
        await writeLog(logFilePath, `\nPerformance Metrics:`, true);
        await writeLog(logFilePath, `  Memory Used: ${metrics.memoryUsed.toFixed(2)} MB`, true);
        await writeLog(logFilePath, `  Throughput: ${metrics.throughputMBps.toFixed(2)} MB/s`, true);
        await writeLog(logFilePath, `  Files/second: ${(metrics.filesProcessed / metrics.duration).toFixed(2)}`, true);
        
        await writeLog(logFilePath, `Files found: ${originalFileCount}`, true);
        await writeLog(logFilePath, `Files processed successfully: ${finalFilesToProcess.length}`, true);
        await writeLog(logFilePath, `Files skipped (too large): ${skippedCount}`, true);
        await writeLog(logFilePath, `Files filtered out: ${originalFileCount - filePaths.length}`, true);
        
        const generatedFormats = enabledStrategies.map(s =&gt; s.extension);
        
        const result = {
            success: true as const,
            message: `${message} Generated formats: ${generatedFormats.join(&#39;, &#39;)}.`,
            fusionFilePath: generatedPaths[0] || logFilePath,
            logFilePath
        };

        const finalResult = await pluginManager.executeAfterFusion(result, finalConfig);
        
        await pluginManager.cleanupPlugins();
        
        return finalResult;

    } catch (error) {
        const errorMessage = `Fusion process failed: ${String(error)}`;
        console.error(errorMessage);

        try {
            await pluginManager.cleanupPlugins();
        } catch (cleanupError) {
            console.error(&#39;Error during plugin cleanup:&#39;, cleanupError);
        }

        try {
            let logFilePath: FilePath;
            try {
                logFilePath = createFilePath(path.resolve(config.rootDirectory, `${config.generatedFileName}.log`));
                const endTime = new Date();
                await writeLog(logFilePath, `Status: Fusion failed due to error\nError details: ${errorMessage}\nEnd time: ${formatTimestamp(endTime)}`, true);
            } catch {
                logFilePath = createFilePath(path.resolve(`${config.generatedFileName}.log`));
                const endTime = new Date();
                await writeLog(logFilePath, `Status: Fusion failed due to error\nError details: ${errorMessage}\nEnd time: ${formatTimestamp(endTime)}`, true);
            }

            return {
                success: false,
                message: errorMessage,
                logFilePath,
                error: error as Error
            };
        } catch (logError) {
            console.error(&#39;Could not write to log file:&#39;, logError);
            return {
                success: false,
                message: errorMessage,
                error: error as Error
            };
        }
    }
}</code></pre>
    </div>

    <div class="file-section" id="src-index-ts">
        <div class="file-title">
            <h2>üìÑ src/index.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Entry point for Project Fusion
 */

// Architecture exports (alphabetical)
export { DefaultFileSystemAdapter, MemoryFileSystemAdapter } from &#39;./adapters/file-system.js&#39;;
export type { FileSystemAdapter } from &#39;./adapters/file-system.js&#39;;
export { PluginManager, BasePlugin, createPlugin } from &#39;./plugins/plugin-system.js&#39;;
export type { Plugin, PluginHooks, PluginMetadata } from &#39;./plugins/plugin-system.js&#39;;
export { 
    OutputStrategyManager, 
    TextOutputStrategy, 
    MarkdownOutputStrategy, 
    HtmlOutputStrategy 
} from &#39;./strategies/output-strategy.js&#39;;
export type { OutputStrategy, OutputContext } from &#39;./strategies/output-strategy.js&#39;;

// Core API (alphabetical)
export { 
    createConfig,
    fusionAPI,
    runFusion,
    type ProgrammaticFusionOptions,
    type ProgrammaticFusionResult 
} from &#39;./api.js&#39;;
export { BenchmarkTracker, type BenchmarkMetrics } from &#39;./benchmark.js&#39;;
export { 
    projectFusion,
    ProjectFusionBuilder 
} from &#39;./fluent.js&#39;;
export { processFusion } from &#39;./fusion.js&#39;;

// Schemas and types (alphabetical)
export * from &#39;./schema.js&#39;;
export * from &#39;./types.js&#39;;
export * from &#39;./utils.js&#39;;
</code></pre>
    </div>

    <div class="file-section" id="src-plugins-plugin-system-ts">
        <div class="file-title">
            <h2>üìÑ src/plugins/plugin-system.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Plugin system for extending Project Fusion functionality
 */
import path from &#39;node:path&#39;;
import type { FileSystemAdapter } from &#39;../adapters/file-system.js&#39;;
import type { FileInfo, OutputStrategy } from &#39;../strategies/output-strategy.js&#39;;
import { type Config, createFilePath } from &#39;../types.js&#39;;

export interface PluginMetadata {
    name: string;
    version: string;
    description: string;
    author?: string;
    homepage?: string;
}

export interface PluginHooks {
    beforeFileProcessing?(fileInfo: FileInfo, config: Config): Promise&lt;FileInfo | null&gt;;
    afterFileProcessing?(fileInfo: FileInfo, processedContent: string, config: Config): Promise&lt;string&gt;;
    beforeFusion?(config: Config, filesToProcess: FileInfo[]): Promise&lt;{ config: Config; filesToProcess: FileInfo[] }&gt;;
    afterFusion?(result: unknown, config: Config): Promise&lt;unknown&gt;;
    registerOutputStrategies?(): OutputStrategy[];
    registerFileExtensions?(): Record&lt;string, string[]&gt;;
}

export interface Plugin extends PluginHooks {
    metadata: PluginMetadata;
    initialize?(config: Config): Promise&lt;void&gt;;
    cleanup?(): Promise&lt;void&gt;;
}

export interface PluginConfig {
    name: string;
    enabled: boolean;
    options?: Record&lt;string, unknown&gt;;
}

export class PluginManager {
    private readonly plugins: Map&lt;string, Plugin&gt; = new Map();
    private readonly pluginConfigs: Map&lt;string, PluginConfig&gt; = new Map();
    private readonly fs: FileSystemAdapter;

    constructor(fs: FileSystemAdapter) {
        this.fs = fs;
    }

    async loadPlugin(pluginPath: string): Promise&lt;void&gt; {
        try {
            const pluginModule = await import(pluginPath) as { default?: Plugin; plugin?: Plugin };
            const plugin: Plugin = pluginModule.default ?? pluginModule.plugin ?? pluginModule as Plugin;
            
            if (!plugin.metadata) {
                throw new Error(`Plugin at ${pluginPath} is missing metadata`);
            }
            
            this.plugins.set(plugin.metadata.name, plugin);
            console.log(`Loaded plugin: ${plugin.metadata.name} v${plugin.metadata.version}`);
        } catch (error) {
            console.error(`Failed to load plugin from ${pluginPath}:`, error);
            throw error;
        }
    }

    async loadPluginsFromDirectory(pluginsDir: string): Promise&lt;void&gt; {
        try {
            if (!(await this.fs.exists(createFilePath(pluginsDir)))) {
                return;
            }

            const pluginFiles = await this.fs.glob(path.join(pluginsDir, &#39;**/*.js&#39;));
            
            for (const pluginFile of pluginFiles) {
                try {
                    await this.loadPlugin(pluginFile);
                } catch (error) {
                    console.warn(`Skipping plugin ${pluginFile} due to error:`, error);
                }
            }
        } catch (error) {
            console.error(`Error loading plugins from directory ${pluginsDir}:`, error);
        }
    }

    registerPlugin(plugin: Plugin): void {
        this.plugins.set(plugin.metadata.name, plugin);
    }

    unregisterPlugin(name: string): void {
        this.plugins.delete(name);
        this.pluginConfigs.delete(name);
    }

    configurePlugin(name: string, config: PluginConfig): void {
        this.pluginConfigs.set(name, config);
    }

    getPlugin(name: string): Plugin | undefined {
        return this.plugins.get(name);
    }

    getEnabledPlugins(): Plugin[] {
        return [...this.plugins.values()].filter(plugin =&gt; {
            const config = this.pluginConfigs.get(plugin.metadata.name);
            return config?.enabled !== false;
        });
    }

    async initializePlugins(config: Config): Promise&lt;void&gt; {
        const enabledPlugins = this.getEnabledPlugins();
        
        for (const plugin of enabledPlugins) {
            try {
                if (plugin.initialize) {
                    await plugin.initialize(config);
                }
            } catch (error) {
                console.error(`Error initializing plugin ${plugin.metadata.name}:`, error);
            }
        }
    }

    async cleanupPlugins(): Promise&lt;void&gt; {
        const enabledPlugins = this.getEnabledPlugins();
        
        for (const plugin of enabledPlugins) {
            try {
                if (plugin.cleanup) {
                    await plugin.cleanup();
                }
            } catch (error) {
                console.error(`Error cleaning up plugin ${plugin.metadata.name}:`, error);
            }
        }
    }

    async executeBeforeFileProcessing(fileInfo: FileInfo, config: Config): Promise&lt;FileInfo | null&gt; {
        let currentFileInfo = fileInfo;
        
        for (const plugin of this.getEnabledPlugins()) {
            if (plugin.beforeFileProcessing) {
                try {
                    const result = await plugin.beforeFileProcessing(currentFileInfo, config);
                    if (result === null) {
                        return null;
                    }
                    currentFileInfo = result;
                } catch (error) {
                    console.error(`Error in plugin ${plugin.metadata.name} beforeFileProcessing:`, error);
                }
            }
        }
        
        return currentFileInfo;
    }

    async executeAfterFileProcessing(
        fileInfo: FileInfo, 
        processedContent: string, 
        config: Config
    ): Promise&lt;string&gt; {
        let currentContent = processedContent;
        
        for (const plugin of this.getEnabledPlugins()) {
            if (plugin.afterFileProcessing) {
                try {
                    currentContent = await plugin.afterFileProcessing(fileInfo, currentContent, config);
                } catch (error) {
                    console.error(`Error in plugin ${plugin.metadata.name} afterFileProcessing:`, error);
                }
            }
        }
        
        return currentContent;
    }

    async executeBeforeFusion(
        config: Config, 
        filesToProcess: FileInfo[]
    ): Promise&lt;{ config: Config; filesToProcess: FileInfo[] }&gt; {
        let currentConfig = config;
        let currentFiles = filesToProcess;
        
        for (const plugin of this.getEnabledPlugins()) {
            if (plugin.beforeFusion) {
                try {
                    const result = await plugin.beforeFusion(currentConfig, currentFiles);
                    currentConfig = result.config;
                    currentFiles = result.filesToProcess;
                } catch (error) {
                    console.error(`Error in plugin ${plugin.metadata.name} beforeFusion:`, error);
                }
            }
        }
        
        return { config: currentConfig, filesToProcess: currentFiles };
    }

    async executeAfterFusion&lt;T&gt;(result: T, config: Config): Promise&lt;T&gt; {
        let currentResult = result;
        
        for (const plugin of this.getEnabledPlugins()) {
            if (plugin.afterFusion) {
                try {
                    currentResult = await plugin.afterFusion(currentResult, config) as T;
                } catch (error) {
                    console.error(`Error in plugin ${plugin.metadata.name} afterFusion:`, error);
                }
            }
        }
        
        return currentResult;
    }

    getAdditionalOutputStrategies(): OutputStrategy[] {
        const strategies: OutputStrategy[] = [];
        
        for (const plugin of this.getEnabledPlugins()) {
            if (plugin.registerOutputStrategies) {
                try {
                    const pluginStrategies = plugin.registerOutputStrategies();
                    strategies.push(...pluginStrategies);
                } catch (error) {
                    console.error(`Error getting output strategies from plugin ${plugin.metadata.name}:`, error);
                }
            }
        }
        
        return strategies;
    }

    getAdditionalFileExtensions(): Record&lt;string, string[]&gt; {
        const extensions: Record&lt;string, string[]&gt; = {};
        
        for (const plugin of this.getEnabledPlugins()) {
            if (plugin.registerFileExtensions) {
                try {
                    const pluginExtensions = plugin.registerFileExtensions();
                    Object.assign(extensions, pluginExtensions);
                } catch (error) {
                    console.error(`Error getting file extensions from plugin ${plugin.metadata.name}:`, error);
                }
            }
        }
        
        return extensions;
    }

    listPlugins(): PluginMetadata[] {
        return [...this.plugins.values()].map(plugin =&gt; plugin.metadata);
    }
}

export abstract class BasePlugin implements Plugin {
    abstract metadata: PluginMetadata;

    async initialize?(): Promise&lt;void&gt; {
        // Default implementation - can be overridden
    }

    async cleanup?(): Promise&lt;void&gt; {
        // Default implementation - can be overridden
    }
}

export function createPlugin(metadata: PluginMetadata, hooks: PluginHooks = {}): Plugin {
    return {
        metadata,
        ...hooks
    };
}</code></pre>
    </div>

    <div class="file-section" id="src-schema-ts">
        <div class="file-title">
            <h2>üìÑ src/schema.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Configuration schema definitions for Project Fusion
 */
import { z } from &#39;zod&#39;;

/**
 * File extension groups with support for custom categories
 */
const ParsedFileExtensionsSchema = z.object({
    backend: z.array(z.string()).default([&quot;.cs&quot;, &quot;.go&quot;, &quot;.java&quot;, &quot;.php&quot;, &quot;.py&quot;, &quot;.rb&quot;, &quot;.rs&quot;]),
    config: z.array(z.string()).default([&quot;.json&quot;, &quot;.toml&quot;, &quot;.xml&quot;, &quot;.yaml&quot;, &quot;.yml&quot;]),
    cpp: z.array(z.string()).default([&quot;.c&quot;, &quot;.cc&quot;, &quot;.cpp&quot;, &quot;.h&quot;, &quot;.hpp&quot;]),
    doc: z.array(z.string()).default([&quot;.adoc&quot;, &quot;.md&quot;, &quot;.rst&quot;]),
    godot: z.array(z.string()).default([&quot;.cfg&quot;, &quot;.cs&quot;, &quot;.gd&quot;, &quot;.import&quot;, &quot;.tscn&quot;, &quot;.tres&quot;]),
    scripts: z.array(z.string()).default([&quot;.bat&quot;, &quot;.cmd&quot;, &quot;.ps1&quot;, &quot;.sh&quot;]),
    web: z.array(z.string()).default([&quot;.css&quot;, &quot;.html&quot;, &quot;.js&quot;, &quot;.jsx&quot;, &quot;.svelte&quot;, &quot;.ts&quot;, &quot;.tsx&quot;, &quot;.vue&quot;]),
}).and(z.record(z.string(), z.array(z.string())));

/**
 * Complete configuration schema for version 1
 */
export const ConfigSchemaV1 = z.object({
    copyToClipboard: z.boolean().default(false),
    generatedFileName: z.string().default(&quot;project-fusioned&quot;),
    generateHtml: z.boolean().default(true),
    generateMarkdown: z.boolean().default(true),
    generateText: z.boolean().default(true),
    maxFileSizeKB: z.number().default(1024),
    parseSubDirectories: z.boolean().default(true),
    parsedFileExtensions: ParsedFileExtensionsSchema.default({
        backend: [&quot;.cs&quot;, &quot;.go&quot;, &quot;.java&quot;, &quot;.php&quot;, &quot;.py&quot;, &quot;.rb&quot;, &quot;.rs&quot;],
        config: [&quot;.json&quot;, &quot;.toml&quot;, &quot;.xml&quot;, &quot;.yaml&quot;, &quot;.yml&quot;],
        cpp: [&quot;.c&quot;, &quot;.cc&quot;, &quot;.cpp&quot;, &quot;.h&quot;, &quot;.hpp&quot;],
        doc: [&quot;.adoc&quot;, &quot;.md&quot;, &quot;.rst&quot;],
        godot: [&quot;.cfg&quot;, &quot;.cs&quot;, &quot;.gd&quot;, &quot;.import&quot;, &quot;.tscn&quot;, &quot;.tres&quot;],
        scripts: [&quot;.bat&quot;, &quot;.cmd&quot;, &quot;.ps1&quot;, &quot;.sh&quot;],
        web: [&quot;.css&quot;, &quot;.html&quot;, &quot;.js&quot;, &quot;.jsx&quot;, &quot;.svelte&quot;, &quot;.ts&quot;, &quot;.tsx&quot;, &quot;.vue&quot;]
    }),
    ignorePatterns: z.array(z.string()).default([
        &quot;project-fusion.json&quot;,
        &quot;project-fusion.log&quot;,
        &quot;project-fusioned.*&quot;,
        &quot;node_modules/&quot;,
        &quot;package-lock.json&quot;,
        &quot;pnpm-lock.yaml&quot;,
        &quot;yarn.lock&quot;,
        &quot;dist/&quot;,
        &quot;build/&quot;,
        &quot;*.min.js&quot;,
        &quot;*.min.css&quot;,
        &quot;.env&quot;,
        &quot;.env.*&quot;,
        &quot;*.key&quot;,
        &quot;*.pem&quot;,
        &quot;**/credentials/*&quot;,
        &quot;**/secrets/*&quot;,
        &quot;*.log&quot;,
        &quot;logs/&quot;,
        &quot;.DS_Store&quot;,
        &quot;Thumbs.db&quot;,
        &quot;.vscode/&quot;,
        &quot;.idea/&quot;,
        &quot;*.swp&quot;,
        &quot;*.swo&quot;,
        &quot;*.zip&quot;,
        &quot;*.tar&quot;,
        &quot;*.tgz&quot;,
        &quot;*.gz&quot;,
        &quot;*.7z&quot;,
        &quot;*.rar&quot;,
        &quot;*.png&quot;,
        &quot;*.jpg&quot;,
        &quot;*.jpeg&quot;,
        &quot;*.gif&quot;,
        &quot;*.bmp&quot;,
        &quot;*.ico&quot;,
        &quot;*.svg&quot;,
        &quot;*.webp&quot;,
        &quot;*.pdf&quot;,
        &quot;*.doc&quot;,
        &quot;*.docx&quot;,
        &quot;*.xls&quot;,
        &quot;*.xlsx&quot;,
        &quot;*.ppt&quot;,
        &quot;*.pptx&quot;,
        &quot;*.mp3&quot;,
        &quot;*.mp4&quot;,
        &quot;*.avi&quot;,
        &quot;*.mov&quot;,
        &quot;*.wmv&quot;,
        &quot;*.flv&quot;,
        &quot;*.wav&quot;,
        &quot;*.flac&quot;,
        &quot;*.unitypackage&quot;,
        &quot;*.uasset&quot;,
        &quot;*.fbx&quot;,
        &quot;*.obj&quot;,
        &quot;*.blend&quot;,
        &quot;*.exe&quot;,
        &quot;*.dll&quot;,
        &quot;*.so&quot;,
        &quot;*.dylib&quot;,
        &quot;*.a&quot;,
        &quot;*.o&quot;,
        &quot;*.pyc&quot;,
        &quot;*.pyo&quot;,
        &quot;*.class&quot;,
        &quot;*.jar&quot;,
        &quot;*.war&quot;
    ]),
    rootDirectory: z.string().default(&quot;.&quot;),
    schemaVersion: z.literal(1).default(1),
    useGitIgnoreForExcludes: z.boolean().default(true),
});</code></pre>
    </div>

    <div class="file-section" id="src-strategies-output-strategy-ts">
        <div class="file-title">
            <h2>üìÑ src/strategies/output-strategy.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Output strategy pattern for different fusion formats
 */
import { WriteStream, createWriteStream } from &#39;node:fs&#39;;
import path from &#39;node:path&#39;;
import type { FileSystemAdapter } from &#39;../adapters/file-system.js&#39;;
import { type Config, type FilePath, createFilePath } from &#39;../types.js&#39;;
import { formatLocalTimestamp, formatTimestamp, getMarkdownLanguage } from &#39;../utils.js&#39;;

export interface FileInfo {
    content: string;
    relativePath: string;
    path: FilePath;
    size: number;
}

export interface OutputContext {
    projectTitle: string;
    versionInfo: string;
    filesToProcess: FileInfo[];
    config: Config;
}

export interface OutputStrategy {
    readonly name: string;
    readonly extension: string;
    generateHeader(context: OutputContext): string;
    processFile(fileInfo: FileInfo, context: OutputContext): string;
    generateFooter?(context: OutputContext): string;
    createStream?(outputPath: FilePath): WriteStream;
}

function escapeHtml(text: string): string {
    return text
        .replaceAll(&#39;&amp;&#39;, &#39;&amp;amp;&#39;)
        .replaceAll(&#39;&lt;&#39;, &#39;&amp;lt;&#39;)
        .replaceAll(&#39;&gt;&#39;, &#39;&amp;gt;&#39;)
        .replaceAll(&#39;&quot;&#39;, &#39;&amp;quot;&#39;)
        .replaceAll(&#39;\&#39;&#39;, &#39;&amp;#39;&#39;);
}

export class TextOutputStrategy implements OutputStrategy {
    readonly name = &#39;text&#39;;
    readonly extension = &#39;.txt&#39;;

    generateHeader(context: OutputContext): string {
        return `# Generated Project Fusion File
# Project: ${context.projectTitle}${context.versionInfo}
# Generated: ${formatLocalTimestamp()}
# UTC: ${formatTimestamp()}
# Files: ${context.filesToProcess.length}
# Generated by: project-fusion

`;
    }

    processFile(fileInfo: FileInfo): string {
        return `&lt;!-- ============================================================ --&gt;
&lt;!-- FILE: ${fileInfo.relativePath.padEnd(54)} --&gt;
&lt;!-- ============================================================ --&gt;
${fileInfo.content}

`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath);
    }
}

export class MarkdownOutputStrategy implements OutputStrategy {
    readonly name = &#39;markdown&#39;;
    readonly extension = &#39;.md&#39;;

    generateHeader(context: OutputContext): string {
        const tocEntries = context.filesToProcess
            .map(fileInfo =&gt; `- [${fileInfo.relativePath}](#${fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, &#39;-&#39;).toLowerCase()})`)
            .join(&#39;\n&#39;);

        return `# Generated Project Fusion File

**Project:** ${context.projectTitle}${context.versionInfo}

**Generated:** ${formatLocalTimestamp()}

**UTC:** ${formatTimestamp()}

**Files:** ${context.filesToProcess.length}

**Generated by:** [project-fusion](https://github.com/the99studio/project-fusion)

---

## üìÅ Table of Contents

${tocEntries}

---

`;
    }

    processFile(fileInfo: FileInfo): string {
        const fileExt = path.extname(fileInfo.path).toLowerCase();
        const basename = path.basename(fileInfo.path);
        const language = getMarkdownLanguage(fileExt || basename);

        return `## üìÑ ${fileInfo.relativePath}

\`\`\`${language}
${fileInfo.content}
\`\`\`

`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath);
    }
}

export class HtmlOutputStrategy implements OutputStrategy {
    readonly name = &#39;html&#39;;
    readonly extension = &#39;.html&#39;;

    generateHeader(context: OutputContext): string {
        const tocEntries = context.filesToProcess
            .map(fileInfo =&gt; `            &lt;li&gt;&lt;a href=&quot;#${fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, &#39;-&#39;).toLowerCase()}&quot;&gt;${escapeHtml(fileInfo.relativePath)}&lt;/a&gt;&lt;/li&gt;`)
            .join(&#39;\n&#39;);

        return `&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Project Fusion - ${escapeHtml(context.projectTitle)}${escapeHtml(context.versionInfo)}&lt;/title&gt;
    &lt;style&gt;
        body { font-family: -apple-system, BlinkMacSystemFont, &#39;Segoe UI&#39;, Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { border-bottom: 2px solid #eee; padding-bottom: 20px; margin-bottom: 30px; }
        .file-section { margin-bottom: 40px; border: 1px solid #ddd; border-radius: 8px; padding: 20px; }
        .file-title { background: #f5f5f5; margin: -20px -20px 20px -20px; padding: 15px 20px; border-radius: 8px 8px 0 0; }
        pre { background: #f8f9fa; padding: 15px; border-radius: 6px; overflow-x: auto; }
        code { font-family: &#39;Monaco&#39;, &#39;Menlo&#39;, &#39;Ubuntu Mono&#39;, monospace; }
        .toc { background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 30px; }
        .toc ul { margin: 0; padding-left: 20px; }
        .toc a { text-decoration: none; color: #0366d6; }
        .toc a:hover { text-decoration: underline; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;header&quot;&gt;
        &lt;h1&gt;Generated Project Fusion File&lt;/h1&gt;
        &lt;p&gt;&lt;strong&gt;Project:&lt;/strong&gt; ${escapeHtml(context.projectTitle)}${escapeHtml(context.versionInfo)}&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Generated:&lt;/strong&gt; ${formatLocalTimestamp()}&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;UTC:&lt;/strong&gt; ${formatTimestamp()}&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Files:&lt;/strong&gt; ${context.filesToProcess.length}&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Generated by:&lt;/strong&gt; &lt;a href=&quot;https://github.com/the99studio/project-fusion&quot;&gt;project-fusion&lt;/a&gt;&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;toc&quot;&gt;
        &lt;h2&gt;üìÅ Table of Contents&lt;/h2&gt;
        &lt;ul&gt;
${tocEntries}
        &lt;/ul&gt;
    &lt;/div&gt;
`;
    }

    processFile(fileInfo: FileInfo): string {
        const fileExt = path.extname(fileInfo.path).toLowerCase();
        const basename = path.basename(fileInfo.path);
        const language = getMarkdownLanguage(fileExt || basename);
        const escapedContent = escapeHtml(fileInfo.content);
        const fileAnchor = fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, &#39;-&#39;).toLowerCase();

        return `    &lt;div class=&quot;file-section&quot; id=&quot;${fileAnchor}&quot;&gt;
        &lt;div class=&quot;file-title&quot;&gt;
            &lt;h2&gt;üìÑ ${escapeHtml(fileInfo.relativePath)}&lt;/h2&gt;
        &lt;/div&gt;
        &lt;pre&gt;&lt;code class=&quot;${language}&quot;&gt;${escapedContent}&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

`;
    }

    generateFooter(): string {
        return `&lt;/body&gt;
&lt;/html&gt;`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath);
    }
}

export class OutputStrategyManager {
    private readonly strategies: Map&lt;string, OutputStrategy&gt; = new Map();

    constructor() {
        this.registerStrategy(new TextOutputStrategy());
        this.registerStrategy(new MarkdownOutputStrategy());
        this.registerStrategy(new HtmlOutputStrategy());
    }

    registerStrategy(strategy: OutputStrategy): void {
        this.strategies.set(strategy.name, strategy);
    }

    getStrategy(name: string): OutputStrategy | undefined {
        return this.strategies.get(name);
    }

    getEnabledStrategies(config: Config): OutputStrategy[] {
        const enabled: OutputStrategy[] = [];
        
        if (config.generateText) {
            const strategy = this.getStrategy(&#39;text&#39;);
            if (strategy) enabled.push(strategy);
        }
        
        if (config.generateMarkdown) {
            const strategy = this.getStrategy(&#39;markdown&#39;);
            if (strategy) enabled.push(strategy);
        }
        
        if (config.generateHtml) {
            const strategy = this.getStrategy(&#39;html&#39;);
            if (strategy) enabled.push(strategy);
        }
        
        return enabled;
    }

    getOutputPath(strategy: OutputStrategy, config: Config): FilePath {
        return createFilePath(path.resolve(config.rootDirectory, `${config.generatedFileName}${strategy.extension}`));
    }

    async generateOutput(
        strategy: OutputStrategy, 
        context: OutputContext, 
        fs: FileSystemAdapter
    ): Promise&lt;FilePath&gt; {
        const outputPath = this.getOutputPath(strategy, context.config);
        
        await fs.ensureDir(path.dirname(outputPath));
        
        let content = strategy.generateHeader(context);
        
        for (const fileInfo of context.filesToProcess) {
            content += strategy.processFile(fileInfo, context);
        }
        
        if (strategy.generateFooter) {
            content += strategy.generateFooter(context);
        }
        
        await fs.writeFile(outputPath, content);
        
        return outputPath;
    }
}</code></pre>
    </div>

    <div class="file-section" id="src-types-ts">
        <div class="file-title">
            <h2>üìÑ src/types.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Type definitions for the fusion functionality
 */

// Branded types for type-safe handling
export type FilePath = string &amp; { readonly __brand: unique symbol };

export const createFilePath = (path: string): FilePath =&gt; {
    if (!path || typeof path !== &#39;string&#39;) {
        throw new FusionError(&#39;Invalid file path provided&#39;, &#39;INVALID_PATH&#39;, &#39;error&#39;);
    }
    return path as FilePath;
};

// Utility types for enhanced type safety
export type NonEmptyArray&lt;T&gt; = readonly [T, ...T[]];

export const isNonEmptyArray = &lt;T&gt;(array: readonly T[]): array is NonEmptyArray&lt;T&gt; =&gt; {
    return array.length &gt; 0;
};

export const createNonEmptyArray = &lt;T&gt;(items: readonly T[]): NonEmptyArray&lt;T&gt; =&gt; {
    if (!isNonEmptyArray(items)) {
        throw new FusionError(&#39;Array must contain at least one element&#39;, &#39;EMPTY_ARRAY&#39;, &#39;error&#39;);
    }
    return items;
};

// Extension groups with type safety (alphabetically sorted)
export const EXTENSION_GROUPS = {
    web: [&#39;.css&#39;, &#39;.html&#39;, &#39;.js&#39;, &#39;.jsx&#39;, &#39;.svelte&#39;, &#39;.ts&#39;, &#39;.tsx&#39;, &#39;.vue&#39;],
    backend: [&#39;.cs&#39;, &#39;.go&#39;, &#39;.java&#39;, &#39;.php&#39;, &#39;.py&#39;, &#39;.rb&#39;, &#39;.rs&#39;],
    config: [&#39;.cfg&#39;, &#39;.json&#39;, &#39;.toml&#39;, &#39;.xml&#39;, &#39;.yaml&#39;, &#39;.yml&#39;],
    cpp: [&#39;.c&#39;, &#39;.cc&#39;, &#39;.cpp&#39;, &#39;.h&#39;, &#39;.hpp&#39;],
    scripts: [&#39;.bat&#39;, &#39;.cmd&#39;, &#39;.ps1&#39;, &#39;.sh&#39;],
    godot: [&#39;.gd&#39;, &#39;.import&#39;, &#39;.tres&#39;, &#39;.tscn&#39;],
    doc: [&#39;.adoc&#39;, &#39;.md&#39;, &#39;.rst&#39;]
} as const;

export type ExtensionGroupName = keyof typeof EXTENSION_GROUPS;
export type ExtensionGroup = typeof EXTENSION_GROUPS[ExtensionGroupName];

export const isValidExtensionGroup = (group: string): group is ExtensionGroupName =&gt; {
    return group in EXTENSION_GROUPS;
};

export const getExtensionsForGroup = (groupName: ExtensionGroupName): ExtensionGroup =&gt; {
    return EXTENSION_GROUPS[groupName];
};

// Enhanced error hierarchy with codes and severity
export type FusionErrorCode = 
    | &#39;INVALID_PATH&#39;
    | &#39;UNKNOWN_EXTENSION_GROUP&#39;
    | &#39;EMPTY_ARRAY&#39;
    | &#39;PATH_TRAVERSAL&#39;
    | &#39;SYMLINK_NOT_ALLOWED&#39;;

export type FusionErrorSeverity = &#39;error&#39; | &#39;warning&#39; | &#39;info&#39;;

export class FusionError extends Error {
    public readonly code: FusionErrorCode;
    public readonly severity: FusionErrorSeverity;
    public readonly context: Record&lt;string, unknown&gt; | undefined;

    constructor(
        message: string, 
        code: FusionErrorCode, 
        severity: FusionErrorSeverity = &#39;error&#39;,
        context?: Record&lt;string, unknown&gt;
    ) {
        super(message);
        this.name = &#39;FusionError&#39;;
        this.code = code;
        this.severity = severity;
        this.context = context;
    }
}

/**
 * Main configuration interface
 */
export interface Config {
    copyToClipboard: boolean;
    generatedFileName: string;
    generateHtml: boolean;
    generateMarkdown: boolean;
    generateText: boolean;
    ignorePatterns: string[];
    maxFileSizeKB: number;
    parsedFileExtensions: {
        backend?: string[];
        config?: string[];
        cpp?: string[];
        doc?: string[];
        godot?: string[];
        scripts?: string[];
        web?: string[];
        [key: string]: string[] | undefined;
    };
    parseSubDirectories: boolean;
    rootDirectory: string;
    schemaVersion: number;
    useGitIgnoreForExcludes: boolean;
}


/**
 * Options for the fusion process
 */
export interface FusionOptions {
    extensionGroups?: string[];
    pluginsDir?: string;
    enabledPlugins?: string[];
    fs?: import(&#39;./adapters/file-system.js&#39;).FileSystemAdapter;
}

/**
 * Type-safe fusion result with discriminated union for success/failure states
 */
export type FusionResult = 
    | {
        fusionFilePath: FilePath;
        logFilePath: FilePath;
        message: string;
        success: true;
    }
    | {
        error?: Error;
        logFilePath?: FilePath;
        message: string;
        success: false;
    };</code></pre>
    </div>

    <div class="file-section" id="src-utils-ts">
        <div class="file-title">
            <h2>üìÑ src/utils.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Utilities for Project Fusion
 */
import path from &#39;node:path&#39;;

import fs from &#39;fs-extra&#39;;
import { z } from &#39;zod&#39;;

import { ConfigSchemaV1 } from &#39;./schema.js&#39;;
import { type Config, FusionError, isNonEmptyArray, isValidExtensionGroup } from &#39;./types.js&#39;;


/**
 * Default configuration for Project Fusion
 */
export const defaultConfig = {
    copyToClipboard: false,
    generatedFileName: &quot;project-fusioned&quot;,
    generateHtml: true,
    generateMarkdown: true,
    generateText: true,
    maxFileSizeKB: 1024,
    parseSubDirectories: true,
    parsedFileExtensions: {
        backend: [&quot;.cs&quot;, &quot;.go&quot;, &quot;.java&quot;, &quot;.php&quot;, &quot;.py&quot;, &quot;.rb&quot;, &quot;.rs&quot;] as const,
        config: [&quot;.json&quot;, &quot;.toml&quot;, &quot;.xml&quot;, &quot;.yaml&quot;, &quot;.yml&quot;] as const,
        cpp: [&quot;.c&quot;, &quot;.cc&quot;, &quot;.cpp&quot;, &quot;.h&quot;, &quot;.hpp&quot;] as const,
        doc: [&quot;.adoc&quot;, &quot;.md&quot;, &quot;.rst&quot;] as const,
        godot: [&quot;.cfg&quot;, &quot;.cs&quot;, &quot;.gd&quot;, &quot;.import&quot;, &quot;.tscn&quot;, &quot;.tres&quot;] as const,
        scripts: [&quot;.bat&quot;, &quot;.cmd&quot;, &quot;.ps1&quot;, &quot;.sh&quot;] as const,
        web: [&quot;.css&quot;, &quot;.html&quot;, &quot;.js&quot;, &quot;.jsx&quot;, &quot;.svelte&quot;, &quot;.ts&quot;, &quot;.tsx&quot;, &quot;.vue&quot;] as const
    },
    ignorePatterns: [
        &quot;project-fusion.json&quot;,
        &quot;project-fusion.log&quot;,
        &quot;project-fusioned.*&quot;,
        &quot;node_modules/&quot;,
        &quot;package-lock.json&quot;,
        &quot;pnpm-lock.yaml&quot;,
        &quot;yarn.lock&quot;,
        &quot;dist/&quot;,
        &quot;build/&quot;,
        &quot;*.min.js&quot;,
        &quot;*.min.css&quot;,
        &quot;.env&quot;,
        &quot;.env.*&quot;,
        &quot;*.key&quot;,
        &quot;*.pem&quot;,
        &quot;**/credentials/*&quot;,
        &quot;**/secrets/*&quot;,
        &quot;*.log&quot;,
        &quot;logs/&quot;,
        &quot;.DS_Store&quot;,
        &quot;Thumbs.db&quot;,
        &quot;.vscode/&quot;,
        &quot;.idea/&quot;,
        &quot;*.swp&quot;,
        &quot;*.swo&quot;,
        // Binary files and archives
        &quot;*.zip&quot;,
        &quot;*.tar&quot;,
        &quot;*.tgz&quot;,
        &quot;*.gz&quot;,
        &quot;*.7z&quot;,
        &quot;*.rar&quot;,
        // Images
        &quot;*.png&quot;,
        &quot;*.jpg&quot;,
        &quot;*.jpeg&quot;,
        &quot;*.gif&quot;,
        &quot;*.bmp&quot;,
        &quot;*.ico&quot;,
        &quot;*.svg&quot;,
        &quot;*.webp&quot;,
        // Documents
        &quot;*.pdf&quot;,
        &quot;*.doc&quot;,
        &quot;*.docx&quot;,
        &quot;*.xls&quot;,
        &quot;*.xlsx&quot;,
        &quot;*.ppt&quot;,
        &quot;*.pptx&quot;,
        // Media
        &quot;*.mp3&quot;,
        &quot;*.mp4&quot;,
        &quot;*.avi&quot;,
        &quot;*.mov&quot;,
        &quot;*.wmv&quot;,
        &quot;*.flv&quot;,
        &quot;*.wav&quot;,
        &quot;*.flac&quot;,
        // Game engine assets
        &quot;*.unitypackage&quot;,
        &quot;*.uasset&quot;,
        &quot;*.fbx&quot;,
        &quot;*.obj&quot;,
        &quot;*.blend&quot;,
        // Compiled/Binary
        &quot;*.exe&quot;,
        &quot;*.dll&quot;,
        &quot;*.so&quot;,
        &quot;*.dylib&quot;,
        &quot;*.a&quot;,
        &quot;*.o&quot;,
        &quot;*.pyc&quot;,
        &quot;*.pyo&quot;,
        &quot;*.class&quot;,
        &quot;*.jar&quot;,
        &quot;*.war&quot;
    ],
    rootDirectory: &quot;.&quot;,
    schemaVersion: 1,
    useGitIgnoreForExcludes: true
} as const satisfies Config;


/**
 * Load and validate configuration with fallback to defaults
 * @returns The loaded configuration or default config if invalid/missing
 */
export async function loadConfig(): Promise&lt;Config&gt; {
    try {
        const configPath = path.resolve(&#39;./project-fusion.json&#39;);
        
        let configContent: string;
        try {
            configContent = await fs.readFile(configPath, &#39;utf8&#39;);
        } catch {
            return defaultConfig;
        }

        const parsedConfig = JSON.parse(configContent) as unknown;

        try {
            const validatedConfig = ConfigSchemaV1.parse(parsedConfig);
            return validatedConfig;
        } catch (zodError: unknown) {
            // Graceful degradation with detailed error reporting
            if (zodError instanceof z.ZodError) {
                console.error(&#39;Configuration validation failed (will use default config):&#39;);
                for (const [index, issue] of zodError.issues.entries()) {
                    const path = issue.path.length &gt; 0 ? issue.path.join(&#39;.&#39;) : &#39;root&#39;;
                     
                    const value = issue.path.reduce((obj: unknown, key) =&gt; {
                        if (typeof key === &#39;string&#39; &amp;&amp; obj &amp;&amp; typeof obj === &#39;object&#39;) {
                            return (obj as Record&lt;string, unknown&gt;)[key];
                        }
                        return undefined;
                    }, parsedConfig);
                    console.error(`  ${index + 1}. Path: ${path}`);
                    console.error(`     Error: ${issue.message}`);
                    console.error(`     Current value: ${JSON.stringify(value)}`);
                    if (issue.code === &#39;invalid_type&#39;) {
                         
                        console.error(`     Expected type: ${String((issue as unknown as Record&lt;string, unknown&gt;)[&#39;expected&#39;])}, received: ${String((issue as unknown as Record&lt;string, unknown&gt;)[&#39;received&#39;])}`);
                    }
                }
            } else {
                console.error(&#39;Unknown validation error (will use default config):&#39;, zodError);
            }
            return defaultConfig;
        }
    } catch (error) {
        const typedError = error instanceof Error ? error : new Error(String(error));

        console.error(&#39;Error loading configuration, will use default configuration:&#39;, {
            message: typedError.message,
            stack: typedError.stack,
            context: &#39;loadConfig&#39;,
            configPath: path.resolve(&#39;./project-fusion.json&#39;)
        });

        return defaultConfig;
    }
}

/**
 * Create directory if it doesn&#39;t exist
 * @param directory Directory path
 */
export async function ensureDirectoryExists(directory: string): Promise&lt;void&gt; {
    await fs.ensureDir(directory);
}

/**
 * Write content to log file with optional console output
 * @param logFilePath Path to log file
 * @param content Content to log
 * @param append If true, append to existing file
 * @param consoleOutput If true, also display on console
 */
export async function writeLog(
    logFilePath: string,
    content: string,
    append = false,
    consoleOutput = false
): Promise&lt;void&gt; {
    try {
        await ensureDirectoryExists(path.dirname(logFilePath));
        await (append ? fs.appendFile(logFilePath, `${content  }\n`) : fs.writeFile(logFilePath, `${content  }\n`));

        if (consoleOutput) {
            console.log(content);
        }
    } catch (error) {
        console.error(&#39;Error writing log:&#39;, error);
    }
}


/**
 * Format a timestamp
 * @param date Optional date to format, defaults to current date
 * @returns Formatted timestamp
 */
export function formatTimestamp(date?: Date): string {
    return (date ?? new Date()).toISOString();
}

/**
 * Format a local timestamp for display
 * @param date Optional date to format, defaults to current date
 * @returns Formatted local timestamp
 */
export function formatLocalTimestamp(date?: Date): string {
    const now = date ?? new Date();
    return now.toLocaleString(&#39;fr-FR&#39;, {
        year: &#39;numeric&#39;,
        month: &#39;2-digit&#39;,
        day: &#39;2-digit&#39;,
        hour: &#39;2-digit&#39;,
        minute: &#39;2-digit&#39;,
        second: &#39;2-digit&#39;,
        timeZoneName: &#39;short&#39;
    });
}


/**
 * Extract file extensions from configuration groups
 * @param config Config object
 * @param groups Extension groups to include (all if undefined)
 * @returns Array of file extensions
 */
export function getExtensionsFromGroups(
    config: Config,
    groups?: string[]
): string[] {
    // Return all extensions if no specific groups requested
    if (!groups || groups.length === 0) {
        return Object.values(config.parsedFileExtensions)
            .filter((extensions): extensions is string[] =&gt; Boolean(extensions))
            .flat();
    }

    // Validate and collect extensions from specified groups
    return groups.reduce((acc: string[], group: string) =&gt; {
        // Type-safe group validation
        if (!isValidExtensionGroup(group)) {
            console.warn(`Unknown extension group &#39;${group}&#39;. Valid groups: ${Object.keys(config.parsedFileExtensions).join(&#39;, &#39;)}`);
            return acc;
        }

        const extensions = config.parsedFileExtensions[group];
        if (extensions &amp;&amp; isNonEmptyArray(extensions)) {
            acc.push(...extensions);
        } else {
            console.warn(`Extension group &#39;${group}&#39; is empty or not found in configuration`);
        }
        return acc;
    }, []);
}

/**
 * Validate that a file path is safe and doesn&#39;t escape the root directory
 * @param filePath Path to validate
 * @param rootDirectory Root directory that files must stay within
 * @returns Normalized absolute path if valid
 * @throws FusionError if path is unsafe
 */
export function validateSecurePath(filePath: string, rootDirectory: string): string {
    try {
        // Resolve both paths to absolute paths
        const resolvedRoot = path.resolve(rootDirectory);
        const resolvedFile = path.resolve(filePath);
        
        // Check if the file path starts with the root directory
        if (!resolvedFile.startsWith(resolvedRoot + path.sep) &amp;&amp; resolvedFile !== resolvedRoot) {
            throw new FusionError(
                `Path traversal detected: &#39;${filePath}&#39; escapes root directory &#39;${rootDirectory}&#39;`,
                &#39;PATH_TRAVERSAL&#39;,
                &#39;error&#39;,
                { filePath, rootDirectory, resolvedFile, resolvedRoot }
            );
        }
        
        return resolvedFile;
    } catch (error) {
        if (error instanceof FusionError) {
            throw error;
        }
        throw new FusionError(
            `Invalid path: &#39;${filePath}&#39;`,
            &#39;INVALID_PATH&#39;,
            &#39;error&#39;,
            { filePath, rootDirectory, originalError: error }
        );
    }
}

/**
 * Check if a path is a symbolic link and validate it&#39;s allowed
 * @param filePath Path to check
 * @param allowSymlinks Whether symbolic links are allowed
 * @returns True if the path is safe to process
 * @throws FusionError if symlink is found and not allowed
 */
export async function validateNoSymlinks(filePath: string, allowSymlinks: boolean = false): Promise&lt;boolean&gt; {
    try {
        const stats = await fs.lstat(filePath);
        
        if (stats.isSymbolicLink()) {
            if (!allowSymlinks) {
                throw new FusionError(
                    `Symbolic link not allowed: &#39;${filePath}&#39;`,
                    &#39;SYMLINK_NOT_ALLOWED&#39;,
                    &#39;error&#39;,
                    { filePath }
                );
            }
            // If symlinks are allowed, we still want to log them for transparency
            console.warn(`Processing symbolic link: ${filePath}`);
        }
        
        return true;
    } catch (error) {
        if (error instanceof FusionError) {
            throw error;
        }
        // If lstat fails, the file doesn&#39;t exist or is inaccessible
        return false;
    }
}

/**
 * Detect if a file appears to be binary
 * @param filePath Path to the file
 * @param sampleSize Number of bytes to sample (default: 1024)
 * @returns True if the file appears to be binary
 */
export async function isBinaryFile(filePath: string, sampleSize: number = 1024): Promise&lt;boolean&gt; {
    try {
        const stats = await fs.stat(filePath);
        if (stats.size === 0) {
            return false; // Empty file is not binary
        }
        
        // Read only the first part of the file for analysis
        const bytesToRead = Math.min(stats.size, sampleSize);
        const buffer = await fs.readFile(filePath, { encoding: null });
        const actualBytesToCheck = Math.min(buffer.length, bytesToRead);
        
        // Check for null bytes which indicate binary content
        for (let i = 0; i &lt; actualBytesToCheck; i++) {
            if (buffer[i] === 0) {
                return true;
            }
        }
        
        // Check for high ratio of non-printable characters
        let nonPrintable = 0;
        for (let i = 0; i &lt; actualBytesToCheck; i++) {
            const byte = buffer[i];
            if (byte === undefined) continue; // Skip undefined bytes
            // Allow common whitespace chars: space(32), tab(9), newline(10), carriage return(13)
            if (byte &lt; 32 &amp;&amp; byte !== 9 &amp;&amp; byte !== 10 &amp;&amp; byte !== 13) {
                nonPrintable++;
            } else if (byte &gt; 126) {
                nonPrintable++;
            }
        }
        
        // If more than 30% non-printable, consider it binary
        return (nonPrintable / actualBytesToCheck) &gt; 0.3;
    } catch {
        // If we can&#39;t read the file, assume it&#39;s not binary
        return false;
    }
}

/**
 * Map file extensions to syntax highlighting languages for markdown/HTML
 * @param extensionOrBasename File extension or special basename
 * @returns Language identifier for syntax highlighting
 */
export function getMarkdownLanguage(extensionOrBasename: string): string {
    // Comprehensive mapping for syntax highlighting across multiple formats
    const languageMap: Record&lt;string, string&gt; = {
        // Backend (alphabetized)
        &#39;.cs&#39;: &#39;csharp&#39;,
        &#39;.go&#39;: &#39;go&#39;,
        &#39;.java&#39;: &#39;java&#39;,
        &#39;.kt&#39;: &#39;kotlin&#39;,
        &#39;.lua&#39;: &#39;lua&#39;,
        &#39;.perl&#39;: &#39;perl&#39;,
        &#39;.php&#39;: &#39;php&#39;,
        &#39;.pl&#39;: &#39;perl&#39;,
        &#39;.py&#39;: &#39;python&#39;,
        &#39;.r&#39;: &#39;r&#39;,
        &#39;.rb&#39;: &#39;ruby&#39;,
        &#39;.rs&#39;: &#39;rust&#39;,
        &#39;.scala&#39;: &#39;scala&#39;,
        &#39;.swift&#39;: &#39;swift&#39;,
        
        // C/C++ (alphabetized)
        &#39;.c&#39;: &#39;c&#39;,
        &#39;.cc&#39;: &#39;cpp&#39;,
        &#39;.cpp&#39;: &#39;cpp&#39;,
        &#39;.cxx&#39;: &#39;cpp&#39;,
        &#39;.h&#39;: &#39;c&#39;,
        &#39;.hpp&#39;: &#39;cpp&#39;,
        &#39;.hxx&#39;: &#39;cpp&#39;,
        
        // Config (alphabetized)
        &#39;.env&#39;: &#39;bash&#39;,
        &#39;.ini&#39;: &#39;ini&#39;,
        &#39;.json&#39;: &#39;json&#39;,
        &#39;.toml&#39;: &#39;toml&#39;,
        &#39;.xml&#39;: &#39;xml&#39;,
        &#39;.yaml&#39;: &#39;yaml&#39;,
        &#39;.yml&#39;: &#39;yaml&#39;,
        
        // Database
        &#39;.sql&#39;: &#39;sql&#39;,
        
        // Documentation (alphabetized)
        &#39;.md&#39;: &#39;markdown&#39;,
        &#39;.mdx&#39;: &#39;markdown&#39;,
        &#39;.rst&#39;: &#39;rst&#39;,
        &#39;.tex&#39;: &#39;latex&#39;,
        
        // Godot (alphabetized)
        &#39;.cfg&#39;: &#39;ini&#39;,
        &#39;.gd&#39;: &#39;gdscript&#39;,
        &#39;.import&#39;: &#39;ini&#39;,
        &#39;.tres&#39;: &#39;gdscript&#39;,
        &#39;.tscn&#39;: &#39;gdscript&#39;,
        
        // Other (alphabetized)
        &#39;.cmake&#39;: &#39;cmake&#39;,
        &#39;.dockerfile&#39;: &#39;dockerfile&#39;,
        &#39;.Dockerfile&#39;: &#39;dockerfile&#39;,
        &#39;.gql&#39;: &#39;graphql&#39;,
        &#39;.gradle&#39;: &#39;gradle&#39;,
        &#39;.graphql&#39;: &#39;graphql&#39;,
        &#39;.makefile&#39;: &#39;makefile&#39;,
        &#39;.Makefile&#39;: &#39;makefile&#39;,
        &#39;.proto&#39;: &#39;protobuf&#39;,
        
        // Shell/Scripts (alphabetized)
        &#39;.bash&#39;: &#39;bash&#39;,
        &#39;.bat&#39;: &#39;batch&#39;,
        &#39;.cmd&#39;: &#39;batch&#39;,
        &#39;.fish&#39;: &#39;bash&#39;,
        &#39;.ps1&#39;: &#39;powershell&#39;,
        &#39;.sh&#39;: &#39;bash&#39;,
        &#39;.zsh&#39;: &#39;bash&#39;,
        
        // Web (alphabetized)
        &#39;.css&#39;: &#39;css&#39;,
        &#39;.html&#39;: &#39;html&#39;,
        &#39;.js&#39;: &#39;javascript&#39;,
        &#39;.jsx&#39;: &#39;jsx&#39;,
        &#39;.less&#39;: &#39;less&#39;,
        &#39;.sass&#39;: &#39;sass&#39;,
        &#39;.scss&#39;: &#39;scss&#39;,
        &#39;.svelte&#39;: &#39;svelte&#39;,
        &#39;.ts&#39;: &#39;typescript&#39;,
        &#39;.tsx&#39;: &#39;tsx&#39;,
        &#39;.vue&#39;: &#39;vue&#39;,
        
        // Files without extensions (alphabetized by basename)
        &#39;.gitattributes&#39;: &#39;text&#39;,
        &#39;.gitignore&#39;: &#39;text&#39;,
        &#39;.htaccess&#39;: &#39;apache&#39;,
        &#39;Cargo.lock&#39;: &#39;toml&#39;,
        &#39;Cargo.toml&#39;: &#39;toml&#39;,
        &#39;CMakeLists.txt&#39;: &#39;cmake&#39;,
        dockerfile: &#39;dockerfile&#39;,
        Dockerfile: &#39;dockerfile&#39;,
        Gemfile: &#39;ruby&#39;,
        &#39;go.mod&#39;: &#39;go&#39;,
        &#39;go.sum&#39;: &#39;text&#39;,
        Jenkinsfile: &#39;groovy&#39;,
        makefile: &#39;makefile&#39;,
        Makefile: &#39;makefile&#39;,
        &#39;nginx.conf&#39;: &#39;nginx&#39;,
        Rakefile: &#39;ruby&#39;,
        &#39;requirements.txt&#39;: &#39;text&#39;,
        Vagrantfile: &#39;ruby&#39;,
    };
    
    // Case-insensitive lookup with fallback to &#39;text&#39;
    const lang = languageMap[extensionOrBasename.toLowerCase()] ?? languageMap[extensionOrBasename];
    return lang ?? &#39;text&#39;;
}</code></pre>
    </div>

    <div class="file-section" id="tests-api-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/api.test.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for programmatic API
 */
import { existsSync } from &#39;node:fs&#39;;
import { join } from &#39;node:path&#39;;
import { mkdir, rm, writeFile } from &#39;node:fs/promises&#39;;
import { afterEach, beforeEach, describe, expect, it, vi } from &#39;vitest&#39;;
import { createConfig, fusionAPI, runFusion } from &#39;../src/api.js&#39;;
import { defaultConfig } from &#39;../src/utils.js&#39;;
import type { Config } from &#39;../src/types.js&#39;;

describe(&#39;API Tests&#39;, () =&gt; {
    const testDir = join(process.cwd(), &#39;temp&#39;, &#39;test-api&#39;);
    const testProjectDir = join(testDir, &#39;test-project&#39;);
    
    beforeEach(async () =&gt; {
        // Create test directories
        await mkdir(testProjectDir, { recursive: true });
        
        // Create test files
        await writeFile(join(testProjectDir, &#39;index.js&#39;), &#39;console.log(&quot;Hello&quot;);&#39;);
        await writeFile(join(testProjectDir, &#39;app.ts&#39;), &#39;const app = &quot;test&quot;;&#39;);
        await writeFile(join(testProjectDir, &#39;style.css&#39;), &#39;body { margin: 0; }&#39;);
        await writeFile(join(testProjectDir, &#39;config.json&#39;), &#39;{&quot;test&quot;: true}&#39;);
        await writeFile(join(testProjectDir, &#39;README.md&#39;), &#39;# Test Project&#39;);
        await writeFile(join(testProjectDir, &#39;script.py&#39;), &#39;print(&quot;Python&quot;)&#39;);
    });
    
    afterEach(async () =&gt; {
        // Clean up test directories
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        
        // Clean up generated files in current directory if any
        const generatedFiles = [
            &#39;project-fusioned.txt&#39;,
            &#39;project-fusioned.md&#39;,
            &#39;project-fusioned.html&#39;,
            &#39;project-fusioned.log&#39;
        ];
        for (const file of generatedFiles) {
            const filePath = join(testProjectDir, file);
            if (existsSync(filePath)) {
                await rm(filePath, { force: true });
            }
        }
    });
    
    describe(&#39;createConfig&#39;, () =&gt; {
        it(&#39;should create a complete config with defaults&#39;, () =&gt; {
            const config = createConfig();
            
            expect(config.schemaVersion).toBe(1);
            expect(config.copyToClipboard).toBe(defaultConfig.copyToClipboard);
            expect(config.generatedFileName).toBe(defaultConfig.generatedFileName);
            expect(config.generateHtml).toBe(defaultConfig.generateHtml);
            expect(config.generateMarkdown).toBe(defaultConfig.generateMarkdown);
            expect(config.generateText).toBe(defaultConfig.generateText);
            expect(config.maxFileSizeKB).toBe(defaultConfig.maxFileSizeKB);
            expect(config.parsedFileExtensions).toEqual(defaultConfig.parsedFileExtensions);
            expect(config.parseSubDirectories).toBe(defaultConfig.parseSubDirectories);
            expect(config.rootDirectory).toBe(process.cwd());
            expect(config.useGitIgnoreForExcludes).toBe(defaultConfig.useGitIgnoreForExcludes);
        });
        
        it(&#39;should override defaults with provided values&#39;, () =&gt; {
            const overrides = {
                generateHtml: false,
                maxFileSizeKB: 2048,
                rootDirectory: &#39;/custom/path&#39;
            };
            
            const config = createConfig(overrides);
            
            expect(config.generateHtml).toBe(false);
            expect(config.maxFileSizeKB).toBe(2048);
            expect(config.rootDirectory).toBe(&#39;/custom/path&#39;);
            expect(config.generateMarkdown).toBe(defaultConfig.generateMarkdown);
        });
        
        it(&#39;should handle partial parsedFileExtensions override&#39;, () =&gt; {
            const config = createConfig({
                parsedFileExtensions: {
                    web: [&#39;.ts&#39;, &#39;.tsx&#39;],
                    backend: [&#39;.py&#39;]
                }
            });
            
            expect(config.parsedFileExtensions).toEqual({
                web: [&#39;.ts&#39;, &#39;.tsx&#39;],
                backend: [&#39;.py&#39;]
            });
        });
    });
    
    describe(&#39;fusionAPI&#39;, () =&gt; {
        it(&#39;should process fusion with default config&#39;, async () =&gt; {
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            expect(result.message).toContain(&#39;Fusion completed&#39;);
            expect(result.fusionFilePath).toBeDefined();
            expect(result.logFilePath).toBeDefined();
            
            // Check files were created
            expect(existsSync(join(testProjectDir, &#39;project-fusioned.txt&#39;))).toBe(true);
            expect(existsSync(join(testProjectDir, &#39;project-fusioned.md&#39;))).toBe(true);
            expect(existsSync(join(testProjectDir, &#39;project-fusioned.log&#39;))).toBe(true);
        });
        
        it(&#39;should handle custom extensions&#39;, async () =&gt; {
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                parsedFileExtensions: {
                    web: [&#39;.js&#39;, &#39;.ts&#39;],
                    backend: [],
                    config: [],
                    cpp: [],
                    doc: [],
                    godot: [],
                    scripts: []
                },
                generateHtml: false,
                generateMarkdown: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            
            // Check that only .js and .ts files were processed
            const content = await import(&#39;node:fs&#39;).then(fs =&gt; 
                fs.promises.readFile(join(testProjectDir, &#39;project-fusioned.txt&#39;), &#39;utf8&#39;)
            );
            expect(content).toContain(&#39;index.js&#39;);
            expect(content).toContain(&#39;app.ts&#39;);
            expect(content).not.toContain(&#39;style.css&#39;);
            expect(content).not.toContain(&#39;config.json&#39;);
        });
        
        it(&#39;should respect extensionGroups filter&#39;, async () =&gt; {
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                extensionGroups: [&#39;web&#39;],
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            
            const content = await import(&#39;node:fs&#39;).then(fs =&gt; 
                fs.promises.readFile(join(testProjectDir, &#39;project-fusioned.txt&#39;), &#39;utf8&#39;)
            );
            expect(content).toContain(&#39;index.js&#39;);
            expect(content).toContain(&#39;app.ts&#39;);
            expect(content).toContain(&#39;style.css&#39;);
            expect(content).not.toContain(&#39;config.json&#39;);
            expect(content).not.toContain(&#39;script.py&#39;);
        });
        
        it(&#39;should handle rootDir option&#39;, async () =&gt; {
            const result = await fusionAPI({
                cwd: testDir,
                rootDir: &#39;test-project&#39;,
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            expect(existsSync(join(testProjectDir, &#39;project-fusioned.txt&#39;))).toBe(true);
        });
        
        it(&#39;should handle errors gracefully&#39;, async () =&gt; {
            const result = await fusionAPI({
                rootDirectory: &#39;/non/existent/path&#39;,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(false);
            expect(result.message).toContain(&#39;failed&#39;);
            expect(result.error).toBeDefined();
        });
    });
    
    describe(&#39;runFusion&#39;, () =&gt; {
        it(&#39;should work with partial config&#39;, async () =&gt; {
            const result = await runFusion({
                rootDirectory: testProjectDir,
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            expect(result.message).toContain(&#39;Fusion completed&#39;);
        });
        
        it(&#39;should work with complete config&#39;, async () =&gt; {
            const config = createConfig({
                rootDirectory: testProjectDir,
                generateHtml: false,
                generateMarkdown: false,
                copyToClipboard: false
            });
            
            const result = await runFusion(config);
            
            expect(result.success).toBe(true);
            expect(existsSync(join(testProjectDir, &#39;project-fusioned.txt&#39;))).toBe(true);
            expect(existsSync(join(testProjectDir, &#39;project-fusioned.md&#39;))).toBe(false);
            expect(existsSync(join(testProjectDir, &#39;project-fusioned.html&#39;))).toBe(false);
        });
        
        it(&#39;should accept fusion options&#39;, async () =&gt; {
            const result = await runFusion(
                { rootDirectory: testProjectDir, copyToClipboard: false },
                { extensionGroups: [&#39;config&#39;, &#39;doc&#39;] }
            );
            
            expect(result.success).toBe(true);
            
            const content = await import(&#39;node:fs&#39;).then(fs =&gt; 
                fs.promises.readFile(join(testProjectDir, &#39;project-fusioned.txt&#39;), &#39;utf8&#39;)
            );
            expect(content).toContain(&#39;config.json&#39;);
            expect(content).toContain(&#39;README.md&#39;);
            expect(content).not.toContain(&#39;index.js&#39;);
            expect(content).not.toContain(&#39;script.py&#39;);
        });
        
        it(&#39;should handle empty extension groups&#39;, async () =&gt; {
            const result = await runFusion(
                { 
                    rootDirectory: testProjectDir,
                    parsedFileExtensions: {
                        backend: [],
                        config: [],
                        cpp: [],
                        doc: [],
                        godot: [],
                        scripts: [],
                        web: []
                    },
                    copyToClipboard: false
                }
            );
            
            expect(result.success).toBe(false);
            expect(result.message).toContain(&#39;No file extensions to process&#39;);
        });
    });
    
    describe(&#39;Integration Tests&#39;, () =&gt; {
        it(&#39;should handle complex nested project structure&#39;, async () =&gt; {
            // Create nested structure
            const nestedDir = join(testProjectDir, &#39;src&#39;, &#39;components&#39;);
            await mkdir(nestedDir, { recursive: true });
            await writeFile(join(nestedDir, &#39;Button.tsx&#39;), &#39;export const Button = () =&gt; &lt;button /&gt;;&#39;);
            await writeFile(join(nestedDir, &#39;Card.tsx&#39;), &#39;export const Card = () =&gt; &lt;div /&gt;;&#39;);
            
            const utilsDir = join(testProjectDir, &#39;src&#39;, &#39;utils&#39;);
            await mkdir(utilsDir, { recursive: true });
            await writeFile(join(utilsDir, &#39;helpers.ts&#39;), &#39;export const helper = () =&gt; {};&#39;);
            
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                parseSubDirectories: true,
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            
            const content = await import(&#39;node:fs&#39;).then(fs =&gt; 
                fs.promises.readFile(join(testProjectDir, &#39;project-fusioned.txt&#39;), &#39;utf8&#39;)
            );
            expect(content).toContain(&#39;Button.tsx&#39;);
            expect(content).toContain(&#39;Card.tsx&#39;);
            expect(content).toContain(&#39;helpers.ts&#39;);
        });
        
        it(&#39;should respect ignore patterns&#39;, async () =&gt; {
            // Create test files
            await writeFile(join(testProjectDir, &#39;test.example.js&#39;), &#39;console.log(&quot;test example&quot;);&#39;);
            await writeFile(join(testProjectDir, &#39;.env&#39;), &#39;SECRET=123&#39;);
            await writeFile(join(testProjectDir, &#39;main.ts&#39;), &#39;const main = () =&gt; {};&#39;);
            
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                ignorePatterns: [&#39;*.example.js&#39;, &#39;.env&#39;],
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            
            const content = await import(&#39;node:fs&#39;).then(fs =&gt; 
                fs.promises.readFile(join(testProjectDir, &#39;project-fusioned.txt&#39;), &#39;utf8&#39;)
            );
            expect(content).toContain(&#39;main.ts&#39;);
            expect(content).not.toContain(&#39;test.example.js&#39;);
            expect(content).not.toContain(&#39;.env&#39;);
        });
        
        it(&#39;should handle file size limits&#39;, async () =&gt; {
            // Create a large file
            const largeContent = &#39;x&#39;.repeat(2 * 1024 * 1024); // 2MB
            await writeFile(join(testProjectDir, &#39;large.js&#39;), largeContent);
            
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                maxFileSizeKB: 1024, // 1MB limit
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            
            const content = await import(&#39;node:fs&#39;).then(fs =&gt; 
                fs.promises.readFile(join(testProjectDir, &#39;project-fusioned.txt&#39;), &#39;utf8&#39;)
            );
            expect(content).not.toContain(&#39;large.js&#39;);
            expect(content).toContain(&#39;index.js&#39;); // Small files should still be included
        });
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-architecture-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/architecture.test.ts</h2>
        </div>
        <pre><code class="typescript">import { describe, it, expect, beforeEach, afterEach } from &#39;vitest&#39;;
import fs from &#39;fs-extra&#39;;
import path from &#39;node:path&#39;;
import { 
    DefaultFileSystemAdapter, 
    MemoryFileSystemAdapter,
    OutputStrategyManager,
    TextOutputStrategy,
    MarkdownOutputStrategy,
    HtmlOutputStrategy,
    PluginManager,
    createPlugin,
    processFusion
} from &#39;../src/index.js&#39;;
import { createFilePath, type Config } from &#39;../src/types.js&#39;;

const tempDir = path.join(process.cwd(), &#39;temp&#39;, &#39;architecture-tests&#39;);

describe(&#39;Architecture Tests&#39;, () =&gt; {
    beforeEach(async () =&gt; {
        await fs.ensureDir(tempDir);
        await fs.emptyDir(tempDir);
    });

    afterEach(async () =&gt; {
        await fs.remove(tempDir);
    });

    describe(&#39;FileSystemAdapter&#39;, () =&gt; {
        it(&#39;should provide consistent interface between adapters&#39;, async () =&gt; {
            const defaultFs = new DefaultFileSystemAdapter();
            const memoryFs = new MemoryFileSystemAdapter();

            const testFilePath = createFilePath(path.join(tempDir, &#39;test.txt&#39;));
            const content = &#39;Hello World&#39;;

            await defaultFs.writeFile(testFilePath, content);
            memoryFs.addFile(testFilePath, content);

            expect(await defaultFs.readFile(testFilePath)).toBe(content);
            expect(await memoryFs.readFile(testFilePath)).toBe(content);

            const defaultStats = await defaultFs.stat(testFilePath);
            const memoryStats = await memoryFs.stat(testFilePath);

            expect(defaultStats.isFile).toBe(true);
            expect(memoryStats.isFile).toBe(true);
            expect(defaultStats.size).toBeGreaterThan(0);
            expect(memoryStats.size).toBeGreaterThan(0);
        });
    });

    describe(&#39;OutputStrategy Pattern&#39;, () =&gt; {
        it(&#39;should provide consistent output generation across strategies&#39;, async () =&gt; {
            const manager = new OutputStrategyManager();
            const memoryFs = new MemoryFileSystemAdapter();

            const context = {
                projectTitle: &#39;Test Project&#39;,
                versionInfo: &#39; v1.0.0&#39;,
                filesToProcess: [{
                    content: &#39;console.log(&quot;hello&quot;);&#39;,
                    relativePath: &#39;test.js&#39;,
                    path: createFilePath(&#39;/test.js&#39;),
                    size: 100
                }],
                config: {
                    rootDirectory: tempDir,
                    generatedFileName: &#39;test-fusion&#39;
                } as Config
            };

            const textStrategy = manager.getStrategy(&#39;text&#39;);
            const mdStrategy = manager.getStrategy(&#39;markdown&#39;);
            const htmlStrategy = manager.getStrategy(&#39;html&#39;);

            expect(textStrategy).toBeDefined();
            expect(mdStrategy).toBeDefined();
            expect(htmlStrategy).toBeDefined();

            if (textStrategy &amp;&amp; mdStrategy &amp;&amp; htmlStrategy) {
                const textOutput = await manager.generateOutput(textStrategy, context, memoryFs);
                const mdOutput = await manager.generateOutput(mdStrategy, context, memoryFs);
                const htmlOutput = await manager.generateOutput(htmlStrategy, context, memoryFs);

                expect(textOutput).toContain(&#39;.txt&#39;);
                expect(mdOutput).toContain(&#39;.md&#39;);
                expect(htmlOutput).toContain(&#39;.html&#39;);

                const textContent = await memoryFs.readFile(textOutput);
                const mdContent = await memoryFs.readFile(mdOutput);
                const htmlContent = await memoryFs.readFile(htmlOutput);

                expect(textContent).toContain(&#39;console.log(&quot;hello&quot;);&#39;);
                expect(mdContent).toContain(&#39;console.log(&quot;hello&quot;);&#39;);
                expect(htmlContent).toContain(&#39;console.log(&amp;quot;hello&amp;quot;);&#39;);
            }
        });
    });

    describe(&#39;Plugin System&#39;, () =&gt; {
        it(&#39;should support plugin registration and execution&#39;, async () =&gt; {
            const fs = new MemoryFileSystemAdapter();
            const manager = new PluginManager(fs);

            let beforeCalled = false;
            let afterCalled = false;

            const testPlugin = createPlugin(
                {
                    name: &#39;test-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Test plugin&#39;
                },
                {
                    beforeFileProcessing: async (fileInfo) =&gt; {
                        beforeCalled = true;
                        return fileInfo;
                    },
                    afterFileProcessing: async (fileInfo, content) =&gt; {
                        afterCalled = true;
                        return content + &#39;\n// Plugin processed&#39;;
                    }
                }
            );

            manager.registerPlugin(testPlugin);
            manager.configurePlugin(&#39;test-plugin&#39;, { name: &#39;test-plugin&#39;, enabled: true });

            const fileInfo = {
                content: &#39;test content&#39;,
                relativePath: &#39;test.js&#39;,
                path: createFilePath(&#39;/test.js&#39;),
                size: 100
            };

            const config = { rootDirectory: tempDir } as Config;

            const processedFile = await manager.executeBeforeFileProcessing(fileInfo, config);
            expect(beforeCalled).toBe(true);
            expect(processedFile).toEqual(fileInfo);

            const processedContent = await manager.executeAfterFileProcessing(fileInfo, &#39;content&#39;, config);
            expect(afterCalled).toBe(true);
            expect(processedContent).toBe(&#39;content\n// Plugin processed&#39;);
        });
    });

    describe(&#39;Fusion V2 Integration&#39;, () =&gt; {
        it(&#39;should process fusion with new architecture&#39;, async () =&gt; {
            const testDir = path.join(tempDir, &#39;fusion-v2-test&#39;);
            await fs.ensureDir(testDir);

            await fs.writeFile(path.join(testDir, &#39;test.js&#39;), &#39;console.log(&quot;test&quot;);&#39;);
            await fs.writeFile(path.join(testDir, &#39;test.ts&#39;), &#39;const x: string = &quot;test&quot;;&#39;);

            const config: Config = {
                schemaVersion: 1,
                copyToClipboard: false,
                generatedFileName: &#39;test-fusion&#39;,
                generateHtml: true,
                generateMarkdown: true,
                generateText: true,
                maxFileSizeKB: 1024,
                parseSubDirectories: false,
                parsedFileExtensions: {
                    web: [&#39;.js&#39;, &#39;.ts&#39;]
                },
                ignorePatterns: [],
                rootDirectory: testDir,
                useGitIgnoreForExcludes: false
            };

            const result = await processFusion(config, {
                extensionGroups: [&#39;web&#39;]
            });

            expect(result.success).toBe(true);
            expect(result.message).toContain(&#39;2 files processed&#39;);

            const txtPath = path.join(testDir, &#39;test-fusion.txt&#39;);
            const mdPath = path.join(testDir, &#39;test-fusion.md&#39;);
            const htmlPath = path.join(testDir, &#39;test-fusion.html&#39;);

            expect(await fs.pathExists(txtPath)).toBe(true);
            expect(await fs.pathExists(mdPath)).toBe(true);
            expect(await fs.pathExists(htmlPath)).toBe(true);

            const txtContent = await fs.readFile(txtPath, &#39;utf8&#39;);
            const mdContent = await fs.readFile(mdPath, &#39;utf8&#39;);
            const htmlContent = await fs.readFile(htmlPath, &#39;utf8&#39;);

            expect(txtContent).toContain(&#39;console.log(&quot;test&quot;);&#39;);
            expect(txtContent).toContain(&#39;const x: string = &quot;test&quot;;&#39;);

            expect(mdContent).toContain(&#39;```javascript&#39;);
            expect(mdContent).toContain(&#39;```typescript&#39;);

            expect(htmlContent).toContain(&#39;&lt;html&#39;);
            expect(htmlContent).toContain(&#39;&lt;/html&gt;&#39;);
        });
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-benchmark-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/benchmark.test.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for benchmark functionality
 */
import { describe, expect, it, vi, beforeEach, afterEach } from &#39;vitest&#39;;
import { BenchmarkTracker } from &#39;../src/benchmark.js&#39;;

describe(&#39;BenchmarkTracker&#39;, () =&gt; {
    let originalMemoryUsage: NodeJS.MemoryUsage;
    
    beforeEach(() =&gt; {
        // Mock process.memoryUsage
        originalMemoryUsage = process.memoryUsage();
        vi.spyOn(process, &#39;memoryUsage&#39;).mockReturnValue({
            rss: 100 * 1024 * 1024, // 100MB
            heapTotal: 80 * 1024 * 1024,
            heapUsed: 50 * 1024 * 1024,
            external: 10 * 1024 * 1024,
            arrayBuffers: 5 * 1024 * 1024
        });
    });
    
    afterEach(() =&gt; {
        vi.restoreAllMocks();
    });
    
    describe(&#39;constructor&#39;, () =&gt; {
        it(&#39;should initialize with zero values&#39;, () =&gt; {
            const tracker = new BenchmarkTracker();
            const metrics = tracker.getMetrics();
            
            expect(metrics.filesProcessed).toBe(0);
            expect(metrics.totalBytesProcessed).toBe(0);
            expect(metrics.memoryUsedMB).toBeGreaterThan(0);
            expect(metrics.processingTimeMs).toBeGreaterThanOrEqual(0);
        });
    });
    
    describe(&#39;markFileProcessed&#39;, () =&gt; {
        it(&#39;should track file metrics&#39;, () =&gt; {
            const tracker = new BenchmarkTracker();
            
            tracker.markFileProcessed(1024);
            tracker.markFileProcessed(2048);
            
            const metrics = tracker.getMetrics();
            expect(metrics.filesProcessed).toBe(2);
            expect(metrics.totalBytesProcessed).toBe(3072);
        });
        
        it(&#39;should handle empty files&#39;, () =&gt; {
            const tracker = new BenchmarkTracker();
            
            tracker.markFileProcessed(0);
            
            const metrics = tracker.getMetrics();
            expect(metrics.filesProcessed).toBe(1);
            expect(metrics.totalBytesProcessed).toBe(0);
        });
        
        it(&#39;should handle large files&#39;, () =&gt; {
            const tracker = new BenchmarkTracker();
            const largeSize = 10 * 1024 * 1024; // 10MB
            
            tracker.markFileProcessed(largeSize);
            
            const metrics = tracker.getMetrics();
            expect(metrics.filesProcessed).toBe(1);
            expect(metrics.totalBytesProcessed).toBe(largeSize);
        });
    });
    
    describe(&#39;getMetrics&#39;, () =&gt; {
        it(&#39;should calculate processing time&#39;, async () =&gt; {
            const tracker = new BenchmarkTracker();
            
            // Wait a bit to ensure processing time &gt; 0
            await new Promise(resolve =&gt; setTimeout(resolve, 10));
            
            const metrics = tracker.getMetrics();
            expect(metrics.processingTimeMs).toBeGreaterThan(0);
        });
        
        it(&#39;should calculate throughput correctly&#39;, () =&gt; {
            const tracker = new BenchmarkTracker();
            
            // Add files
            tracker.markFileProcessed(1024 * 1024); // 1MB
            tracker.markFileProcessed(1024 * 1024); // 1MB
            
            const metrics = tracker.getMetrics();
            
            // Throughput should be total bytes / time in seconds
            if (metrics.processingTimeMs &gt; 0) {
                const expectedThroughput = (2 * 1024 * 1024) / (metrics.processingTimeMs / 1000);
                expect(metrics.throughputBytesPerSec).toBeCloseTo(expectedThroughput, 0);
            }
        });
        
        it(&#39;should handle zero processing time&#39;, () =&gt; {
            const tracker = new BenchmarkTracker();
            
            // Mock Date.now to return same value
            const now = Date.now();
            vi.spyOn(Date, &#39;now&#39;).mockReturnValue(now);
            
            tracker.markFileProcessed(1024);
            const metrics = tracker.getMetrics();
            
            expect(metrics.processingTimeMs).toBe(0);
            expect(metrics.throughputBytesPerSec).toBe(0);
        });
        
        it(&#39;should report memory usage&#39;, () =&gt; {
            const tracker = new BenchmarkTracker();
            const metrics = tracker.getMetrics();
            
            // Based on our mock: 50MB heap used
            expect(metrics.memoryUsedMB).toBeCloseTo(50, 1);
        });
    });
    
    
    describe(&#39;Edge Cases&#39;, () =&gt; {
        it(&#39;should handle rapid successive recordings&#39;, () =&gt; {
            const tracker = new BenchmarkTracker();
            
            for (let i = 0; i &lt; 1000; i++) {
                tracker.markFileProcessed(i);
            }
            
            const metrics = tracker.getMetrics();
            expect(metrics.filesProcessed).toBe(1000);
            expect(metrics.totalBytesProcessed).toBe(499500); // Sum of 0 to 999
        });
        
        it(&#39;should handle special characters in filenames&#39;, () =&gt; {
            const tracker = new BenchmarkTracker();
            
            tracker.markFileProcessed(100);
            tracker.markFileProcessed(200);
            tracker.markFileProcessed(300);
            tracker.markFileProcessed(400);
            
            const metrics = tracker.getMetrics();
            expect(metrics.filesProcessed).toBe(4);
            expect(metrics.totalBytesProcessed).toBe(1000);
        });
        
        it(&#39;should maintain accuracy with floating point sizes&#39;, () =&gt; {
            const tracker = new BenchmarkTracker();
            
            tracker.markFileProcessed(0.1);
            tracker.markFileProcessed(0.2);
            tracker.markFileProcessed(0.3);
            
            const metrics = tracker.getMetrics();
            expect(metrics.totalBytesProcessed).toBeCloseTo(0.6, 10);
        });
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-cli-e2e-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/cli-e2e.test.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * End-to-end CLI tests for Project Fusion
 */
import { describe, it, expect, beforeEach, afterEach } from &#39;vitest&#39;;
import { execSync } from &#39;node:child_process&#39;;
import { join } from &#39;node:path&#39;;
import { writeFile, mkdir, rm, readFile, access } from &#39;node:fs/promises&#39;;
import { existsSync } from &#39;node:fs&#39;;

describe(&#39;CLI E2E Tests&#39;, () =&gt; {
    const testDir = join(process.cwd(), &#39;temp&#39;, &#39;cli-e2e-test&#39;);
    const originalCwd = process.cwd();
    const cliBin = join(process.cwd(), &#39;dist&#39;, &#39;cli.js&#39;);

    beforeEach(async () =&gt; {
        // Clean up and create test directory
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        await mkdir(testDir, { recursive: true });
        
        // Build the project to ensure CLI is available
        try {
            execSync(&#39;npm run build&#39;, { cwd: process.cwd(), stdio: &#39;pipe&#39; });
        } catch (error) {
            console.warn(&#39;Build failed, continuing with existing dist&#39;);
        }
        
        process.chdir(testDir);
    });

    afterEach(async () =&gt; {
        process.chdir(originalCwd);
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    describe(&#39;Default Command&#39;, () =&gt; {
        it(&#39;should create fusion files with default settings&#39;, async () =&gt; {
            // Create sample files
            await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;Hello, World!&quot;);&#39;);
            await writeFile(&#39;test.ts&#39;, &#39;const message: string = &quot;TypeScript&quot;;&#39;);
            
            // Run the CLI
            const output = execSync(`node &quot;${cliBin}&quot;`, { 
                encoding: &#39;utf8&#39;,
                env: { ...process.env, CI: &#39;true&#39; } // Disable clipboard and TTY
            });
            
            // Check output contains success message
            expect(output).toContain(&#39;‚úÖ&#39;);
            expect(output).toContain(&#39;files processed&#39;);
            expect(output).toContain(&#39;Generated files:&#39;);
            
            // Check that fusion files were created
            expect(existsSync(&#39;project-fusioned.txt&#39;)).toBe(true);
            expect(existsSync(&#39;project-fusioned.md&#39;)).toBe(true);
            expect(existsSync(&#39;project-fusioned.html&#39;)).toBe(true);
            expect(existsSync(&#39;project-fusioned.log&#39;)).toBe(true);
            
            // Check content of text file
            const txtContent = await readFile(&#39;project-fusioned.txt&#39;, &#39;utf8&#39;);
            expect(txtContent).toContain(&#39;test.js&#39;);
            expect(txtContent).toContain(&#39;test.ts&#39;);
            expect(txtContent).toContain(&#39;Hello, World!&#39;);
            expect(txtContent).toContain(&#39;TypeScript&#39;);
            
            // Check content of markdown file
            const mdContent = await readFile(&#39;project-fusioned.md&#39;, &#39;utf8&#39;);
            expect(mdContent).toContain(&#39;## üìÑ test.js&#39;);
            expect(mdContent).toContain(&#39;## üìÑ test.ts&#39;);
            expect(mdContent).toContain(&#39;```javascript&#39;);
            expect(mdContent).toContain(&#39;```typescript&#39;);
            
            // Check content of HTML file
            const htmlContent = await readFile(&#39;project-fusioned.html&#39;, &#39;utf8&#39;);
            expect(htmlContent).toContain(&#39;&lt;!DOCTYPE html&gt;&#39;);
            expect(htmlContent).toContain(&#39;üìÑ test.js&#39;);
            expect(htmlContent).toContain(&#39;üìÑ test.ts&#39;);
            expect(htmlContent).toContain(&#39;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&#39;);
            expect(htmlContent).toContain(&#39;&lt;pre&gt;&lt;code class=&quot;typescript&quot;&gt;&#39;);
        });

        it(&#39;should handle empty directory gracefully&#39;, async () =&gt; {
            // Run CLI in empty directory
            const output = execSync(`node &quot;${cliBin}&quot;`, { 
                encoding: &#39;utf8&#39;,
                env: { ...process.env, CI: &#39;true&#39; }
            });
            
            expect(output).toContain(&#39;‚ùå&#39;);
            expect(output).toContain(&#39;No files found to process&#39;);
            
            // Should still create a log file
            expect(existsSync(&#39;project-fusioned.log&#39;)).toBe(true);
        });

        it(&#39;should respect command line options&#39;, async () =&gt; {
            // Create sample files
            await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;Test&quot;);&#39;);
            await writeFile(&#39;test.py&#39;, &#39;print(&quot;Python&quot;)&#39;);
            
            // Run CLI with specific root directory and extensions
            const output = execSync(`node &quot;${cliBin}&quot; --extensions web`, { 
                encoding: &#39;utf8&#39;,
                env: { ...process.env, CI: &#39;true&#39; }
            });
            
            expect(output).toContain(&#39;‚úÖ&#39;);
            expect(output).toContain(&#39;Using extension groups: web&#39;);
            
            // Check that only JS file was processed (web extensions)
            const txtContent = await readFile(&#39;project-fusioned.txt&#39;, &#39;utf8&#39;);
            expect(txtContent).toContain(&#39;test.js&#39;);
            expect(txtContent).not.toContain(&#39;test.py&#39;); // Python not in web group
        });
    });

    describe(&#39;Init Command&#39;, () =&gt; {
        it(&#39;should create configuration file&#39;, async () =&gt; {
            const output = execSync(`node &quot;${cliBin}&quot; init`, { 
                encoding: &#39;utf8&#39;,
                env: { ...process.env, CI: &#39;true&#39; }
            });
            
            expect(output).toContain(&#39;‚úÖ Project Fusion initialized successfully!&#39;);
            expect(output).toContain(&#39;Created:&#39;);
            expect(output).toContain(&#39;project-fusion.json&#39;);
            
            // Check config file was created
            expect(existsSync(&#39;project-fusion.json&#39;)).toBe(true);
            
            // Validate config content
            const config = JSON.parse(await readFile(&#39;project-fusion.json&#39;, &#39;utf8&#39;));
            expect(config).toHaveProperty(&#39;schemaVersion&#39;, 1);
            expect(config).toHaveProperty(&#39;generatedFileName&#39;, &#39;project-fusioned&#39;);
            expect(config).toHaveProperty(&#39;parsedFileExtensions&#39;);
            expect(config.parsedFileExtensions).toHaveProperty(&#39;web&#39;);
            expect(config.parsedFileExtensions).toHaveProperty(&#39;backend&#39;);
        });

        it(&#39;should not overwrite existing config without force flag&#39;, async () =&gt; {
            // Create initial config
            await writeFile(&#39;project-fusion.json&#39;, &#39;{&quot;custom&quot;: &quot;config&quot;}&#39;);
            
            // Try to init again without force
            try {
                execSync(`node &quot;${cliBin}&quot; init`, { 
                    encoding: &#39;utf8&#39;,
                    env: { ...process.env, CI: &#39;true&#39; }
                });
                expect.fail(&#39;Should have thrown an error&#39;);
            } catch (error: any) {
                expect(error.status).toBe(1);
                expect(error.stdout).toContain(&#39;already exists&#39;);
                expect(error.stdout).toContain(&#39;Use --force to override&#39;);
            }
            
            // Config should be unchanged
            const config = await readFile(&#39;project-fusion.json&#39;, &#39;utf8&#39;);
            expect(config).toContain(&#39;&quot;custom&quot;: &quot;config&quot;&#39;);
        });

        it(&#39;should overwrite existing config with force flag&#39;, async () =&gt; {
            // Create initial config
            await writeFile(&#39;project-fusion.json&#39;, &#39;{&quot;custom&quot;: &quot;config&quot;}&#39;);
            
            // Init with force flag
            const output = execSync(`node &quot;${cliBin}&quot; init --force`, { 
                encoding: &#39;utf8&#39;,
                env: { ...process.env, CI: &#39;true&#39; }
            });
            
            expect(output).toContain(&#39;‚úÖ Project Fusion initialized successfully!&#39;);
            expect(output).toContain(&#39;Overriding existing configuration&#39;);
            
            // Config should be replaced with default
            const config = JSON.parse(await readFile(&#39;project-fusion.json&#39;, &#39;utf8&#39;));
            expect(config).not.toHaveProperty(&#39;custom&#39;);
            expect(config).toHaveProperty(&#39;schemaVersion&#39;, 1);
        });
    });

    describe(&#39;Config Check Command&#39;, () =&gt; {
        it(&#39;should validate valid configuration&#39;, async () =&gt; {
            // Create valid config
            const validConfig = {
                schemaVersion: 1,
                generatedFileName: &quot;test-fusion&quot;,
                generateHtml: true,
                generateMarkdown: true,
                generateText: true,
                maxFileSizeKB: 1024,
                parseSubDirectories: true,
                parsedFileExtensions: {
                    web: [&quot;.js&quot;, &quot;.ts&quot;],
                    backend: [&quot;.py&quot;]
                },
                rootDirectory: &quot;.&quot;,
                useGitIgnoreForExcludes: true,
                copyToClipboard: false,
                ignorePatterns: [&quot;node_modules/&quot;]
            };
            
            await writeFile(&#39;project-fusion.json&#39;, JSON.stringify(validConfig, null, 2));
            
            const output = execSync(`node &quot;${cliBin}&quot; config-check`, { 
                encoding: &#39;utf8&#39;,
                env: { ...process.env, CI: &#39;true&#39; }
            });
            
            expect(output).toContain(&#39;‚úÖ Configuration is valid!&#39;);
            expect(output).toContain(&#39;Configuration Summary:&#39;);
            expect(output).toContain(&#39;Schema Version: 1&#39;);
            expect(output).toContain(&#39;Generated File Name: test-fusion&#39;);
            expect(output).toContain(&#39;web: 2 extensions (.js, .ts)&#39;);
            expect(output).toContain(&#39;backend: 1 extensions (.py)&#39;);
        });

        it(&#39;should handle invalid configuration&#39;, async () =&gt; {
            // Create invalid config
            const invalidConfig = {
                schemaVersion: &quot;invalid&quot;,
                generateHtml: &quot;not-boolean&quot;,
                parsedFileExtensions: &quot;not-object&quot;
            };
            
            await writeFile(&#39;project-fusion.json&#39;, JSON.stringify(invalidConfig));
            
            try {
                execSync(`node &quot;${cliBin}&quot; config-check`, { 
                    encoding: &#39;utf8&#39;,
                    env: { ...process.env, CI: &#39;true&#39; }
                });
                expect.fail(&#39;Should have thrown an error&#39;);
            } catch (error: any) {
                expect(error.status).toBe(1);
                expect(error.stdout).toContain(&#39;‚ùå Configuration validation failed:&#39;);
                expect(error.stdout).toContain(&#39;schemaVersion&#39;);
                expect(error.stdout).toContain(&#39;expected 1&#39;);
            }
        });

        it(&#39;should handle missing configuration file&#39;, async () =&gt; {
            const output = execSync(`node &quot;${cliBin}&quot; config-check`, { 
                encoding: &#39;utf8&#39;,
                env: { ...process.env, CI: &#39;true&#39; }
            });
            
            expect(output).toContain(&#39;‚ö†Ô∏è No project-fusion.json found.&#39;);
            expect(output).toContain(&#39;Using default configuration.&#39;);
            expect(output).toContain(&#39;Configuration Summary:&#39;);
            expect(output).toContain(&#39;(Using default configuration)&#39;);
        });

        it(&#39;should handle malformed JSON&#39;, async () =&gt; {
            // Create malformed JSON
            await writeFile(&#39;project-fusion.json&#39;, &#39;{ invalid json&#39;);
            
            try {
                execSync(`node &quot;${cliBin}&quot; config-check`, { 
                    encoding: &#39;utf8&#39;,
                    env: { ...process.env, CI: &#39;true&#39; }
                });
                expect.fail(&#39;Should have thrown an error&#39;);
            } catch (error: any) {
                expect(error.status).toBe(1);
                expect(error.stdout).toContain(&#39;‚ùå Invalid JSON in configuration file:&#39;);
            }
        });
    });

    describe(&#39;Clipboard and Environment Handling&#39;, () =&gt; {
        it(&#39;should skip clipboard copy in CI environment&#39;, async () =&gt; {
            // Create sample file
            await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;test&quot;);&#39;);
            
            // Create config with clipboard enabled
            const configWithClipboard = {
                schemaVersion: 1,
                copyToClipboard: true,
                generatedFileName: &quot;project-fusioned&quot;,
                generateHtml: true,
                generateMarkdown: true,
                generateText: true,
                maxFileSizeKB: 1024,
                parseSubDirectories: true,
                parsedFileExtensions: { web: [&quot;.js&quot;] },
                rootDirectory: &quot;.&quot;,
                useGitIgnoreForExcludes: true,
                ignorePatterns: []
            };
            
            await writeFile(&#39;project-fusion.json&#39;, JSON.stringify(configWithClipboard));
            
            const output = execSync(`node &quot;${cliBin}&quot;`, { 
                encoding: &#39;utf8&#39;,
                env: { ...process.env, CI: &#39;true&#39; } // Simulate CI environment
            });
            
            expect(output).toContain(&#39;‚úÖ&#39;);
            expect(output).toContain(&#39;üìã Clipboard copy skipped (non-interactive environment)&#39;);
        });

        it(&#39;should handle non-TTY environment&#39;, async () =&gt; {
            // Create sample file
            await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;test&quot;);&#39;);
            
            const output = execSync(`node &quot;${cliBin}&quot;`, { 
                encoding: &#39;utf8&#39;,
                env: { ...process.env, CI: &#39;false&#39; }, // Not CI but still non-TTY via execSync
                stdio: [&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;] // Force non-TTY
            });
            
            expect(output).toContain(&#39;‚úÖ&#39;);
            // Should not attempt clipboard copy even without CI flag due to non-TTY
        });
    });

    describe(&#39;Error Handling&#39;, () =&gt; {
        it(&#39;should handle invalid command line options&#39;, async () =&gt; {
            try {
                execSync(`node &quot;${cliBin}&quot; --unknown-option`, { 
                    encoding: &#39;utf8&#39;,
                    env: { ...process.env, CI: &#39;true&#39; }
                });
                expect.fail(&#39;Should have thrown an error&#39;);
            } catch (error: any) {
                expect(error.status).toBe(1);
                // Commander.js should show help after error
                expect(error.stdout || error.stderr).toContain(&#39;Usage:&#39;);
            }
        });

        it(&#39;should show help information&#39;, async () =&gt; {
            const output = execSync(`node &quot;${cliBin}&quot; --help`, { 
                encoding: &#39;utf8&#39;,
                env: { ...process.env, CI: &#39;true&#39; }
            });
            
            expect(output).toContain(&#39;Usage:&#39;);
            expect(output).toContain(&#39;project-fusion&#39;);
            expect(output).toContain(&#39;init&#39;);
            expect(output).toContain(&#39;config-check&#39;);
            expect(output).toContain(&#39;Options:&#39;);
        });

        it(&#39;should show version information&#39;, async () =&gt; {
            const output = execSync(`node &quot;${cliBin}&quot; --version`, { 
                encoding: &#39;utf8&#39;,
                env: { ...process.env, CI: &#39;true&#39; }
            });
            
            expect(output.trim()).toMatch(/^\d+\.\d+\.\d+$/); // Version format
        });
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-clicommands-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/clicommands.test.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for CLI commands
 */
import { describe, it, expect, beforeEach, afterEach, vi } from &#39;vitest&#39;;
import { join } from &#39;node:path&#39;;
import { writeFile, mkdir, rm, readFile, pathExists } from &#39;fs-extra&#39;;
import { existsSync } from &#39;node:fs&#39;;
import { 
    runFusionCommand, 
    runInitCommand, 
    runConfigCheckCommand 
} from &#39;../src/clicommands.js&#39;;

// Mock external dependencies
vi.mock(&#39;chalk&#39;, () =&gt; ({
    default: {
        blue: (str: string) =&gt; str,
        green: (str: string) =&gt; str,
        yellow: (str: string) =&gt; str,
        red: (str: string) =&gt; str,
        cyan: (str: string) =&gt; str,
        gray: (str: string) =&gt; str,
        magenta: (str: string) =&gt; str
    }
}));

vi.mock(&#39;clipboardy&#39;, () =&gt; ({
    default: {
        write: vi.fn().mockResolvedValue(undefined)
    }
}));

describe(&#39;CLI Commands&#39;, () =&gt; {
    const testDir = join(process.cwd(), &#39;temp&#39;, &#39;clicommands-test&#39;);
    const originalCwd = process.cwd();
    const originalExit = process.exit;
    const originalConsole = {
        log: console.log,
        error: console.error,
        warn: console.warn
    };

    // Mock console and process.exit
    const mockConsole = {
        log: vi.fn(),
        error: vi.fn(),
        warn: vi.fn()
    };
    const mockExit = vi.fn();

    beforeEach(async () =&gt; {
        // Clear all mocks before each test
        vi.clearAllMocks();
        
        // Clean up and create test directory
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        await mkdir(testDir, { recursive: true });
        process.chdir(testDir);

        // Mock console and process.exit
        console.log = mockConsole.log;
        console.error = mockConsole.error;
        console.warn = mockConsole.warn;
        process.exit = mockExit as any;
    });

    afterEach(async () =&gt; {
        // Restore original functions
        console.log = originalConsole.log;
        console.error = originalConsole.error;
        console.warn = originalConsole.warn;
        process.exit = originalExit;

        process.chdir(originalCwd);
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    describe(&#39;runFusionCommand&#39;, () =&gt; {
        it(&#39;should run fusion with default options&#39;, async () =&gt; {
            // Create sample files
            await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;Hello&quot;);&#39;);
            await writeFile(&#39;test.ts&#39;, &#39;const msg: string = &quot;TypeScript&quot;;&#39;);

            await runFusionCommand({});

            // Should log success message
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;‚úÖ&#39;));
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;Generated files:&#39;));
        });

        it(&#39;should handle custom root directory&#39;, async () =&gt; {
            // Create subdirectory with files
            await mkdir(&#39;subdir&#39;);
            await writeFile(&#39;subdir/test.js&#39;, &#39;console.log(&quot;Subdir&quot;);&#39;);

            await runFusionCommand({ root: &#39;./subdir&#39; });

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;Using specified directory as root: ./subdir&#39;));
        });

        it(&#39;should handle extension groups&#39;, async () =&gt; {
            await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;JS&quot;);&#39;);
            await writeFile(&#39;test.py&#39;, &#39;print(&quot;Python&quot;)&#39;);

            await runFusionCommand({ extensions: &#39;web,backend&#39; });

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;Using extension groups: web, backend&#39;));
        });

        it(&#39;should handle clipboard copy&#39;, async () =&gt; {
            await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;Test&quot;);&#39;);
            
            // Create config with clipboard enabled
            const configWithClipboard = {
                schemaVersion: 1,
                copyToClipboard: true,
                generatedFileName: &quot;project-fusioned&quot;,
                generateHtml: true,
                generateMarkdown: true,
                generateText: true,
                maxFileSizeKB: 1024,
                parseSubDirectories: true,
                parsedFileExtensions: { web: [&quot;.js&quot;] },
                rootDirectory: &quot;.&quot;,
                useGitIgnoreForExcludes: true,
                ignorePatterns: []
            };
            
            await writeFile(&#39;project-fusion.json&#39;, JSON.stringify(configWithClipboard));

            // Mock non-TTY environment
            const originalTTY = process.stdout.isTTY;
            process.stdout.isTTY = true;
            process.env[&#39;CI&#39;] = &#39;false&#39;;

            await runFusionCommand({});

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;üìã Fusion content copied to clipboard&#39;));

            // Restore
            process.stdout.isTTY = originalTTY;
        });

        it(&#39;should skip clipboard in CI environment&#39;, async () =&gt; {
            await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;Test&quot;);&#39;);
            
            const configWithClipboard = {
                schemaVersion: 1,
                copyToClipboard: true,
                generatedFileName: &quot;project-fusioned&quot;,
                generateHtml: true,
                generateMarkdown: true,
                generateText: true,
                maxFileSizeKB: 1024,
                parseSubDirectories: true,
                parsedFileExtensions: { web: [&quot;.js&quot;] },
                rootDirectory: &quot;.&quot;,
                useGitIgnoreForExcludes: true,
                ignorePatterns: []
            };
            
            await writeFile(&#39;project-fusion.json&#39;, JSON.stringify(configWithClipboard));

            // Mock CI environment
            process.env[&#39;CI&#39;] = &#39;true&#39;;

            await runFusionCommand({});

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;üìã Clipboard copy skipped (non-interactive environment)&#39;));
        });

        it(&#39;should handle clipboard error gracefully&#39;, async () =&gt; {
            await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;Test&quot;);&#39;);
            
            const configWithClipboard = {
                schemaVersion: 1,
                copyToClipboard: true,
                generatedFileName: &quot;project-fusioned&quot;,
                generateHtml: true,
                generateMarkdown: true,
                generateText: true,
                maxFileSizeKB: 1024,
                parseSubDirectories: true,
                parsedFileExtensions: { web: [&quot;.js&quot;] },
                rootDirectory: &quot;.&quot;,
                useGitIgnoreForExcludes: true,
                ignorePatterns: []
            };
            
            await writeFile(&#39;project-fusion.json&#39;, JSON.stringify(configWithClipboard));

            // Mock clipboard error
            const clipboardy = await import(&#39;clipboardy&#39;);
            vi.mocked(clipboardy.default.write).mockRejectedValueOnce(new Error(&#39;Clipboard error&#39;));

            const originalTTY = process.stdout.isTTY;
            process.stdout.isTTY = true;
            process.env[&#39;CI&#39;] = &#39;false&#39;;

            await runFusionCommand({});

            expect(mockConsole.warn).toHaveBeenCalledWith(expect.stringContaining(&#39;‚ö†Ô∏è Could not copy to clipboard&#39;));

            process.stdout.isTTY = originalTTY;
        });

        it(&#39;should handle fusion failure&#39;, async () =&gt; {
            // Create empty directory (no files to process)
            await runFusionCommand({});

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;‚ùå&#39;));
        });

    });

    describe(&#39;runInitCommand&#39;, () =&gt; {
        it(&#39;should create config file&#39;, async () =&gt; {
            await runInitCommand();

            expect(await pathExists(&#39;project-fusion.json&#39;)).toBe(true);
            
            const config = JSON.parse(await readFile(&#39;project-fusion.json&#39;, &#39;utf8&#39;));
            expect(config).toHaveProperty(&#39;schemaVersion&#39;, 1);
            expect(config).toHaveProperty(&#39;generatedFileName&#39;, &#39;project-fusioned&#39;);

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;‚úÖ Project Fusion initialized successfully!&#39;));
        });


        it(&#39;should overwrite existing config with force flag&#39;, async () =&gt; {
            // Create existing config
            await writeFile(&#39;project-fusion.json&#39;, &#39;{&quot;custom&quot;: &quot;config&quot;}&#39;);

            await runInitCommand({ force: true });

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;‚ö†Ô∏è Overriding existing configuration&#39;));
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;‚úÖ Project Fusion initialized successfully!&#39;));

            // Config should be replaced
            const config = JSON.parse(await readFile(&#39;project-fusion.json&#39;, &#39;utf8&#39;));
            expect(config).not.toHaveProperty(&#39;custom&#39;);
            expect(config).toHaveProperty(&#39;schemaVersion&#39;, 1);
        });

        it(&#39;should handle write errors&#39;, async () =&gt; {
            // Create a directory named project-fusion.json to cause write error
            await mkdir(&#39;project-fusion.json&#39;);

            await runInitCommand();

            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringContaining(&#39;‚ùå Initialization failed&#39;));
            expect(mockExit).toHaveBeenCalledWith(1);
        });
    });

    describe(&#39;runConfigCheckCommand&#39;, () =&gt; {
        it(&#39;should validate valid configuration&#39;, async () =&gt; {
            const validConfig = {
                schemaVersion: 1,
                generatedFileName: &quot;test-fusion&quot;,
                generateHtml: true,
                generateMarkdown: true,
                generateText: true,
                maxFileSizeKB: 1024,
                parseSubDirectories: true,
                parsedFileExtensions: {
                    web: [&quot;.js&quot;, &quot;.ts&quot;],
                    backend: [&quot;.py&quot;]
                },
                rootDirectory: &quot;.&quot;,
                useGitIgnoreForExcludes: true,
                copyToClipboard: false,
                ignorePatterns: [&quot;node_modules/&quot;]
            };
            
            await writeFile(&#39;project-fusion.json&#39;, JSON.stringify(validConfig, null, 2));

            await runConfigCheckCommand();

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;‚úÖ Configuration is valid!&#39;));
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;Configuration Summary:&#39;));
        });

        it(&#39;should handle missing configuration file&#39;, async () =&gt; {
            await runConfigCheckCommand();

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;‚ö†Ô∏è No project-fusion.json found&#39;));
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;Using default configuration&#39;));
        });

        it(&#39;should handle invalid JSON&#39;, async () =&gt; {
            await writeFile(&#39;project-fusion.json&#39;, &#39;{ invalid json&#39;);

            await runConfigCheckCommand();

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;‚ùå Invalid JSON in configuration file&#39;));
            expect(mockExit).toHaveBeenCalledWith(1);
        });

        it(&#39;should handle invalid configuration schema&#39;, async () =&gt; {
            const invalidConfig = {
                schemaVersion: &quot;invalid&quot;,
                generateHtml: &quot;not-boolean&quot;,
                parsedFileExtensions: &quot;not-object&quot;
            };
            
            await writeFile(&#39;project-fusion.json&#39;, JSON.stringify(invalidConfig));

            await runConfigCheckCommand();

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;‚ùå Configuration validation failed&#39;));
            expect(mockExit).toHaveBeenCalledWith(1);
        });

        it(&#39;should handle file read errors&#39;, async () =&gt; {
            // Create a directory instead of file to cause read error
            await mkdir(&#39;project-fusion.json&#39;);

            await runConfigCheckCommand();

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;‚ùå Cannot read configuration file&#39;));
            expect(mockExit).toHaveBeenCalledWith(1);
        });

        it(&#39;should display config info with file preview&#39;, async () =&gt; {
            // Create some test files
            await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;test&quot;);&#39;);
            await writeFile(&#39;test.ts&#39;, &#39;const x: string = &quot;test&quot;;&#39;);

            await runConfigCheckCommand();

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;üîß Basic Settings&#39;));
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;üìÑ Output Generation&#39;));
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;üìÅ File Extension Groups&#39;));
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;üö´ Ignore Patterns&#39;));
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining(&#39;üîç File Discovery Preview&#39;));
        });
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-file-security-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/file-security.test.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * File security tests for Project Fusion
 */
import { describe, it, expect, beforeEach, afterEach } from &#39;vitest&#39;;
import { join } from &#39;node:path&#39;;
import { writeFile, mkdir, rm, symlink, readFile } from &#39;node:fs/promises&#39;;
import { existsSync } from &#39;node:fs&#39;;
import { validateSecurePath, validateNoSymlinks, isBinaryFile } from &#39;../src/utils.js&#39;;
import { processFusion } from &#39;../src/fusion.js&#39;;
import { defaultConfig } from &#39;../src/utils.js&#39;;
import { FusionError } from &#39;../src/types.js&#39;;

describe(&#39;File Security Tests&#39;, () =&gt; {
    const testDir = join(process.cwd(), &#39;temp&#39;, &#39;file-security-test&#39;);
    const outsideDir = join(process.cwd(), &#39;temp&#39;, &#39;outside-test&#39;);

    beforeEach(async () =&gt; {
        // Clean up and create test directories
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        if (existsSync(outsideDir)) {
            await rm(outsideDir, { recursive: true, force: true });
        }
        await mkdir(testDir, { recursive: true });
        await mkdir(outsideDir, { recursive: true });
        process.chdir(testDir);
    });

    afterEach(async () =&gt; {
        process.chdir(join(testDir, &#39;..&#39;, &#39;..&#39;));
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        if (existsSync(outsideDir)) {
            await rm(outsideDir, { recursive: true, force: true });
        }
    });

    describe(&#39;Path Traversal Protection&#39;, () =&gt; {
        it(&#39;should validate safe paths within root directory&#39;, () =&gt; {
            const safePath1 = join(testDir, &#39;safe-file.js&#39;);
            const safePath2 = join(testDir, &#39;subdir&#39;, &#39;another-file.ts&#39;);
            
            expect(() =&gt; validateSecurePath(safePath1, testDir)).not.toThrow();
            expect(() =&gt; validateSecurePath(safePath2, testDir)).not.toThrow();
            
            const validatedPath = validateSecurePath(safePath1, testDir);
            expect(validatedPath).toBe(safePath1);
        });

        it(&#39;should reject paths that escape root directory&#39;, () =&gt; {
            const maliciousPath1 = join(testDir, &#39;..&#39;, &#39;..&#39;, &#39;etc&#39;, &#39;passwd&#39;);
            const maliciousPath2 = &#39;../../../etc/passwd&#39;;
            const maliciousPath3 = join(outsideDir, &#39;evil.js&#39;);
            
            expect(() =&gt; validateSecurePath(maliciousPath1, testDir)).toThrow(FusionError);
            expect(() =&gt; validateSecurePath(maliciousPath2, testDir)).toThrow(FusionError);
            expect(() =&gt; validateSecurePath(maliciousPath3, testDir)).toThrow(FusionError);
            
            try {
                validateSecurePath(maliciousPath1, testDir);
            } catch (error) {
                expect(error).toBeInstanceOf(FusionError);
                expect((error as FusionError).code).toBe(&#39;PATH_TRAVERSAL&#39;);
            }
        });

        it(&#39;should handle relative paths correctly&#39;, () =&gt; {
            // When run from testDir, relative paths should be resolved relative to testDir
            const relativePath = &#39;./safe-file.js&#39;;
            const result = validateSecurePath(relativePath, testDir);
            expect(result).toBe(join(testDir, &#39;safe-file.js&#39;));
        });

        it(&#39;should prevent access to root directory itself when not intended&#39;, () =&gt; {
            const rootPath = testDir;
            // Root directory itself should be valid
            expect(() =&gt; validateSecurePath(rootPath, testDir)).not.toThrow();
            
            // But parent of root should not be
            const parentPath = join(testDir, &#39;..&#39;);
            expect(() =&gt; validateSecurePath(parentPath, testDir)).toThrow(FusionError);
        });
    });

    describe(&#39;Symbolic Link Detection&#39;, () =&gt; {
        it(&#39;should detect and reject symbolic links by default&#39;, async () =&gt; {
            const targetFile = join(testDir, &#39;target.js&#39;);
            const symlinkFile = join(testDir, &#39;symlink.js&#39;);
            
            await writeFile(targetFile, &#39;console.log(&quot;target&quot;);&#39;);
            await symlink(targetFile, symlinkFile);
            
            await expect(validateNoSymlinks(symlinkFile, false)).rejects.toThrow(FusionError);
            
            try {
                await validateNoSymlinks(symlinkFile, false);
            } catch (error) {
                expect(error).toBeInstanceOf(FusionError);
                expect((error as FusionError).code).toBe(&#39;SYMLINK_NOT_ALLOWED&#39;);
            }
        });

        it(&#39;should allow symbolic links when explicitly enabled&#39;, async () =&gt; {
            const targetFile = join(testDir, &#39;target.js&#39;);
            const symlinkFile = join(testDir, &#39;symlink.js&#39;);
            
            await writeFile(targetFile, &#39;console.log(&quot;target&quot;);&#39;);
            await symlink(targetFile, symlinkFile);
            
            await expect(validateNoSymlinks(symlinkFile, true)).resolves.toBe(true);
        });

        it(&#39;should handle non-existent files gracefully&#39;, async () =&gt; {
            const nonExistentFile = join(testDir, &#39;does-not-exist.js&#39;);
            await expect(validateNoSymlinks(nonExistentFile, false)).resolves.toBe(false);
        });

        it(&#39;should handle regular files correctly&#39;, async () =&gt; {
            const regularFile = join(testDir, &#39;regular.js&#39;);
            await writeFile(regularFile, &#39;console.log(&quot;regular&quot;);&#39;);
            
            await expect(validateNoSymlinks(regularFile, false)).resolves.toBe(true);
        });
    });

    describe(&#39;Binary File Detection&#39;, () =&gt; {
        it(&#39;should detect binary files with null bytes&#39;, async () =&gt; {
            const binaryFile = join(testDir, &#39;binary.bin&#39;);
            const binaryContent = Buffer.from([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00]); // PNG header with null
            await writeFile(binaryFile, binaryContent);
            
            expect(await isBinaryFile(binaryFile)).toBe(true);
        });

        it(&#39;should detect text files correctly&#39;, async () =&gt; {
            const textFile = join(testDir, &#39;text.js&#39;);
            await writeFile(textFile, &#39;console.log(&quot;Hello, World!&quot;);&#39;);
            
            expect(await isBinaryFile(textFile)).toBe(false);
        });

        it(&#39;should handle empty files as text&#39;, async () =&gt; {
            const emptyFile = join(testDir, &#39;empty.txt&#39;);
            await writeFile(emptyFile, &#39;&#39;);
            
            expect(await isBinaryFile(emptyFile)).toBe(false);
        });

        it(&#39;should detect files with high non-printable character ratio&#39;, async () =&gt; {
            const nonPrintableFile = join(testDir, &#39;nonprintable.dat&#39;);
            // Create content with &gt;30% non-printable characters
            const content = Buffer.alloc(100);
            for (let i = 0; i &lt; 100; i++) {
                if (i &lt; 40) {
                    content[i] = Math.floor(Math.random() * 32); // Non-printable
                } else {
                    content[i] = 65 + (i % 26); // Printable letters
                }
            }
            await writeFile(nonPrintableFile, content);
            
            expect(await isBinaryFile(nonPrintableFile)).toBe(true);
        });

        it(&#39;should handle files with common whitespace correctly&#39;, async () =&gt; {
            const whitespaceFile = join(testDir, &#39;whitespace.txt&#39;);
            const content = &#39;Line 1\nLine 2\tWith tab\rCarriage return\n&#39;;
            await writeFile(whitespaceFile, content);
            
            expect(await isBinaryFile(whitespaceFile)).toBe(false);
        });

        it(&#39;should handle non-existent files gracefully&#39;, async () =&gt; {
            const nonExistentFile = join(testDir, &#39;does-not-exist.bin&#39;);
            expect(await isBinaryFile(nonExistentFile)).toBe(false);
        });
    });

    describe(&#39;Integration with Fusion Process&#39;, () =&gt; {
        it(&#39;should skip binary files during fusion&#39;, async () =&gt; {
            // Create a text file and a binary file
            await writeFile(&#39;text.js&#39;, &#39;console.log(&quot;text&quot;);&#39;);
            
            const binaryContent = Buffer.from([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00]);
            await writeFile(&#39;binary.bin&#39;, binaryContent);
            
            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateHtml: false,
                generateMarkdown: false,
                generateText: true,
                parsedFileExtensions: {
                    web: [&#39;.js&#39;],
                    other: [&#39;.bin&#39;]
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            // Check that only text file was processed
            const fusionContent = await readFile(join(testDir, &#39;project-fusioned.txt&#39;), &#39;utf8&#39;);
            expect(fusionContent).toContain(&#39;console.log(&quot;text&quot;);&#39;);
            expect(fusionContent).not.toContain(&#39;PNG&#39;); // Binary content shouldn&#39;t be there
            
            // Check log for binary file skip message
            const logContent = await readFile(result.logFilePath!, &#39;utf8&#39;);
            expect(logContent).toContain(&#39;Skipping binary file: binary.bin&#39;);
        });

        it(&#39;should prevent path traversal in fusion process&#39;, async () =&gt; {
            // Create a file inside the test directory and one outside
            await writeFile(&#39;inside.js&#39;, &#39;console.log(&quot;inside&quot;);&#39;);
            await writeFile(join(outsideDir, &#39;outside.js&#39;), &#39;console.log(&quot;outside&quot;);&#39;);
            
            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateHtml: false,
                generateMarkdown: false,
                generateText: true,
                parsedFileExtensions: {
                    web: [&#39;.js&#39;]
                }
            };

            // The fusion process should not find files outside the root directory
            // because glob patterns are constrained to the root directory
            const result = await processFusion(config);
            expect(result.success).toBe(true);
            
            const fusionContent = await readFile(join(testDir, &#39;project-fusioned.txt&#39;), &#39;utf8&#39;);
            expect(fusionContent).toContain(&#39;inside&#39;); // File inside should be included
            expect(fusionContent).not.toContain(&#39;outside&#39;); // File outside should not be included
        });

        it(&#39;should reject symbolic links in fusion process&#39;, async () =&gt; {
            await writeFile(&#39;target.js&#39;, &#39;console.log(&quot;target&quot;);&#39;);
            await symlink(join(testDir, &#39;target.js&#39;), join(testDir, &#39;symlink.js&#39;));
            
            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateHtml: false,
                generateMarkdown: false,
                generateText: true,
                parsedFileExtensions: {
                    web: [&#39;.js&#39;]
                }
            };

            // The fusion process should skip symbolic links
            const result = await processFusion(config);
            expect(result.success).toBe(true);
            
            // Check that target file was processed but symlink was skipped
            const fusionContent = await readFile(join(testDir, &#39;project-fusioned.txt&#39;), &#39;utf8&#39;);
            expect(fusionContent).toContain(&#39;target.js&#39;); // Target file should be included
            
            // The symlink should cause an error that&#39;s logged but doesn&#39;t fail the process
            const logContent = await readFile(result.logFilePath!, &#39;utf8&#39;);
            expect(logContent).toContain(&#39;symlink.js&#39;); // Should mention the symlink file
        });
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-fluent-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/fluent.test.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for Fluent API
 */
import { describe, it, expect, beforeEach, afterEach, vi } from &#39;vitest&#39;;
import { join } from &#39;node:path&#39;;
import { writeFile, mkdir, rm } from &#39;fs-extra&#39;;
import { existsSync } from &#39;node:fs&#39;;
import { projectFusion, ProjectFusionBuilder } from &#39;../src/fluent.js&#39;;
import { defaultConfig } from &#39;../src/utils.js&#39;;

// Mock external dependencies
vi.mock(&#39;chalk&#39;, () =&gt; ({
    default: {
        blue: (str: string) =&gt; str,
        green: (str: string) =&gt; str,
        yellow: (str: string) =&gt; str,
        red: (str: string) =&gt; str,
        cyan: (str: string) =&gt; str,
        gray: (str: string) =&gt; str,
        magenta: (str: string) =&gt; str
    }
}));

vi.mock(&#39;clipboardy&#39;, () =&gt; ({
    default: {
        write: vi.fn().mockResolvedValue(undefined)
    }
}));

describe(&#39;Fluent API&#39;, () =&gt; {
    const testDir = join(process.cwd(), &#39;temp&#39;, &#39;fluent-test&#39;);
    const originalCwd = process.cwd();

    beforeEach(async () =&gt; {
        // Clear all mocks before each test
        vi.clearAllMocks();
        
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        await mkdir(testDir, { recursive: true });
        process.chdir(testDir);
    });

    afterEach(async () =&gt; {
        process.chdir(originalCwd);
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    describe(&#39;ProjectFusionBuilder&#39;, () =&gt; {
        it(&#39;should create a new builder instance&#39;, () =&gt; {
            const builder = new ProjectFusionBuilder();
            expect(builder).toBeInstanceOf(ProjectFusionBuilder);
        });

        it(&#39;should support method chaining&#39;, () =&gt; {
            const builder = projectFusion()
                .root(&#39;./src&#39;)
                .include([&#39;web&#39;])
                .exclude([&#39;*.test.ts&#39;])
                .maxSize(&#39;1MB&#39;)
                .output([&#39;md&#39;])
                .name(&#39;test-fusion&#39;)
                .subdirectories(false)
                .clipboard(false)
                .gitignore(true);

            expect(builder).toBeInstanceOf(ProjectFusionBuilder);
        });

        describe(&#39;configuration methods&#39;, () =&gt; {
            it(&#39;should set root directory&#39;, () =&gt; {
                const builder = projectFusion().root(&#39;./src&#39;);
                const config = builder.getConfig();
                expect(config.rootDirectory).toBe(&#39;./src&#39;);
            });

            it(&#39;should set working directory&#39;, () =&gt; {
                const builder = projectFusion().cwd(&#39;/custom/cwd&#39;);
                const config = builder.getConfig();
                expect(config.cwd).toBe(&#39;/custom/cwd&#39;);
            });

            it(&#39;should set extension groups&#39;, () =&gt; {
                const builder = projectFusion().include([&#39;web&#39;, &#39;backend&#39;]);
                const config = builder.getConfig();
                expect(config.extensionGroups).toEqual([&#39;web&#39;, &#39;backend&#39;]);
            });

            it(&#39;should set ignore patterns&#39;, () =&gt; {
                const patterns = [&#39;*.test.ts&#39;, &#39;node_modules/&#39;];
                const builder = projectFusion().exclude(patterns);
                const config = builder.getConfig();
                expect(config.ignorePatterns).toEqual(patterns);
            });

            it(&#39;should set max file size from string with MB&#39;, () =&gt; {
                const builder = projectFusion().maxSize(&#39;2MB&#39;);
                const config = builder.getConfig();
                expect(config.maxFileSizeKB).toBe(2048);
            });

            it(&#39;should set max file size from string with KB&#39;, () =&gt; {
                const builder = projectFusion().maxSize(&#39;512KB&#39;);
                const config = builder.getConfig();
                expect(config.maxFileSizeKB).toBe(512);
            });

            it(&#39;should set max file size from number&#39;, () =&gt; {
                const builder = projectFusion().maxSize(1024);
                const config = builder.getConfig();
                expect(config.maxFileSizeKB).toBe(1024);
            });

            it(&#39;should throw error for invalid size format&#39;, () =&gt; {
                expect(() =&gt; {
                    projectFusion().maxSize(&#39;invalid&#39;);
                }).toThrow(&#39;Invalid size format&#39;);
            });

            it(&#39;should set output formats&#39;, () =&gt; {
                const builder = projectFusion().output([&#39;md&#39;, &#39;html&#39;]);
                const config = builder.getConfig();
                expect(config.generateMarkdown).toBe(true);
                expect(config.generateHtml).toBe(true);
                expect(config.generateText).toBe(false);
            });

            it(&#39;should set generated file name&#39;, () =&gt; {
                const builder = projectFusion().name(&#39;custom-name&#39;);
                const config = builder.getConfig();
                expect(config.generatedFileName).toBe(&#39;custom-name&#39;);
            });

            it(&#39;should set subdirectories flag&#39;, () =&gt; {
                const builder = projectFusion().subdirectories(false);
                const config = builder.getConfig();
                expect(config.parseSubDirectories).toBe(false);
            });

            it(&#39;should set clipboard flag&#39;, () =&gt; {
                const builder = projectFusion().clipboard(true);
                const config = builder.getConfig();
                expect(config.copyToClipboard).toBe(true);
            });

            it(&#39;should set gitignore flag&#39;, () =&gt; {
                const builder = projectFusion().gitignore(false);
                const config = builder.getConfig();
                expect(config.useGitIgnoreForExcludes).toBe(false);
            });

            it(&#39;should add custom extensions for a group&#39;, () =&gt; {
                const builder = projectFusion().extensions(&#39;custom&#39;, [&#39;.custom&#39;, &#39;.ext&#39;]);
                const config = builder.getConfig();
                expect(config.parsedFileExtensions?.custom).toEqual([&#39;.custom&#39;, &#39;.ext&#39;]);
            });

            it(&#39;should set all extensions&#39;, () =&gt; {
                const extensions = { web: [&#39;.ts&#39;], backend: [&#39;.py&#39;] };
                const builder = projectFusion().allExtensions(extensions);
                const config = builder.getConfig();
                expect(config.parsedFileExtensions).toEqual(extensions);
            });

            it(&#39;should apply custom configuration function&#39;, () =&gt; {
                const builder = projectFusion().configure((options) =&gt; {
                    options.maxFileSizeKB = 9999;
                    options.generateText = false;
                });
                const config = builder.getConfig();
                expect(config.maxFileSizeKB).toBe(9999);
                expect(config.generateText).toBe(false);
            });
        });

        describe(&#39;reset method&#39;, () =&gt; {
            it(&#39;should reset configuration to defaults&#39;, () =&gt; {
                const builder = projectFusion()
                    .root(&#39;./src&#39;)
                    .include([&#39;web&#39;])
                    .maxSize(&#39;2MB&#39;)
                    .reset();

                const config = builder.getConfig();
                expect(config.rootDirectory).toBeUndefined();
                expect(config.extensionGroups).toBeUndefined();
                expect(config.maxFileSizeKB).toBeUndefined();
            });
        });

        describe(&#39;integration tests&#39;, () =&gt; {
            it(&#39;should generate fusion files with basic configuration&#39;, async () =&gt; {
                // Create test files
                await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;Hello&quot;);&#39;);
                await writeFile(&#39;test.ts&#39;, &#39;const msg: string = &quot;TypeScript&quot;;&#39;);

                const result = await projectFusion()
                    .include([&#39;web&#39;])
                    .output([&#39;text&#39;])
                    .generate();

                expect(result.success).toBe(true);
                expect(result.message).toContain(&#39;files processed&#39;);
            });

            it(&#39;should generate fusion files with advanced configuration&#39;, async () =&gt; {
                // Create test structure
                await mkdir(&#39;src&#39;, { recursive: true });
                await writeFile(&#39;src/app.js&#39;, &#39;console.log(&quot;App&quot;);&#39;);
                await writeFile(&#39;src/utils.ts&#39;, &#39;export const util = () =&gt; {};&#39;);
                await writeFile(&#39;test.spec.js&#39;, &#39;console.log(&quot;Test&quot;);&#39;);

                const result = await projectFusion()
                    .root(&#39;./src&#39;)
                    .include([&#39;web&#39;])
                    .exclude([&#39;*.spec.js&#39;])
                    .maxSize(&#39;1MB&#39;)
                    .output([&#39;md&#39;, &#39;html&#39;])
                    .name(&#39;custom-fusion&#39;)
                    .clipboard(false)
                    .generate();

                expect(result.success).toBe(true);
                expect(result.message).toContain(&#39;files processed&#39;);
            });

            it(&#39;should handle empty directory gracefully&#39;, async () =&gt; {
                const result = await projectFusion()
                    .include([&#39;web&#39;])
                    .generate();

                expect(result.success).toBe(false);
                expect(result.message).toContain(&#39;No files found&#39;);
            });

            it(&#39;should handle file size limits&#39;, async () =&gt; {
                // Create a small file
                await writeFile(&#39;small.js&#39;, &#39;console.log(&quot;small&quot;);&#39;);
                
                const result = await projectFusion()
                    .include([&#39;web&#39;])
                    .maxSize(&#39;1KB&#39;)
                    .generate();

                expect(result.success).toBe(true);
            });

            it(&#39;should handle custom extension groups&#39;, async () =&gt; {
                await writeFile(&#39;script.custom&#39;, &#39;custom file content&#39;);
                await writeFile(&#39;regular.js&#39;, &#39;console.log(&quot;regular&quot;);&#39;);

                const result = await projectFusion()
                    .extensions(&#39;custom&#39;, [&#39;.custom&#39;])
                    .include([&#39;custom&#39;, &#39;web&#39;]) // Include both custom and web to ensure success
                    .generate();

                expect(result.success).toBe(true);
            });

            it(&#39;should handle multiple output formats&#39;, async () =&gt; {
                await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;test&quot;);&#39;);

                const result = await projectFusion()
                    .include([&#39;web&#39;])
                    .output([&#39;text&#39;, &#39;md&#39;, &#39;html&#39;])
                    .generate();

                expect(result.success).toBe(true);
            });
        });

        describe(&#39;factory function&#39;, () =&gt; {
            it(&#39;should create builder via projectFusion function&#39;, () =&gt; {
                const builder = projectFusion();
                expect(builder).toBeInstanceOf(ProjectFusionBuilder);
            });

            it(&#39;should create independent builder instances&#39;, () =&gt; {
                const builder1 = projectFusion().root(&#39;./src1&#39;);
                const builder2 = projectFusion().root(&#39;./src2&#39;);

                expect(builder1.getConfig().rootDirectory).toBe(&#39;./src1&#39;);
                expect(builder2.getConfig().rootDirectory).toBe(&#39;./src2&#39;);
            });
        });

        describe(&#39;error handling&#39;, () =&gt; {
            it(&#39;should handle invalid size units gracefully&#39;, () =&gt; {
                expect(() =&gt; {
                    projectFusion().maxSize(&#39;100XB&#39;);
                }).toThrow(&#39;Invalid size format&#39;);
            });

            it(&#39;should handle malformed size strings&#39;, () =&gt; {
                expect(() =&gt; {
                    projectFusion().maxSize(&#39;not-a-number&#39;);
                }).toThrow(&#39;Invalid size format&#39;);
            });
        });

        describe(&#39;edge cases&#39;, () =&gt; {
            it(&#39;should handle subdirectories default parameter&#39;, () =&gt; {
                const builder = projectFusion().subdirectories();
                const config = builder.getConfig();
                expect(config.parseSubDirectories).toBe(true);
            });

            it(&#39;should handle clipboard default parameter&#39;, () =&gt; {
                const builder = projectFusion().clipboard();
                const config = builder.getConfig();
                expect(config.copyToClipboard).toBe(true);
            });

            it(&#39;should handle gitignore default parameter&#39;, () =&gt; {
                const builder = projectFusion().gitignore();
                const config = builder.getConfig();
                expect(config.useGitIgnoreForExcludes).toBe(true);
            });

            it(&#39;should preserve existing extensions when adding custom ones&#39;, () =&gt; {
                const builder = projectFusion()
                    .extensions(&#39;custom1&#39;, [&#39;.ext1&#39;])
                    .extensions(&#39;custom2&#39;, [&#39;.ext2&#39;]);
                
                const config = builder.getConfig();
                expect(config.parsedFileExtensions?.custom1).toEqual([&#39;.ext1&#39;]);
                expect(config.parsedFileExtensions?.custom2).toEqual([&#39;.ext2&#39;]);
                expect(config.parsedFileExtensions?.web).toEqual(defaultConfig.parsedFileExtensions.web);
            });

            it(&#39;should handle decimal sizes&#39;, () =&gt; {
                const builder = projectFusion().maxSize(&#39;1.5MB&#39;);
                const config = builder.getConfig();
                expect(config.maxFileSizeKB).toBe(1536);
            });

            it(&#39;should handle GB units&#39;, () =&gt; {
                const builder = projectFusion().maxSize(&#39;1GB&#39;);
                const config = builder.getConfig();
                expect(config.maxFileSizeKB).toBe(1024 * 1024);
            });
        });
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-formats-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/formats.test.ts</h2>
        </div>
        <pre><code class="typescript">import { describe, it, expect, beforeEach, afterEach } from &#39;vitest&#39;;
import fs from &#39;fs-extra&#39;;
import path from &#39;path&#39;;
import { processFusion } from &#39;../src/fusion.js&#39;;
import { Config } from &#39;../src/types.js&#39;;

// Test configuration for multiple output formats
const testConfig: Config = {
  schemaVersion: 1,
  generatedFileName: &#39;test-output&#39;,
  copyToClipboard: false,
  generateText: true,
  generateMarkdown: true,
  generateHtml: true,
  parsedFileExtensions: {
    web: [&#39;.js&#39;, &#39;.ts&#39;],
    doc: [&#39;.md&#39;]
  },
  parseSubDirectories: false,
  rootDirectory: &#39;.&#39;,
  maxFileSizeKB: 1024,
  ignorePatterns: [],
  useGitIgnoreForExcludes: false
};

const testDir = path.resolve(&#39;./temp/test-formats&#39;);
const originalCwd = process.cwd();

describe(&#39;Multiple Format Generation&#39;, () =&gt; {
  beforeEach(async () =&gt; {
    await fs.ensureDir(testDir);
    process.chdir(testDir);
    
    // Create test files
    await fs.writeFile(path.join(testDir, &#39;test.js&#39;), `
console.log(&#39;Hello World&#39;);
function greet(name) {
  return \`Hello, \${name}!\`;
}
export { greet };
    `.trim());

    await fs.writeFile(path.join(testDir, &#39;README.md&#39;), `
# Test Project

This is a **test** project with _markdown_ content.

## Features
- Feature 1
- Feature 2
    `.trim());
  });

  afterEach(async () =&gt; {
    process.chdir(originalCwd);
    await fs.remove(testDir);
  });

  it(&#39;should generate text format when enabled&#39;, async () =&gt; {
    const config = { ...testConfig, generateText: true, generateMarkdown: false, generateHtml: false };
    const result = await processFusion(config);
    
    expect(result.success).toBe(true);
    expect(await fs.pathExists(&#39;test-output.txt&#39;)).toBe(true);
    expect(await fs.pathExists(&#39;test-output.md&#39;)).toBe(false);
    expect(await fs.pathExists(&#39;test-output.html&#39;)).toBe(false);
  });

  it(&#39;should generate markdown format when enabled&#39;, async () =&gt; {
    const config = { ...testConfig, generateText: false, generateMarkdown: true, generateHtml: false };
    const result = await processFusion(config);
    
    expect(result.success).toBe(true);
    expect(await fs.pathExists(&#39;test-output.txt&#39;)).toBe(false);
    expect(await fs.pathExists(&#39;test-output.md&#39;)).toBe(true);
    expect(await fs.pathExists(&#39;test-output.html&#39;)).toBe(false);
  });

  it(&#39;should generate HTML format when enabled&#39;, async () =&gt; {
    const config = { ...testConfig, generateText: false, generateMarkdown: false, generateHtml: true };
    const result = await processFusion(config);
    
    expect(result.success).toBe(true);
    expect(await fs.pathExists(&#39;test-output.txt&#39;)).toBe(false);
    expect(await fs.pathExists(&#39;test-output.md&#39;)).toBe(false);
    expect(await fs.pathExists(&#39;test-output.html&#39;)).toBe(true);
  });

  it(&#39;should generate multiple formats when enabled&#39;, async () =&gt; {
    const result = await processFusion(testConfig);
    
    expect(result.success).toBe(true);
    expect(await fs.pathExists(&#39;test-output.txt&#39;)).toBe(true);
    expect(await fs.pathExists(&#39;test-output.md&#39;)).toBe(true);
    expect(await fs.pathExists(&#39;test-output.html&#39;)).toBe(true);
  });

  it(&#39;should include proper HTML structure&#39;, async () =&gt; {
    const result = await processFusion(testConfig);
    
    expect(result.success).toBe(true);
    const htmlContent = await fs.readFile(&#39;test-output.html&#39;, &#39;utf8&#39;);
    
    expect(htmlContent).toContain(&#39;&lt;!DOCTYPE html&gt;&#39;);
    expect(htmlContent).toContain(&#39;&lt;html lang=&quot;en&quot;&gt;&#39;);
    expect(htmlContent).toContain(&#39;&lt;title&gt;Project Fusion - test-formats&lt;/title&gt;&#39;);
    expect(htmlContent).toContain(&#39;üìÅ Table of Contents&#39;);
    expect(htmlContent).toContain(&#39;üìÑ test.js&#39;);
    expect(htmlContent).toContain(&#39;üìÑ README.md&#39;);
    expect(htmlContent).toContain(&#39;&lt;/body&gt;&#39;);
    expect(htmlContent).toContain(&#39;&lt;/html&gt;&#39;);
  });

  it(&#39;should escape HTML in code content&#39;, async () =&gt; {
    // Add a file with HTML-like content
    await fs.writeFile(&#39;html-test.js&#39;, `
const html = &#39;&lt;div&gt;Hello &amp; &lt;span&gt;World&lt;/span&gt;&lt;/div&gt;&#39;;
console.log(html);
    `.trim());

    const result = await processFusion(testConfig);
    
    expect(result.success).toBe(true);
    const htmlContent = await fs.readFile(&#39;test-output.html&#39;, &#39;utf8&#39;);
    
    expect(htmlContent).toContain(&#39;&amp;lt;div&amp;gt;Hello &amp;amp; &amp;lt;span&amp;gt;World&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&#39;);
  });


  it(&#39;should include proper metadata in generated files&#39;, async () =&gt; {
    // Create a package.json with version info
    await fs.writeFile(&#39;package.json&#39;, JSON.stringify({
      name: &#39;test-package&#39;,
      version: &#39;1.0.0&#39;
    }, null, 2));

    const configWithPackage = {
      ...testConfig,
      parsedFileExtensions: { ...testConfig.parsedFileExtensions, config: [&#39;.json&#39;] }
    };

    const result = await processFusion(configWithPackage);
    
    expect(result.success).toBe(true);
    const txtContent = await fs.readFile(&#39;test-output.txt&#39;, &#39;utf8&#39;);
    const mdContent = await fs.readFile(&#39;test-output.md&#39;, &#39;utf8&#39;);
    
    expect(txtContent).toContain(&#39;# Generated Project Fusion File&#39;);
    expect(txtContent).toContain(&#39;# Project: test-formats / test-package v1.0.0&#39;);
    expect(txtContent).toContain(&#39;# Generated by: project-fusion&#39;);
    
    expect(mdContent).toContain(&#39;# Generated Project Fusion File&#39;);
    expect(mdContent).toContain(&#39;**Project:** test-formats / test-package v1.0.0&#39;);
    expect(mdContent).toContain(&#39;[project-fusion](https://github.com/the99studio/project-fusion)&#39;);
  });
});</code></pre>
    </div>

    <div class="file-section" id="tests-fusion-coverage-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/fusion-coverage.test.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Additional tests to achieve 100% coverage for fusion.ts
 */
import { describe, it, expect, beforeEach, afterEach, vi } from &#39;vitest&#39;;
import { join } from &#39;node:path&#39;;
import { writeFile, mkdir, rm, chmod, symlink } from &#39;fs-extra&#39;;
import { existsSync } from &#39;node:fs&#39;;
import { processFusion } from &#39;../src/fusion.js&#39;;
import { defaultConfig } from &#39;../src/utils.js&#39;;

describe(&#39;Fusion Coverage Tests&#39;, () =&gt; {
    const testDir = join(process.cwd(), &#39;temp&#39;, &#39;fusion-coverage-test&#39;);
    const originalCwd = process.cwd();

    beforeEach(async () =&gt; {
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        await mkdir(testDir, { recursive: true });
        process.chdir(testDir);
    });

    afterEach(async () =&gt; {
        process.chdir(originalCwd);
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    describe(&#39;processFusion edge cases&#39;, () =&gt; {
        it(&#39;should handle empty directories gracefully&#39;, async () =&gt; {
            const result = await processFusion(defaultConfig);
            
            expect(result.success).toBe(false);
            expect(result.message).toContain(&#39;No files found to process&#39;);
        });

        it(&#39;should handle very large files (size limit)&#39;, async () =&gt; {
            // Create a file larger than the default limit (1024 KB)
            const largeContent = &#39;x&#39;.repeat(1024 * 1024 + 1); // 1MB + 1 byte
            await writeFile(&#39;large.txt&#39;, largeContent);

            const config = {
                ...defaultConfig,
                maxFileSizeKB: 1024,
                parsedFileExtensions: {
                    ...defaultConfig.parsedFileExtensions,
                    doc: [&#39;.txt&#39;]
                }
            };

            const result = await processFusion(config);
            
            // Should still succeed but skip the large file
            expect(result.success).toBe(true);
            expect(result.message).toContain(&#39;files processed&#39;);
        });

        it(&#39;should handle binary files&#39;, async () =&gt; {
            // Create a binary file
            const binaryContent = Buffer.from([0x00, 0x01, 0x02, 0x03, 0xFF, 0xFE]);
            await writeFile(&#39;binary.bin&#39;, binaryContent);

            const config = {
                ...defaultConfig,
                parsedFileExtensions: {
                    ...defaultConfig.parsedFileExtensions,
                    other: [&#39;.bin&#39;]
                }
            };

            const result = await processFusion(config);
            
            expect(result.success).toBe(true);
            // Binary files should be skipped
        });

        it(&#39;should handle files with special characters in names&#39;, async () =&gt; {
            await writeFile(&#39;file with spaces.js&#39;, &#39;console.log(&quot;spaces&quot;);&#39;);
            await writeFile(&#39;file-with-dashes.js&#39;, &#39;console.log(&quot;dashes&quot;);&#39;);
            await writeFile(&#39;file_with_underscores.js&#39;, &#39;console.log(&quot;underscores&quot;);&#39;);

            const result = await processFusion(defaultConfig);
            
            expect(result.success).toBe(true);
        });

        it(&#39;should handle deeply nested directories&#39;, async () =&gt; {
            // Create deeply nested structure
            await mkdir(&#39;level1/level2/level3/level4&#39;, { recursive: true });
            await writeFile(&#39;level1/level2/level3/level4/deep.js&#39;, &#39;console.log(&quot;deep&quot;);&#39;);

            const result = await processFusion(defaultConfig);
            
            expect(result.success).toBe(true);
        });

        it(&#39;should handle permission errors gracefully&#39;, async () =&gt; {
            if (process.platform === &#39;win32&#39;) {
                // Skip permission tests on Windows as they work differently
                return;
            }

            await writeFile(&#39;accessible.js&#39;, &#39;console.log(&quot;accessible&quot;);&#39;);
            await writeFile(&#39;restricted.js&#39;, &#39;console.log(&quot;restricted&quot;);&#39;);
            
            try {
                // Remove read permissions
                await chmod(&#39;restricted.js&#39;, 0o000);

                const consoleSpy = vi.spyOn(console, &#39;warn&#39;).mockImplementation(() =&gt; {});

                const result = await processFusion(defaultConfig);
                
                // Should continue processing other files
                expect(result.success).toBe(true);
                
                consoleSpy.mockRestore();
                
                // Restore permissions for cleanup
                await chmod(&#39;restricted.js&#39;, 0o644);
            } catch (error) {
                // If chmod fails on this system, skip the test
                console.warn(&#39;Skipping permission test - chmod not supported properly&#39;);
            }
        });

        it(&#39;should handle symbolic links when they exist&#39;, async () =&gt; {
            if (process.platform === &#39;win32&#39;) {
                // Skip symlink tests on Windows
                return;
            }

            await writeFile(&#39;target.js&#39;, &#39;console.log(&quot;target&quot;);&#39;);
            
            try {
                await symlink(&#39;./target.js&#39;, &#39;link.js&#39;);
                
                const result = await processFusion(defaultConfig);
                
                expect(result.success).toBe(true);
            } catch (error) {
                // If symlink creation fails (permissions), skip the test
                console.warn(&#39;Skipping symlink test due to permissions&#39;);
            }
        });

        it(&#39;should handle gitignore parsing errors&#39;, async () =&gt; {
            // Create malformed .gitignore
            await writeFile(&#39;.gitignore&#39;, &#39;\x00invalid\x00content\x00&#39;);
            await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;test&quot;);&#39;);

            const result = await processFusion(defaultConfig);
            
            // Should still process files despite gitignore issues
            expect(result.success).toBe(true);
        });

        it(&#39;should handle extension groups with undefined extensions&#39;, async () =&gt; {
            const configWithUndefined = {
                ...defaultConfig,
                parsedFileExtensions: {
                    ...defaultConfig.parsedFileExtensions,
                    // @ts-expect-error - Testing undefined case
                    undefined_group: undefined
                }
            };

            await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;test&quot;);&#39;);

            const result = await processFusion(configWithUndefined);
            
            expect(result.success).toBe(true);
        });

        it(&#39;should handle fusion options with invalid extension groups&#39;, async () =&gt; {
            await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;test&quot;);&#39;);

            const result = await processFusion(defaultConfig, {
                extensionGroups: [&#39;invalid_group&#39;, &#39;web&#39;]
            });
            
            expect(result.success).toBe(true);
        });

        it(&#39;should handle HTML generation with special characters&#39;, async () =&gt; {
            await writeFile(&#39;special.html&#39;, `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Test &amp; &quot;Quotes&quot; and &#39;Single&#39; quotes&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;This has &lt;em&gt;emphasis&lt;/em&gt; and &lt;strong&gt;strong&lt;/strong&gt; text.&lt;/p&gt;
    &lt;p&gt;Special chars: &amp;lt; &amp;gt; &amp;amp; &quot; &#39;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;`);

            const result = await processFusion(defaultConfig);
            
            expect(result.success).toBe(true);
            
            // Verify HTML escaping in generated content
            const htmlContent = await import(&#39;fs-extra&#39;).then(fs =&gt; 
                fs.readFile(`${defaultConfig.generatedFileName}.html`, &#39;utf8&#39;)
            );
            expect(htmlContent).toContain(&#39;&amp;lt;&#39;);
            expect(htmlContent).toContain(&#39;&amp;gt;&#39;);
            expect(htmlContent).toContain(&#39;&amp;amp;&#39;);
        });

        it(&#39;should handle markdown generation with code blocks&#39;, async () =&gt; {
            await writeFile(&#39;example.md&#39;, `# Example

\`\`\`javascript
console.log(&quot;Hello, World!&quot;);
\`\`\`

Some **bold** and *italic* text.

- List item 1
- List item 2

| Table | Header |
|-------|--------|
| Cell  | Value  |
`);

            const result = await processFusion(defaultConfig);
            
            expect(result.success).toBe(true);
        });

        it(&#39;should handle very long file names&#39;, async () =&gt; {
            const longName = &#39;a&#39;.repeat(200) + &#39;.js&#39;;
            await writeFile(longName, &#39;console.log(&quot;long name&quot;);&#39;);

            const result = await processFusion(defaultConfig);
            
            expect(result.success).toBe(true);
        });

        it(&#39;should handle files with no extension&#39;, async () =&gt; {
            await writeFile(&#39;Makefile&#39;, &#39;all:\n\techo &quot;make target&quot;&#39;);
            await writeFile(&#39;README&#39;, &#39;# This is a readme file&#39;);
            // Also add a regular file to ensure fusion succeeds
            await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;test&quot;);&#39;);

            const result = await processFusion(defaultConfig);
            
            expect(result.success).toBe(true);
        });

        it(&#39;should handle directory traversal in ignore patterns&#39;, async () =&gt; {
            await mkdir(&#39;safe/directory&#39;, { recursive: true });
            await writeFile(&#39;safe/directory/file.js&#39;, &#39;console.log(&quot;safe&quot;);&#39;);

            const configWithTraversal = {
                ...defaultConfig,
                ignorePatterns: [&#39;../../../etc/passwd&#39;, &#39;safe/../unsafe&#39;]
            };

            const result = await processFusion(configWithTraversal);
            
            expect(result.success).toBe(true);
        });

        it(&#39;should handle benchmark tracking edge cases&#39;, async () =&gt; {
            await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;benchmark test&quot;);&#39;);

            // Test with very quick operations to test benchmark precision
            const startTime = Date.now();
            const result = await processFusion(defaultConfig);
            const endTime = Date.now();
            
            expect(result.success).toBe(true);
            expect(endTime - startTime).toBeGreaterThanOrEqual(0);
        });

        it(&#39;should handle concurrent file processing&#39;, async () =&gt; {
            // Create many files to test concurrent processing
            const promises = [];
            for (let i = 0; i &lt; 50; i++) {
                promises.push(writeFile(`file${i}.js`, `console.log(&quot;File ${i}&quot;);`));
            }
            await Promise.all(promises);

            const result = await processFusion(defaultConfig);
            
            expect(result.success).toBe(true);
            expect(result.message).toContain(&#39;50 files processed&#39;);
        });
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-index-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/index.test.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for main index.ts exports
 */
import { describe, it, expect } from &#39;vitest&#39;;

describe(&#39;Index Exports&#39;, () =&gt; {
    it(&#39;should export core functionality from benchmark&#39;, async () =&gt; {
        const { BenchmarkTracker } = await import(&#39;../src/index.js&#39;);
        expect(BenchmarkTracker).toBeDefined();
        expect(typeof BenchmarkTracker).toBe(&#39;function&#39;);
    });

    it(&#39;should export core functionality from fusion&#39;, async () =&gt; {
        const { processFusion } = await import(&#39;../src/index.js&#39;);
        expect(processFusion).toBeDefined();
        expect(typeof processFusion).toBe(&#39;function&#39;);
    });

    it(&#39;should export programmatic API&#39;, async () =&gt; {
        const { 
            createConfig,
            fusionAPI,
            runFusion
        } = await import(&#39;../src/index.js&#39;);
        
        expect(createConfig).toBeDefined();
        expect(typeof createConfig).toBe(&#39;function&#39;);
        expect(fusionAPI).toBeDefined();
        expect(typeof fusionAPI).toBe(&#39;function&#39;);
        expect(runFusion).toBeDefined();
        expect(typeof runFusion).toBe(&#39;function&#39;);
    });

    it(&#39;should export schemas&#39;, async () =&gt; {
        const { ConfigSchemaV1 } = await import(&#39;../src/index.js&#39;);
        expect(ConfigSchemaV1).toBeDefined();
    });

    it(&#39;should export types&#39;, async () =&gt; {
        const { 
            FusionError,
            isValidExtensionGroup,
            isNonEmptyArray
        } = await import(&#39;../src/index.js&#39;);
        
        expect(FusionError).toBeDefined();
        expect(typeof FusionError).toBe(&#39;function&#39;);
        expect(isValidExtensionGroup).toBeDefined();
        expect(typeof isValidExtensionGroup).toBe(&#39;function&#39;);
        expect(isNonEmptyArray).toBeDefined();
        expect(typeof isNonEmptyArray).toBe(&#39;function&#39;);
    });

    it(&#39;should export utilities&#39;, async () =&gt; {
        const { 
            defaultConfig,
            loadConfig,
            getExtensionsFromGroups,
            formatTimestamp
        } = await import(&#39;../src/index.js&#39;);
        
        expect(defaultConfig).toBeDefined();
        expect(typeof defaultConfig).toBe(&#39;object&#39;);
        expect(loadConfig).toBeDefined();
        expect(typeof loadConfig).toBe(&#39;function&#39;);
        expect(getExtensionsFromGroups).toBeDefined();
        expect(typeof getExtensionsFromGroups).toBe(&#39;function&#39;);
        expect(formatTimestamp).toBeDefined();
        expect(typeof formatTimestamp).toBe(&#39;function&#39;);
    });

    it(&#39;should have consistent exports structure&#39;, async () =&gt; {
        const exports = await import(&#39;../src/index.js&#39;);
        
        // Verify no undefined exports
        const exportKeys = Object.keys(exports);
        expect(exportKeys.length).toBeGreaterThan(0);
        
        for (const key of exportKeys) {
            expect(exports[key as keyof typeof exports]).toBeDefined();
        }
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-integration-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/integration.test.ts</h2>
        </div>
        <pre><code class="typescript">import { describe, it, expect, beforeEach, afterEach } from &#39;vitest&#39;;
import fs from &#39;fs-extra&#39;;
import path from &#39;path&#39;;
import { processFusion } from &#39;../src/fusion.js&#39;;
import { defaultConfig } from &#39;../src/utils.js&#39;;
import { Config } from &#39;../src/types.js&#39;;

describe(&#39;integration&#39;, () =&gt; {
  const testDir = path.join(process.cwd(), &#39;temp&#39;, &#39;test-integration&#39;);
  const originalCwd = process.cwd();

  beforeEach(async () =&gt; {
    // Clean up and create test directory
    await fs.remove(testDir);
    await fs.ensureDir(testDir);
    
    // Change to test directory
    process.chdir(testDir);
  });

  afterEach(async () =&gt; {
    // Restore original directory
    process.chdir(originalCwd);
    
    // Clean up test directory
    await fs.remove(testDir);
  });

  describe(&#39;processFusion&#39;, () =&gt; {
    it(&#39;should process fusion successfully with test files&#39;, async () =&gt; {
      // Create test files
      await fs.writeFile(&#39;test.js&#39;, &#39;console.log(&quot;Hello World&quot;);&#39;);
      await fs.writeFile(&#39;test.ts&#39;, &#39;const message: string = &quot;TypeScript&quot;;&#39;);
      await fs.writeFile(&#39;Dockerfile&#39;, &#39;FROM node:18\nCOPY . .\nRUN npm install&#39;);
      
      // Create config for test
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: &#39;.&#39;,
        parseSubDirectories: false,
        parsedFileExtensions: {
          web: [&#39;.js&#39;, &#39;.ts&#39;]
        }
      };

      const result = await processFusion(testConfig);

      expect(result.success).toBe(true);
      expect(result.message).toContain(&#39;2 files processed&#39;);
      expect(result.fusionFilePath).toBeDefined();
      
      // Check if fusion files were created
      expect(await fs.pathExists(result.fusionFilePath!)).toBe(true);
      expect(await fs.pathExists(result.fusionFilePath!.replace(&#39;.txt&#39;, &#39;.md&#39;))).toBe(true);
      
      // Check content of fusion file
      const fusionContent = await fs.readFile(result.fusionFilePath!, &#39;utf8&#39;);
      expect(fusionContent).toContain(&#39;test.js&#39;);
      expect(fusionContent).toContain(&#39;test.ts&#39;);
      expect(fusionContent).toContain(&#39;console.log(&quot;Hello World&quot;);&#39;);
      expect(fusionContent).toContain(&#39;const message: string = &quot;TypeScript&quot;;&#39;);
      expect(fusionContent).not.toContain(&#39;Dockerfile&#39;); // Not in web extensions
    });

    it(&#39;should handle empty directory gracefully&#39;, async () =&gt; {
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: &#39;.&#39;,
        parseSubDirectories: false
      };

      const result = await processFusion(testConfig);

      expect(result.success).toBe(false);
      expect(result.message).toContain(&#39;No files found to process&#39;);
    });

    it(&#39;should respect ignore patterns&#39;, async () =&gt; {
      // Create test files
      await fs.writeFile(&#39;test.js&#39;, &#39;console.log(&quot;Hello World&quot;);&#39;);
      await fs.writeFile(&#39;ignored.js&#39;, &#39;console.log(&quot;Should be ignored&quot;);&#39;);
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: &#39;.&#39;,
        parseSubDirectories: false,
        parsedFileExtensions: {
          web: [&#39;.js&#39;]
        },
        ignorePatterns: [&#39;ignored.js&#39;]
      };

      const result = await processFusion(testConfig);

      expect(result.success).toBe(true);
      expect(result.message).toContain(&#39;1 files processed&#39;); // Only test.js
      
      const fusionContent = await fs.readFile(result.fusionFilePath!, &#39;utf8&#39;);
      expect(fusionContent).toContain(&#39;test.js&#39;);
      expect(fusionContent).not.toContain(&#39;ignored.js&#39;);
    });

    it(&#39;should filter files by extensions correctly&#39;, async () =&gt; {
      // Create test files with different extensions
      await fs.writeFile(&#39;app.js&#39;, &#39;console.log(&quot;JavaScript&quot;);&#39;);
      await fs.writeFile(&#39;app.ts&#39;, &#39;const app: string = &quot;TypeScript&quot;;&#39;);
      await fs.writeFile(&#39;app.py&#39;, &#39;print(&quot;Python&quot;)&#39;);
      await fs.writeFile(&#39;config.json&#39;, &#39;{&quot;test&quot;: true}&#39;);
      
      // Test web extensions only
      const webConfig: Config = {
        ...defaultConfig,
        rootDirectory: &#39;.&#39;,
        parseSubDirectories: false,
        parsedFileExtensions: {
          web: [&#39;.js&#39;, &#39;.ts&#39;]
        }
      };

      const webResult = await processFusion(webConfig);
      expect(webResult.success).toBe(true);
      expect(webResult.message).toContain(&#39;2 files processed&#39;);
      
      const webContent = await fs.readFile(webResult.fusionFilePath!, &#39;utf8&#39;);
      expect(webContent).toContain(&#39;app.js&#39;);
      expect(webContent).toContain(&#39;app.ts&#39;);
      expect(webContent).not.toContain(&#39;app.py&#39;);
      expect(webContent).not.toContain(&#39;config.json&#39;);

      // Test backend extensions only
      const backendConfig: Config = {
        ...defaultConfig,
        rootDirectory: &#39;.&#39;,
        parseSubDirectories: false,
        parsedFileExtensions: {
          backend: [&#39;.py&#39;]
        }
      };

      const backendResult = await processFusion(backendConfig);
      expect(backendResult.success).toBe(true);
      expect(backendResult.message).toContain(&#39;1 files processed&#39;);
      
      const backendContent = await fs.readFile(backendResult.fusionFilePath!, &#39;utf8&#39;);
      expect(backendContent).toContain(&#39;app.py&#39;);
      expect(backendContent).not.toContain(&#39;app.js&#39;);
      expect(backendContent).not.toContain(&#39;app.ts&#39;);
    });

    it(&#39;should respect .gitignore patterns&#39;, async () =&gt; {
      // Create test files
      await fs.writeFile(&#39;app.js&#39;, &#39;console.log(&quot;main app&quot;);&#39;);
      await fs.writeFile(&#39;build.js&#39;, &#39;console.log(&quot;build file&quot;);&#39;);
      await fs.ensureDir(&#39;node_modules&#39;);
      await fs.writeFile(&#39;node_modules/lib.js&#39;, &#39;console.log(&quot;dependency&quot;);&#39;);
      await fs.ensureDir(&#39;dist&#39;);
      await fs.writeFile(&#39;dist/output.js&#39;, &#39;console.log(&quot;compiled&quot;);&#39;);
      
      // Create .gitignore
      await fs.writeFile(&#39;.gitignore&#39;, &#39;node_modules/\ndist/\nbuild.js&#39;);
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: &#39;.&#39;,
        parseSubDirectories: true,
        useGitIgnoreForExcludes: true,
        parsedFileExtensions: {
          web: [&#39;.js&#39;]
        }
      };

      const result = await processFusion(testConfig);
      expect(result.success).toBe(true);
      expect(result.message).toContain(&#39;1 files processed&#39;); // Only app.js
      
      const fusionContent = await fs.readFile(result.fusionFilePath!, &#39;utf8&#39;);
      expect(fusionContent).toContain(&#39;app.js&#39;);
      expect(fusionContent).not.toContain(&#39;build.js&#39;);
      expect(fusionContent).not.toContain(&#39;node_modules&#39;);
      expect(fusionContent).not.toContain(&#39;dist&#39;);
    });

    it(&#39;should skip files larger than maxFileSizeKB&#39;, async () =&gt; {
      // Create small file
      await fs.writeFile(&#39;small.js&#39;, &#39;console.log(&quot;small&quot;);&#39;);
      
      // Create large file (2KB)
      const largeContent = &#39;console.log(&quot;large&quot;);&#39; + &#39;x&#39;.repeat(2000);
      await fs.writeFile(&#39;large.js&#39;, largeContent);
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: &#39;.&#39;,
        parseSubDirectories: false,
        maxFileSizeKB: 1, // 1KB limit
        parsedFileExtensions: {
          web: [&#39;.js&#39;]
        }
      };

      const result = await processFusion(testConfig);
      expect(result.success).toBe(true);
      expect(result.message).toContain(&#39;1 files processed&#39;); // Only small.js
      
      const fusionContent = await fs.readFile(result.fusionFilePath!, &#39;utf8&#39;);
      expect(fusionContent).toContain(&#39;small.js&#39;);
      expect(fusionContent).not.toContain(&#39;large.js&#39;);
    });

    it(&#39;should respect non-recursive directory parsing&#39;, async () =&gt; {
      // Create files in root
      await fs.writeFile(&#39;root.js&#39;, &#39;console.log(&quot;root&quot;);&#39;);
      
      // Create files in subdirectory
      await fs.ensureDir(&#39;sub&#39;);
      await fs.writeFile(&#39;sub/nested.js&#39;, &#39;console.log(&quot;nested&quot;);&#39;);
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: &#39;.&#39;,
        parseSubDirectories: false, // Non-recursive
        parsedFileExtensions: {
          web: [&#39;.js&#39;]
        }
      };

      const result = await processFusion(testConfig);
      expect(result.success).toBe(true);
      expect(result.message).toContain(&#39;1 files processed&#39;); // Only root.js
      
      const fusionContent = await fs.readFile(result.fusionFilePath!, &#39;utf8&#39;);
      expect(fusionContent).toContain(&#39;root.js&#39;);
      expect(fusionContent).not.toContain(&#39;nested.js&#39;);
    });

    it(&#39;should generate HTML output when enabled&#39;, async () =&gt; {
      // Create test files
      await fs.writeFile(&#39;test.js&#39;, &#39;console.log(&quot;Hello HTML&quot;);&#39;);
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: &#39;.&#39;,
        parseSubDirectories: false,
        generateHtml: true,
        parsedFileExtensions: {
          web: [&#39;.js&#39;]
        }
      };

      const result = await processFusion(testConfig);
      expect(result.success).toBe(true);
      
      // Check HTML file was created
      const htmlPath = result.fusionFilePath!.replace(&#39;.txt&#39;, &#39;.html&#39;);
      expect(await fs.pathExists(htmlPath)).toBe(true);
      
      const htmlContent = await fs.readFile(htmlPath, &#39;utf8&#39;);
      expect(htmlContent).toContain(&#39;&lt;!DOCTYPE html&gt;&#39;);
      expect(htmlContent).toContain(&#39;&lt;html lang=&quot;en&quot;&gt;&#39;);
      expect(htmlContent).toContain(&#39;test.js&#39;);
      expect(htmlContent).toContain(&#39;console.log(&amp;quot;Hello HTML&amp;quot;);&#39;);
    });
  });
});</code></pre>
    </div>

    <div class="file-section" id="tests-memory-fs-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/memory-fs.test.ts</h2>
        </div>
        <pre><code class="typescript">/**
 * Tests for MemoryFileSystemAdapter
 */
import { describe, it, expect, beforeEach } from &#39;vitest&#39;;
import { MemoryFileSystemAdapter } from &#39;../src/adapters/file-system.js&#39;;
import { createFilePath } from &#39;../src/types.js&#39;;

describe(&#39;MemoryFileSystemAdapter&#39;, () =&gt; {
    let fs: MemoryFileSystemAdapter;

    beforeEach(() =&gt; {
        fs = new MemoryFileSystemAdapter();
    });

    describe(&#39;File Operations&#39;, () =&gt; {
        it(&#39;should write and read files&#39;, async () =&gt; {
            const filePath = createFilePath(&#39;/test/file.txt&#39;);
            const content = &#39;Hello, World!&#39;;

            await fs.writeFile(filePath, content);
            const result = await fs.readFile(filePath);

            expect(result).toBe(content);
        });

        it(&#39;should append to files&#39;, async () =&gt; {
            const filePath = createFilePath(&#39;/test/file.txt&#39;);
            
            await fs.writeFile(filePath, &#39;Hello, &#39;);
            await fs.appendFile(filePath, &#39;World!&#39;);
            const result = await fs.readFile(filePath);

            expect(result).toBe(&#39;Hello, World!&#39;);
        });

        it(&#39;should append to non-existent files&#39;, async () =&gt; {
            const filePath = createFilePath(&#39;/new/file.txt&#39;);
            
            await fs.appendFile(filePath, &#39;New content&#39;);
            const result = await fs.readFile(filePath);

            expect(result).toBe(&#39;New content&#39;);
        });

        it(&#39;should throw error when reading non-existent file&#39;, async () =&gt; {
            const filePath = createFilePath(&#39;/missing/file.txt&#39;);
            
            await expect(fs.readFile(filePath)).rejects.toThrow(&#39;File not found&#39;);
        });

        it(&#39;should read files as buffer&#39;, async () =&gt; {
            const filePath = createFilePath(&#39;/test/file.txt&#39;);
            const content = &#39;Hello, Buffer!&#39;;

            await fs.writeFile(filePath, content);
            const buffer = await fs.readBuffer(filePath);

            expect(buffer).toBeInstanceOf(Buffer);
            expect(buffer.toString(&#39;utf8&#39;)).toBe(content);
        });
    });

    describe(&#39;File Stats&#39;, () =&gt; {
        it(&#39;should return stats for files&#39;, async () =&gt; {
            const filePath = createFilePath(&#39;/test/file.txt&#39;);
            const content = &#39;Hello, World!&#39;;

            await fs.writeFile(filePath, content);
            const stats = await fs.stat(filePath);

            expect(stats.isFile).toBe(true);
            expect(stats.isDirectory).toBe(false);
            expect(stats.isSymbolicLink).toBe(false);
            expect(stats.size).toBe(Buffer.byteLength(content, &#39;utf8&#39;));
        });

        it(&#39;should return stats for directories&#39;, async () =&gt; {
            const dirPath = createFilePath(&#39;/test/dir&#39;);
            
            await fs.ensureDir(dirPath);
            const stats = await fs.stat(dirPath);

            expect(stats.isFile).toBe(false);
            expect(stats.isDirectory).toBe(true);
            expect(stats.isSymbolicLink).toBe(false);
            expect(stats.size).toBe(0);
        });

        it(&#39;should throw error for non-existent paths&#39;, async () =&gt; {
            const filePath = createFilePath(&#39;/missing/file.txt&#39;);
            
            await expect(fs.stat(filePath)).rejects.toThrow(&#39;File not found&#39;);
        });

        it(&#39;should support lstat (same as stat for memory fs)&#39;, async () =&gt; {
            const filePath = createFilePath(&#39;/test/file.txt&#39;);
            
            await fs.writeFile(filePath, &#39;content&#39;);
            const stats = await fs.lstat(filePath);

            expect(stats.isFile).toBe(true);
            expect(stats.isSymbolicLink).toBe(false);
        });
    });

    describe(&#39;Directory Operations&#39;, () =&gt; {
        it(&#39;should ensure directories exist&#39;, async () =&gt; {
            const dirPath = &#39;/test/nested/deep&#39;;
            
            await fs.ensureDir(dirPath);
            
            expect(await fs.exists(createFilePath(dirPath))).toBe(true);
        });

        it(&#39;should check file existence&#39;, async () =&gt; {
            const filePath = createFilePath(&#39;/test/file.txt&#39;);
            
            expect(await fs.exists(filePath)).toBe(false);
            
            await fs.writeFile(filePath, &#39;content&#39;);
            expect(await fs.exists(filePath)).toBe(true);
        });

        it(&#39;should check directory existence&#39;, async () =&gt; {
            const dirPath = createFilePath(&#39;/test/dir&#39;);
            
            expect(await fs.exists(dirPath)).toBe(false);
            
            await fs.ensureDir(dirPath);
            expect(await fs.exists(dirPath)).toBe(true);
        });
    });

    describe(&#39;Glob Operations&#39;, () =&gt; {
        beforeEach(async () =&gt; {
            await fs.writeFile(createFilePath(&#39;/test/file1.js&#39;), &#39;content1&#39;);
            await fs.writeFile(createFilePath(&#39;/test/file2.ts&#39;), &#39;content2&#39;);
            await fs.writeFile(createFilePath(&#39;/test/nested/file3.js&#39;), &#39;content3&#39;);
            await fs.ensureDir(&#39;/test/empty-dir&#39;);
        });

        it(&#39;should glob all files and directories&#39;, async () =&gt; {
            const results = await fs.glob(&#39;*&#39;);
            
            expect(results.length).toBeGreaterThan(0);
            expect(results.map(p =&gt; p.toString())).toContain(&#39;/test/file1.js&#39;);
            expect(results.map(p =&gt; p.toString())).toContain(&#39;/test/file2.ts&#39;);
        });

        it(&#39;should glob files only when nodir option is set&#39;, async () =&gt; {
            const results = await fs.glob(&#39;*&#39;, { nodir: true });
            
            const paths = results.map(p =&gt; p.toString());
            expect(paths).toContain(&#39;/test/file1.js&#39;);
            expect(paths).not.toContain(&#39;/test/empty-dir&#39;);
        });

        it(&#39;should glob with follow option (no effect in memory fs)&#39;, async () =&gt; {
            const results = await fs.glob(&#39;*&#39;, { follow: true });
            
            expect(results.length).toBeGreaterThan(0);
        });
    });

    describe(&#39;Helper Methods&#39;, () =&gt; {
        it(&#39;should add files with addFile helper&#39;, async () =&gt; {
            fs.addFile(&#39;/test/file.txt&#39;, &#39;content&#39;);
            
            await expect(fs.readFile(createFilePath(&#39;/test/file.txt&#39;))).resolves.toBe(&#39;content&#39;);
        });

        it(&#39;should get all files with getFiles&#39;, async () =&gt; {
            await fs.writeFile(createFilePath(&#39;/file1.txt&#39;), &#39;content1&#39;);
            await fs.writeFile(createFilePath(&#39;/file2.txt&#39;), &#39;content2&#39;);
            
            const files = fs.getFiles();
            
            expect(files.size).toBe(2);
            expect(files.get(&#39;/file1.txt&#39;)).toBe(&#39;content1&#39;);
            expect(files.get(&#39;/file2.txt&#39;)).toBe(&#39;content2&#39;);
        });

        it(&#39;should clear all files and directories&#39;, async () =&gt; {
            await fs.writeFile(createFilePath(&#39;/file.txt&#39;), &#39;content&#39;);
            await fs.ensureDir(&#39;/dir&#39;);
            
            expect(await fs.exists(createFilePath(&#39;/file.txt&#39;))).toBe(true);
            expect(await fs.exists(createFilePath(&#39;/dir&#39;))).toBe(true);
            
            fs.clear();
            
            expect(await fs.exists(createFilePath(&#39;/file.txt&#39;))).toBe(false);
            expect(await fs.exists(createFilePath(&#39;/dir&#39;))).toBe(false);
        });
    });

    describe(&#39;Auto Directory Creation&#39;, () =&gt; {
        it(&#39;should auto-create parent directories when writing files&#39;, async () =&gt; {
            const filePath = createFilePath(&#39;/deep/nested/path/file.txt&#39;);
            
            await fs.writeFile(filePath, &#39;content&#39;);
            
            expect(await fs.exists(createFilePath(&#39;/deep/nested/path&#39;))).toBe(true);
            expect(await fs.readFile(filePath)).toBe(&#39;content&#39;);
        });
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-plugin-system-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/plugin-system.test.ts</h2>
        </div>
        <pre><code class="typescript">/**
 * Tests for Plugin System
 */
import { describe, it, expect, beforeEach, vi } from &#39;vitest&#39;;
import { join } from &#39;node:path&#39;;
import { 
    PluginManager, 
    BasePlugin, 
    createPlugin,
    type Plugin,
    type PluginMetadata,
    type OutputStrategy
} from &#39;../src/plugins/plugin-system.js&#39;;
import { MemoryFileSystemAdapter } from &#39;../src/adapters/file-system.js&#39;;
import { createFilePath, type Config } from &#39;../src/types.js&#39;;
import { defaultConfig } from &#39;../src/utils.js&#39;;

describe(&#39;Plugin System&#39;, () =&gt; {
    let pluginManager: PluginManager;
    let fs: MemoryFileSystemAdapter;
    let config: Config;

    beforeEach(() =&gt; {
        fs = new MemoryFileSystemAdapter();
        pluginManager = new PluginManager(fs);
        config = { ...defaultConfig };
    });

    describe(&#39;PluginManager&#39;, () =&gt; {
        describe(&#39;Plugin Registration&#39;, () =&gt; {
            it(&#39;should register and retrieve plugins&#39;, () =&gt; {
                const plugin = createPlugin({
                    name: &#39;test-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Test plugin&#39;
                });

                pluginManager.registerPlugin(plugin);
                const retrieved = pluginManager.getPlugin(&#39;test-plugin&#39;);

                expect(retrieved).toBe(plugin);
            });

            it(&#39;should unregister plugins&#39;, () =&gt; {
                const plugin = createPlugin({
                    name: &#39;test-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Test plugin&#39;
                });

                pluginManager.registerPlugin(plugin);
                pluginManager.unregisterPlugin(&#39;test-plugin&#39;);
                
                expect(pluginManager.getPlugin(&#39;test-plugin&#39;)).toBeUndefined();
            });

            it(&#39;should configure plugins&#39;, () =&gt; {
                const plugin = createPlugin({
                    name: &#39;test-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Test plugin&#39;
                });

                pluginManager.registerPlugin(plugin);
                pluginManager.configurePlugin(&#39;test-plugin&#39;, {
                    name: &#39;test-plugin&#39;,
                    enabled: false,
                    options: { key: &#39;value&#39; }
                });

                const enabledPlugins = pluginManager.getEnabledPlugins();
                expect(enabledPlugins).not.toContain(plugin);
            });

            it(&#39;should list plugin metadata&#39;, () =&gt; {
                const plugin1 = createPlugin({
                    name: &#39;plugin1&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;First plugin&#39;
                });
                const plugin2 = createPlugin({
                    name: &#39;plugin2&#39;,
                    version: &#39;2.0.0&#39;,
                    description: &#39;Second plugin&#39;
                });

                pluginManager.registerPlugin(plugin1);
                pluginManager.registerPlugin(plugin2);

                const metadata = pluginManager.listPlugins();
                expect(metadata).toHaveLength(2);
                expect(metadata[0].name).toBe(&#39;plugin1&#39;);
                expect(metadata[1].name).toBe(&#39;plugin2&#39;);
            });
        });

        describe(&#39;Plugin Loading&#39;, () =&gt; {
            it(&#39;should handle plugin loading errors gracefully&#39;, async () =&gt; {
                const consoleSpy = vi.spyOn(console, &#39;error&#39;).mockImplementation(() =&gt; {});

                // Try to load non-existent plugin
                await expect(pluginManager.loadPlugin(&#39;/non/existent/plugin.js&#39;)).rejects.toThrow();

                consoleSpy.mockRestore();
            });

            it(&#39;should load plugins from directory&#39;, async () =&gt; {
                const pluginsDir = &#39;/plugins&#39;;
                
                // Create a mock plugin file
                fs.addFile(&#39;/plugins/test-plugin.js&#39;, `
                    export default {
                        metadata: {
                            name: &#39;test-plugin&#39;,
                            version: &#39;1.0.0&#39;,
                            description: &#39;Test plugin&#39;
                        }
                    };
                `);

                const consoleSpy = vi.spyOn(console, &#39;warn&#39;).mockImplementation(() =&gt; {});

                await pluginManager.loadPluginsFromDirectory(pluginsDir);

                consoleSpy.mockRestore();
            });

            it(&#39;should handle missing plugins directory&#39;, async () =&gt; {
                await pluginManager.loadPluginsFromDirectory(&#39;/non/existent/dir&#39;);
                // Should not throw
            });
        });

        describe(&#39;Plugin Lifecycle&#39;, () =&gt; {
            it(&#39;should initialize plugins&#39;, async () =&gt; {
                const initSpy = vi.fn();
                const plugin = createPlugin({
                    name: &#39;test-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Test plugin&#39;
                }, {
                    initialize: initSpy
                });

                pluginManager.registerPlugin(plugin);
                await pluginManager.initializePlugins(config);

                expect(initSpy).toHaveBeenCalledWith(config);
            });

            it(&#39;should cleanup plugins&#39;, async () =&gt; {
                const cleanupSpy = vi.fn();
                const plugin = createPlugin({
                    name: &#39;test-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Test plugin&#39;
                }, {
                    cleanup: cleanupSpy
                });

                pluginManager.registerPlugin(plugin);
                await pluginManager.cleanupPlugins();

                expect(cleanupSpy).toHaveBeenCalled();
            });

            it(&#39;should handle plugin initialization errors&#39;, async () =&gt; {
                const consoleSpy = vi.spyOn(console, &#39;error&#39;).mockImplementation(() =&gt; {});
                const plugin = createPlugin({
                    name: &#39;failing-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Failing plugin&#39;
                }, {
                    initialize: async () =&gt; { throw new Error(&#39;Init failed&#39;); }
                });

                pluginManager.registerPlugin(plugin);
                await pluginManager.initializePlugins(config);

                expect(consoleSpy).toHaveBeenCalled();
                consoleSpy.mockRestore();
            });

            it(&#39;should handle plugin cleanup errors&#39;, async () =&gt; {
                const consoleSpy = vi.spyOn(console, &#39;error&#39;).mockImplementation(() =&gt; {});
                const plugin = createPlugin({
                    name: &#39;failing-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Failing plugin&#39;
                }, {
                    cleanup: async () =&gt; { throw new Error(&#39;Cleanup failed&#39;); }
                });

                pluginManager.registerPlugin(plugin);
                await pluginManager.cleanupPlugins();

                expect(consoleSpy).toHaveBeenCalled();
                consoleSpy.mockRestore();
            });
        });

        describe(&#39;Plugin Hooks&#39;, () =&gt; {
            it(&#39;should execute beforeFileProcessing hooks&#39;, async () =&gt; {
                const hookSpy = vi.fn().mockResolvedValue({
                    content: &#39;modified&#39;,
                    relativePath: &#39;test.js&#39;,
                    path: createFilePath(&#39;/test.js&#39;),
                    size: 8
                });

                const plugin = createPlugin({
                    name: &#39;test-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Test plugin&#39;
                }, {
                    beforeFileProcessing: hookSpy
                });

                pluginManager.registerPlugin(plugin);

                const fileInfo = {
                    content: &#39;original&#39;,
                    relativePath: &#39;test.js&#39;,
                    path: createFilePath(&#39;/test.js&#39;),
                    size: 8
                };

                const result = await pluginManager.executeBeforeFileProcessing(fileInfo, config);

                expect(hookSpy).toHaveBeenCalledWith(fileInfo, config);
                expect(result?.content).toBe(&#39;modified&#39;);
            });

            it(&#39;should filter out files when hook returns null&#39;, async () =&gt; {
                const plugin = createPlugin({
                    name: &#39;filter-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Filter plugin&#39;
                }, {
                    beforeFileProcessing: async () =&gt; null
                });

                pluginManager.registerPlugin(plugin);

                const fileInfo = {
                    content: &#39;content&#39;,
                    relativePath: &#39;test.js&#39;,
                    path: createFilePath(&#39;/test.js&#39;),
                    size: 7
                };

                const result = await pluginManager.executeBeforeFileProcessing(fileInfo, config);
                expect(result).toBeNull();
            });

            it(&#39;should execute afterFileProcessing hooks&#39;, async () =&gt; {
                const hookSpy = vi.fn().mockResolvedValue(&#39;processed content&#39;);

                const plugin = createPlugin({
                    name: &#39;test-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Test plugin&#39;
                }, {
                    afterFileProcessing: hookSpy
                });

                pluginManager.registerPlugin(plugin);

                const fileInfo = {
                    content: &#39;original&#39;,
                    relativePath: &#39;test.js&#39;,
                    path: createFilePath(&#39;/test.js&#39;),
                    size: 8
                };

                const result = await pluginManager.executeAfterFileProcessing(fileInfo, &#39;content&#39;, config);

                expect(hookSpy).toHaveBeenCalledWith(fileInfo, &#39;content&#39;, config);
                expect(result).toBe(&#39;processed content&#39;);
            });

            it(&#39;should execute beforeFusion hooks&#39;, async () =&gt; {
                const hookSpy = vi.fn().mockResolvedValue({
                    config: { ...config, maxFileSizeKB: 100 },
                    filesToProcess: []
                });

                const plugin = createPlugin({
                    name: &#39;test-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Test plugin&#39;
                }, {
                    beforeFusion: hookSpy
                });

                pluginManager.registerPlugin(plugin);

                const result = await pluginManager.executeBeforeFusion(config, []);

                expect(hookSpy).toHaveBeenCalledWith(config, []);
                expect(result.config.maxFileSizeKB).toBe(100);
            });

            it(&#39;should execute afterFusion hooks&#39;, async () =&gt; {
                const hookSpy = vi.fn().mockResolvedValue({ modified: true });

                const plugin = createPlugin({
                    name: &#39;test-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Test plugin&#39;
                }, {
                    afterFusion: hookSpy
                });

                pluginManager.registerPlugin(plugin);

                const result = await pluginManager.executeAfterFusion({ original: true }, config);

                expect(hookSpy).toHaveBeenCalledWith({ original: true }, config);
                expect(result.modified).toBe(true);
            });

            it(&#39;should handle hook errors gracefully&#39;, async () =&gt; {
                const consoleSpy = vi.spyOn(console, &#39;error&#39;).mockImplementation(() =&gt; {});
                
                const plugin = createPlugin({
                    name: &#39;failing-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Failing plugin&#39;
                }, {
                    beforeFileProcessing: async () =&gt; { throw new Error(&#39;Hook failed&#39;); }
                });

                pluginManager.registerPlugin(plugin);

                const fileInfo = {
                    content: &#39;content&#39;,
                    relativePath: &#39;test.js&#39;,
                    path: createFilePath(&#39;/test.js&#39;),
                    size: 7
                };

                const result = await pluginManager.executeBeforeFileProcessing(fileInfo, config);
                expect(result).toBe(fileInfo);
                expect(consoleSpy).toHaveBeenCalled();

                consoleSpy.mockRestore();
            });
        });

        describe(&#39;Output Strategies&#39;, () =&gt; {
            it(&#39;should get additional output strategies from plugins&#39;, () =&gt; {
                const strategy: OutputStrategy = {
                    name: &#39;custom&#39;,
                    extension: &#39;.custom&#39;,
                    generateHeader: () =&gt; &#39;header&#39;,
                    processFile: () =&gt; &#39;processed&#39;
                };

                const plugin = createPlugin({
                    name: &#39;strategy-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Strategy plugin&#39;
                }, {
                    registerOutputStrategies: () =&gt; [strategy]
                });

                pluginManager.registerPlugin(plugin);

                const strategies = pluginManager.getAdditionalOutputStrategies();
                expect(strategies).toContain(strategy);
            });

            it(&#39;should handle output strategy errors&#39;, () =&gt; {
                const consoleSpy = vi.spyOn(console, &#39;error&#39;).mockImplementation(() =&gt; {});
                
                const plugin = createPlugin({
                    name: &#39;failing-strategy-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Failing strategy plugin&#39;
                }, {
                    registerOutputStrategies: () =&gt; { throw new Error(&#39;Strategy failed&#39;); }
                });

                pluginManager.registerPlugin(plugin);

                const strategies = pluginManager.getAdditionalOutputStrategies();
                expect(strategies).toEqual([]);
                expect(consoleSpy).toHaveBeenCalled();

                consoleSpy.mockRestore();
            });
        });

        describe(&#39;File Extensions&#39;, () =&gt; {
            it(&#39;should get additional file extensions from plugins&#39;, () =&gt; {
                const extensions = { custom: [&#39;.custom1&#39;, &#39;.custom2&#39;] };

                const plugin = createPlugin({
                    name: &#39;extension-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Extension plugin&#39;
                }, {
                    registerFileExtensions: () =&gt; extensions
                });

                pluginManager.registerPlugin(plugin);

                const result = pluginManager.getAdditionalFileExtensions();
                expect(result).toEqual(extensions);
            });

            it(&#39;should handle file extension errors&#39;, () =&gt; {
                const consoleSpy = vi.spyOn(console, &#39;error&#39;).mockImplementation(() =&gt; {});
                
                const plugin = createPlugin({
                    name: &#39;failing-extension-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Failing extension plugin&#39;
                }, {
                    registerFileExtensions: () =&gt; { throw new Error(&#39;Extension failed&#39;); }
                });

                pluginManager.registerPlugin(plugin);

                const result = pluginManager.getAdditionalFileExtensions();
                expect(result).toEqual({});
                expect(consoleSpy).toHaveBeenCalled();

                consoleSpy.mockRestore();
            });
        });
    });

    describe(&#39;BasePlugin&#39;, () =&gt; {
        it(&#39;should create plugins with BasePlugin class&#39;, () =&gt; {
            class TestPlugin extends BasePlugin {
                metadata = {
                    name: &#39;test-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Test plugin&#39;
                };
            }

            const plugin = new TestPlugin();
            expect(plugin.metadata.name).toBe(&#39;test-plugin&#39;);
        });

        it(&#39;should support optional lifecycle methods&#39;, async () =&gt; {
            class TestPlugin extends BasePlugin {
                metadata = {
                    name: &#39;test-plugin&#39;,
                    version: &#39;1.0.0&#39;,
                    description: &#39;Test plugin&#39;
                };

                initCalled = false;
                cleanupCalled = false;

                async initialize() {
                    this.initCalled = true;
                }

                async cleanup() {
                    this.cleanupCalled = true;
                }
            }

            const plugin = new TestPlugin();
            
            if (plugin.initialize) await plugin.initialize(config);
            if (plugin.cleanup) await plugin.cleanup();

            expect(plugin.initCalled).toBe(true);
            expect(plugin.cleanupCalled).toBe(true);
        });
    });

    describe(&#39;createPlugin helper&#39;, () =&gt; {
        it(&#39;should create plugins with metadata only&#39;, () =&gt; {
            const metadata: PluginMetadata = {
                name: &#39;simple-plugin&#39;,
                version: &#39;1.0.0&#39;,
                description: &#39;Simple plugin&#39;
            };

            const plugin = createPlugin(metadata);
            expect(plugin.metadata).toEqual(metadata);
        });

        it(&#39;should create plugins with hooks&#39;, () =&gt; {
            const metadata: PluginMetadata = {
                name: &#39;hook-plugin&#39;,
                version: &#39;1.0.0&#39;,
                description: &#39;Hook plugin&#39;
            };

            const beforeFileProcessing = vi.fn();
            const plugin = createPlugin(metadata, { beforeFileProcessing });

            expect(plugin.metadata).toEqual(metadata);
            expect(plugin.beforeFileProcessing).toBe(beforeFileProcessing);
        });

        it(&#39;should support all optional metadata fields&#39;, () =&gt; {
            const metadata: PluginMetadata = {
                name: &#39;full-plugin&#39;,
                version: &#39;1.0.0&#39;,
                description: &#39;Full plugin&#39;,
                author: &#39;Test Author&#39;,
                homepage: &#39;https://example.com&#39;
            };

            const plugin = createPlugin(metadata);
            expect(plugin.metadata.author).toBe(&#39;Test Author&#39;);
            expect(plugin.metadata.homepage).toBe(&#39;https://example.com&#39;);
        });
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-property-based-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/property-based.test.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Property-based tests for Project Fusion using fast-check
 */
import { describe, it, expect } from &#39;vitest&#39;;
import fc from &#39;fast-check&#39;;
import { getExtensionsFromGroups, defaultConfig } from &#39;../src/utils.js&#39;;
import { isValidExtensionGroup } from &#39;../src/types.js&#39;;
import type { Config } from &#39;../src/types.js&#39;;

describe(&#39;Property-Based Tests&#39;, () =&gt; {
    describe(&#39;Extension Filtering&#39;, () =&gt; {
        // Generator for valid extension groups
        const validExtensionGroupArb = fc.constantFrom(
            &#39;web&#39;, &#39;backend&#39;, &#39;config&#39;, &#39;cpp&#39;, &#39;scripts&#39;, &#39;godot&#39;, &#39;doc&#39;
        );

        // Generator for file extensions
        const extensionArb = fc.string({ minLength: 1, maxLength: 10 })
            .filter(s =&gt; s.startsWith(&#39;.&#39;) &amp;&amp; s.length &gt; 1)
            .map(s =&gt; s.startsWith(&#39;.&#39;) ? s : `.${s}`)
            .filter(s =&gt; !s.includes(&#39; &#39;) &amp;&amp; !s.includes(&#39;\n&#39;));

        // Generator for config with extension groups
        const configArb = fc.record({
            parsedFileExtensions: fc.record({
                web: fc.array(extensionArb, { minLength: 0, maxLength: 20 }),
                backend: fc.array(extensionArb, { minLength: 0, maxLength: 20 }),
                config: fc.array(extensionArb, { minLength: 0, maxLength: 20 }),
                cpp: fc.array(extensionArb, { minLength: 0, maxLength: 20 }),
                scripts: fc.array(extensionArb, { minLength: 0, maxLength: 20 }),
                godot: fc.array(extensionArb, { minLength: 0, maxLength: 20 }),
                doc: fc.array(extensionArb, { minLength: 0, maxLength: 20 })
            })
        }, { requiredKeys: [&#39;parsedFileExtensions&#39;] }) as fc.Arbitrary&lt;Partial&lt;Config&gt;&gt;;

        it(&#39;should always return valid extensions when given valid groups&#39;, () =&gt; {
            fc.assert(fc.property(
                fc.array(validExtensionGroupArb, { minLength: 1, maxLength: 7 }),
                (groups) =&gt; {
                    const config = { ...defaultConfig };
                    const extensions = getExtensionsFromGroups(config, groups);
                    
                    // All returned extensions should start with a dot
                    expect(extensions.every(ext =&gt; ext.startsWith(&#39;.&#39;))).toBe(true);
                    
                    // Extensions should be strings
                    expect(extensions.every(ext =&gt; typeof ext === &#39;string&#39;)).toBe(true);
                    
                    // Should not contain empty strings
                    expect(extensions.every(ext =&gt; ext.length &gt; 1)).toBe(true);
                    
                    // Function may return duplicates if same group is specified multiple times
                    // This is acceptable behavior
                    expect(extensions.length).toBeGreaterThanOrEqual(0);
                }
            ));
        });

        it(&#39;should handle empty group arrays gracefully&#39;, () =&gt; {
            fc.assert(fc.property(
                configArb,
                (partialConfig) =&gt; {
                    const config = { ...defaultConfig, ...partialConfig };
                    const extensions = getExtensionsFromGroups(config, []);
                    
                    // Empty groups should return all extensions
                    expect(Array.isArray(extensions)).toBe(true);
                    expect(extensions.length).toBeGreaterThanOrEqual(0);
                }
            ));
        });

        it(&#39;should handle unknown groups by ignoring them&#39;, () =&gt; {
            fc.assert(fc.property(
                fc.array(fc.string(), { minLength: 1, maxLength: 10 })
                    .filter(groups =&gt; groups.every(g =&gt; !isValidExtensionGroup(g))),
                (unknownGroups) =&gt; {
                    const config = { ...defaultConfig };
                    const extensions = getExtensionsFromGroups(config, unknownGroups);
                    
                    // Unknown groups should result in empty array
                    expect(extensions).toEqual([]);
                }
            ));
        });

        it(&#39;should handle mixed valid and invalid groups&#39;, () =&gt; {
            fc.assert(fc.property(
                fc.tuple(
                    fc.array(validExtensionGroupArb, { minLength: 1, maxLength: 3 }),
                    fc.array(fc.string().filter(s =&gt; !isValidExtensionGroup(s)), { minLength: 1, maxLength: 3 })
                ),
                ([validGroups, invalidGroups]) =&gt; {
                    const config = { ...defaultConfig };
                    const mixedGroups = [...validGroups, ...invalidGroups];
                    const extensions = getExtensionsFromGroups(config, mixedGroups);
                    
                    // Should only return extensions from valid groups
                    const validOnlyExtensions = getExtensionsFromGroups(config, validGroups);
                    expect(extensions).toEqual(validOnlyExtensions);
                }
            ));
        });

        it(&#39;should handle duplicate groups by including extensions multiple times&#39;, () =&gt; {
            fc.assert(fc.property(
                fc.array(validExtensionGroupArb, { minLength: 2, maxLength: 7 }),
                (groups) =&gt; {
                    const config = { ...defaultConfig };
                    const extensions = getExtensionsFromGroups(config, groups);
                    
                    // Extensions may contain duplicates if same group is specified multiple times
                    // This is the current behavior and is acceptable
                    expect(Array.isArray(extensions)).toBe(true);
                    expect(extensions.every(ext =&gt; typeof ext === &#39;string&#39;)).toBe(true);
                }
            ));
        });

        it(&#39;should handle custom config extensions properly&#39;, () =&gt; {
            fc.assert(fc.property(
                configArb,
                validExtensionGroupArb,
                (partialConfig, group) =&gt; {
                    const config = { ...defaultConfig, ...partialConfig } as Config;
                    const extensions = getExtensionsFromGroups(config, [group]);
                    
                    // Extensions should come from the specified group in config
                    const expectedExtensions = config.parsedFileExtensions[group] || [];
                    expect(extensions).toEqual([...expectedExtensions]);
                }
            ));
        });
    });

    describe(&#39;Extension Group Validation&#39;, () =&gt; {
        it(&#39;should correctly identify valid extension groups&#39;, () =&gt; {
            fc.assert(fc.property(
                fc.string().filter(s =&gt; {
                    // Filter out object prototype properties that could cause issues
                    const prototypeMethods = [&#39;__proto__&#39;, &#39;constructor&#39;, &#39;prototype&#39;, &#39;toString&#39;, &#39;valueOf&#39;, &#39;hasOwnProperty&#39;, &#39;isPrototypeOf&#39;, &#39;propertyIsEnumerable&#39;];
                    return !prototypeMethods.includes(s);
                }),
                (input) =&gt; {
                    const isValid = isValidExtensionGroup(input);
                    const validGroups = [&#39;web&#39;, &#39;backend&#39;, &#39;config&#39;, &#39;cpp&#39;, &#39;scripts&#39;, &#39;godot&#39;, &#39;doc&#39;];
                    
                    if (validGroups.includes(input)) {
                        expect(isValid).toBe(true);
                    } else {
                        expect(isValid).toBe(false);
                    }
                }
            ));
        });

        // Test that valid groups are consistently valid
        it(&#39;should have stable validation for known valid groups&#39;, () =&gt; {
            const validGroups = [&#39;web&#39;, &#39;backend&#39;, &#39;config&#39;, &#39;cpp&#39;, &#39;scripts&#39;, &#39;godot&#39;, &#39;doc&#39;];
            
            fc.assert(fc.property(
                fc.constantFrom(...validGroups),
                (group) =&gt; {
                    expect(isValidExtensionGroup(group)).toBe(true);
                }
            ));
        });
    });

    describe(&#39;Config Merging Properties&#39;, () =&gt; {
        // Generator for partial configs
        const partialConfigArb = fc.record({
            generateText: fc.boolean(),
            generateMarkdown: fc.boolean(),
            generateHtml: fc.boolean(),
            maxFileSizeKB: fc.integer({ min: 1, max: 10000 }),
            parseSubDirectories: fc.boolean(),
            copyToClipboard: fc.boolean(),
            useGitIgnoreForExcludes: fc.boolean(),
            generatedFileName: fc.string({ minLength: 1, maxLength: 50 })
                .filter(s =&gt; !s.includes(&#39;/&#39;) &amp;&amp; !s.includes(&#39;\\&#39;) &amp;&amp; s.trim().length &gt; 0),
            ignorePatterns: fc.array(fc.string(), { maxLength: 10 })
        }, { requiredKeys: [] });

        it(&#39;should preserve user-provided values when merging configs&#39;, () =&gt; {
            fc.assert(fc.property(
                partialConfigArb,
                (partialConfig) =&gt; {
                    // This tests the behavior conceptually - actual merging happens in api.ts
                    // We&#39;re testing that the principle holds: user values should override defaults
                    const merged = { ...defaultConfig, ...partialConfig };
                    
                    // User-provided values should be preserved
                    Object.keys(partialConfig).forEach(key =&gt; {
                        expect(merged[key as keyof typeof merged]).toEqual(
                            partialConfig[key as keyof typeof partialConfig]
                        );
                    });
                    
                    // Required fields should always be present
                    expect(merged).toHaveProperty(&#39;schemaVersion&#39;);
                    expect(merged).toHaveProperty(&#39;parsedFileExtensions&#39;);
                    expect(merged).toHaveProperty(&#39;rootDirectory&#39;);
                }
            ));
        });
    });

    describe(&#39;Path and File Handling Properties&#39;, () =&gt; {
        // Generator for file paths (simplified)
        const filePathArb = fc.string({ minLength: 1, maxLength: 100 })
            .filter(s =&gt; !s.includes(&#39;\0&#39;) &amp;&amp; s.trim().length &gt; 0);

        const extensionArb = fc.constantFrom(&#39;.js&#39;, &#39;.ts&#39;, &#39;.py&#39;, &#39;.java&#39;, &#39;.go&#39;, &#39;.rs&#39;, &#39;.html&#39;, &#39;.css&#39;);

        it(&#39;should handle various file paths consistently&#39;, () =&gt; {
            fc.assert(fc.property(
                filePathArb,
                extensionArb,
                (basePath, extension) =&gt; {
                    const fullPath = basePath + extension;
                    
                    // Basic properties that should always hold
                    expect(typeof fullPath).toBe(&#39;string&#39;);
                    expect(fullPath.length).toBeGreaterThan(0);
                    expect(fullPath.endsWith(extension)).toBe(true);
                }
            ));
        });
    });

    describe(&#39;Error Handling Properties&#39;, () =&gt; {
        it(&#39;should handle edge cases in extension processing&#39;, () =&gt; {
            fc.assert(fc.property(
                fc.array(fc.string(), { maxLength: 20 }),
                (arbitraryGroups) =&gt; {
                    const config = { ...defaultConfig };
                    
                    // Should never throw an error, even with arbitrary input
                    expect(() =&gt; {
                        const result = getExtensionsFromGroups(config, arbitraryGroups);
                        expect(Array.isArray(result)).toBe(true);
                    }).not.toThrow();
                }
            ));
        });

        it(&#39;should handle empty and null-like inputs gracefully&#39;, () =&gt; {
            const config = { ...defaultConfig };
            
            // Test various edge cases
            expect(() =&gt; getExtensionsFromGroups(config, [])).not.toThrow();
            expect(() =&gt; getExtensionsFromGroups(config, [&#39;&#39;])).not.toThrow();
            expect(() =&gt; getExtensionsFromGroups(config, [&#39; &#39;])).not.toThrow();
            
            // Results should be predictable
            expect(getExtensionsFromGroups(config, [])).toEqual(
                expect.arrayContaining([])
            );
        });
    });

    describe(&#39;Performance Properties&#39;, () =&gt; {
        it(&#39;should handle large extension groups efficiently&#39;, () =&gt; {
            // Move validExtensionGroupArb here to fix scoping issue
            const validExtensionGroupArb = fc.constantFrom(
                &#39;web&#39;, &#39;backend&#39;, &#39;config&#39;, &#39;cpp&#39;, &#39;scripts&#39;, &#39;godot&#39;, &#39;doc&#39;
            );
            
            fc.assert(fc.property(
                fc.array(validExtensionGroupArb, { minLength: 1, maxLength: 7 }),
                (groups) =&gt; {
                    const config = { ...defaultConfig };
                    const startTime = Date.now();
                    
                    // Should complete quickly even with all groups
                    const extensions = getExtensionsFromGroups(config, groups);
                    const endTime = Date.now();
                    
                    // Should complete in reasonable time (less than 10ms)
                    expect(endTime - startTime).toBeLessThan(10);
                    expect(Array.isArray(extensions)).toBe(true);
                }
            ));
        });
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-schema-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/schema.test.ts</h2>
        </div>
        <pre><code class="typescript">import { describe, it, expect } from &#39;vitest&#39;;
import { ConfigSchemaV1 } from &#39;../src/schema.js&#39;;
import { defaultConfig } from &#39;../src/utils.js&#39;;

describe(&#39;schema&#39;, () =&gt; {
  describe(&#39;ConfigSchemaV1&#39;, () =&gt; {
    it(&#39;should validate default config&#39;, () =&gt; {
      const result = ConfigSchemaV1.safeParse(defaultConfig);
      expect(result.success).toBe(true);
    });

    it(&#39;should validate minimal valid config&#39;, () =&gt; {
      const minimalConfig = {
        schemaVersion: 1,
        generatedFileName: &quot;test-fusion&quot;,
        copyToClipboard: false,
        generateText: true,
        generateMarkdown: true,
        generateHtml: false,
        parsedFileExtensions: {
          web: [&quot;.js&quot;, &quot;.ts&quot;]
        },
        rootDirectory: &quot;.&quot;,
        parseSubDirectories: true,
        maxFileSizeKB: 1024,
        ignorePatterns: [],
        useGitIgnoreForExcludes: true
      };

      const result = ConfigSchemaV1.safeParse(minimalConfig);
      expect(result.success).toBe(true);
    });

    it(&#39;should reject config with invalid schema version&#39;, () =&gt; {
      const invalidConfig = {
        ...defaultConfig,
        schemaVersion: 2
      };

      const result = ConfigSchemaV1.safeParse(invalidConfig);
      expect(result.success).toBe(false);
    });

    it(&#39;should reject config with missing required fields&#39;, () =&gt; {
      const invalidConfig = {
        schemaVersion: 1
        // All other fields have defaults, so this should actually pass
      };

      const result = ConfigSchemaV1.safeParse(invalidConfig);
      expect(result.success).toBe(true); // Schema has defaults for all fields
    });

    it(&#39;should reject config with invalid copyToClipboard type&#39;, () =&gt; {
      const invalidConfig = {
        ...defaultConfig,
        copyToClipboard: &quot;true&quot; // Should be boolean
      };

      const result = ConfigSchemaV1.safeParse(invalidConfig);
      expect(result.success).toBe(false);
    });

    it(&#39;should validate config with copyToClipboard true&#39;, () =&gt; {
      const validConfig = {
        ...defaultConfig,
        copyToClipboard: true
      };

      const result = ConfigSchemaV1.safeParse(validConfig);
      expect(result.success).toBe(true);
    });

    it(&#39;should validate config with HTML generation enabled&#39;, () =&gt; {
      const validConfig = {
        ...defaultConfig,
        generateHtml: true
      };

      const result = ConfigSchemaV1.safeParse(validConfig);
      expect(result.success).toBe(true);
    });

    it(&#39;should validate config with HTML generation enabled&#39;, () =&gt; {
      const validConfig = {
        ...defaultConfig,
        generateHtml: true
      };

      const result = ConfigSchemaV1.safeParse(validConfig);
      expect(result.success).toBe(true);
    });
  });
});</code></pre>
    </div>

    <div class="file-section" id="tests-security-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/security.test.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Security tests for Project Fusion
 */
import { describe, it, expect, beforeEach, afterEach } from &#39;vitest&#39;;
import { join } from &#39;node:path&#39;;
import { writeFile, mkdir, rm } from &#39;node:fs/promises&#39;;
import { existsSync } from &#39;node:fs&#39;;
import { processFusion } from &#39;../src/fusion.js&#39;;
import { defaultConfig } from &#39;../src/utils.js&#39;;

describe(&#39;Security Tests&#39;, () =&gt; {
    const testDir = join(process.cwd(), &#39;temp&#39;, &#39;security-test&#39;);

    beforeEach(async () =&gt; {
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        await mkdir(testDir, { recursive: true });
        process.chdir(testDir);
    });

    afterEach(async () =&gt; {
        process.chdir(join(testDir, &#39;..&#39;, &#39;..&#39;));
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    describe(&#39;HTML Injection Protection&#39;, () =&gt; {
        it(&#39;should escape HTML in file content&#39;, async () =&gt; {
            // Create malicious HTML content
            const maliciousContent = `
console.log(&quot;test&quot;);
&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;
&lt;img src=&quot;x&quot; onerror=&quot;alert(&#39;XSS&#39;)&quot;&gt;
&amp;lt;div&amp;gt;Already escaped&amp;lt;/div&amp;gt;
&quot;quotes&quot; &amp; &#39;apostrophes&#39;
`;

            await writeFile(&#39;malicious.js&#39;, maliciousContent);

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateHtml: true,
                generateText: false,
                generateMarkdown: false,
                parsedFileExtensions: {
                    web: [&#39;.js&#39;]
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            // Read generated HTML
            const htmlContent = await import(&#39;fs&#39;).then(fs =&gt; 
                fs.promises.readFile(join(testDir, &#39;project-fusioned.html&#39;), &#39;utf8&#39;)
            );

            // Verify all dangerous HTML is escaped
            expect(htmlContent).toContain(&#39;&amp;lt;script&amp;gt;alert(&amp;#39;XSS&amp;#39;)&amp;lt;/script&amp;gt;&#39;);
            expect(htmlContent).toContain(&#39;&amp;lt;img src=&amp;quot;x&amp;quot; onerror=&amp;quot;alert(&amp;#39;XSS&amp;#39;)&amp;quot;&amp;gt;&#39;);
            expect(htmlContent).toContain(&#39;&amp;amp;lt;div&amp;amp;gt;Already escaped&amp;amp;lt;/div&amp;amp;gt;&#39;);
            expect(htmlContent).toContain(&#39;&amp;quot;quotes&amp;quot; &amp;amp; &amp;#39;apostrophes&amp;#39;&#39;);

            // Verify no unescaped dangerous content
            expect(htmlContent).not.toContain(&#39;&lt;script&gt;alert(&#39;);
            expect(htmlContent).not.toContain(&#39;&lt;img src=&quot;x&quot;&#39;);
            expect(htmlContent).not.toContain(&#39;onerror=&quot;alert(&#39;);
        });

        it(&#39;should escape HTML in file paths&#39;, async () =&gt; {
            // Create files with dangerous names
            const dangerousFileName = &#39;&lt;script&gt;alert(&quot;path&quot;).js&#39;;
            const safeFileName = &#39;safe-file.js&#39;;

            await writeFile(safeFileName, &#39;console.log(&quot;safe&quot;);&#39;);
            
            // We can&#39;t actually create a file with &lt; &gt; in the name on most filesystems
            // So we&#39;ll test by creating a file and then simulating the dangerous path
            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateHtml: true,
                generateText: false,
                generateMarkdown: false,
                parsedFileExtensions: {
                    web: [&#39;.js&#39;]
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            // Read generated HTML
            const htmlContent = await import(&#39;fs&#39;).then(fs =&gt; 
                fs.promises.readFile(join(testDir, &#39;project-fusioned.html&#39;), &#39;utf8&#39;)
            );

            // File paths should be HTML-escaped in titles and TOC
            expect(htmlContent).toContain(&#39;safe-file.js&#39;);
            
            // Verify no unescaped angle brackets that could be dangerous
            const tocSection = htmlContent.split(&#39;&lt;div class=&quot;toc&quot;&gt;&#39;)[1]?.split(&#39;&lt;/div&gt;&#39;)[0];
            const titleSections = htmlContent.split(&#39;&lt;h2&gt;üìÑ &#39;);
            
            expect(tocSection).toBeDefined();
            expect(titleSections.length).toBeGreaterThan(1);
            
            // All file references should not contain unescaped HTML
            titleSections.slice(1).forEach(section =&gt; {
                const title = section.split(&#39;&lt;/h2&gt;&#39;)[0];
                expect(title).not.toContain(&#39;&lt;script&#39;);
                expect(title).not.toContain(&#39;onerror=&#39;);
            });
        });

        it(&#39;should escape HTML in project title and version&#39;, async () =&gt; {
            // Create a package.json with dangerous content
            const dangerousPackageJson = {
                name: &#39;&lt;script&gt;alert(&quot;name&quot;)&lt;/script&gt;&#39;,
                version: &#39;1.0.0&lt;img src=x onerror=alert(&quot;version&quot;)&gt;&#39;,
                description: &#39;Test package&#39;
            };

            await writeFile(&#39;package.json&#39;, JSON.stringify(dangerousPackageJson, null, 2));
            await writeFile(&#39;test.js&#39;, &#39;console.log(&quot;test&quot;);&#39;);

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateHtml: true,
                generateText: false,
                generateMarkdown: false,
                parsedFileExtensions: {
                    web: [&#39;.js&#39;]
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            // Read generated HTML
            const htmlContent = await import(&#39;fs&#39;).then(fs =&gt; 
                fs.promises.readFile(join(testDir, &#39;project-fusioned.html&#39;), &#39;utf8&#39;)
            );

            // Project title should be escaped
            expect(htmlContent).toContain(&#39;&amp;lt;script&amp;gt;alert(&amp;quot;name&amp;quot;)&amp;lt;/script&amp;gt;&#39;);
            expect(htmlContent).toContain(&#39;1.0.0&amp;lt;img src=x onerror=alert(&amp;quot;version&amp;quot;)&amp;gt;&#39;);
            
            // Verify no unescaped dangerous content in header
            const headerSection = htmlContent.split(&#39;&lt;div class=&quot;header&quot;&gt;&#39;)[1]?.split(&#39;&lt;/div&gt;&#39;)[0];
            expect(headerSection).toBeDefined();
            expect(headerSection).not.toContain(&#39;&lt;script&gt;alert(&#39;);
            expect(headerSection).not.toContain(&#39;&lt;img src=x&#39;);
            // The dangerous tags are escaped, making them safe
            expect(headerSection).not.toContain(&#39;&lt;script&gt;&#39;);
            expect(headerSection).not.toContain(&#39;&lt;img &#39;);
        });
    });

    describe(&#39;Path Traversal Protection&#39;, () =&gt; {
        it(&#39;should handle relative paths safely&#39;, async () =&gt; {
            await writeFile(&#39;normal.js&#39;, &#39;console.log(&quot;normal&quot;);&#39;);
            
            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateHtml: true,
                parseSubDirectories: true,
                parsedFileExtensions: {
                    web: [&#39;.js&#39;]
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            // Should only process files within the root directory
            const htmlContent = await import(&#39;fs&#39;).then(fs =&gt; 
                fs.promises.readFile(join(testDir, &#39;project-fusioned.html&#39;), &#39;utf8&#39;)
            );

            expect(htmlContent).toContain(&#39;normal.js&#39;);
            // Should not escape outside the test directory
            expect(htmlContent).not.toContain(&#39;../../&#39;);
            expect(htmlContent).not.toContain(&#39;../security.test.ts&#39;);
        });
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-snapshots-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/snapshots.test.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Snapshot tests for verifying MD/HTML format output
 */
import { describe, it, expect, beforeEach, afterEach } from &#39;vitest&#39;;
import { join } from &#39;node:path&#39;;
import { writeFile, mkdir, rm, readFile } from &#39;node:fs/promises&#39;;
import { existsSync } from &#39;node:fs&#39;;
import { processFusion } from &#39;../src/fusion.js&#39;;
import { defaultConfig } from &#39;../src/utils.js&#39;;

describe(&#39;Format Snapshot Tests&#39;, () =&gt; {
    const testDir = join(process.cwd(), &#39;temp&#39;, &#39;snapshot-test&#39;);
    const originalCwd = process.cwd();

    beforeEach(async () =&gt; {
        // Clean up and create test directory
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        await mkdir(testDir, { recursive: true });
        process.chdir(testDir);
    });

    afterEach(async () =&gt; {
        process.chdir(originalCwd);
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    describe(&#39;Markdown Format Snapshots&#39;, () =&gt; {
        it(&#39;should generate consistent markdown format for JavaScript files&#39;, async () =&gt; {
            // Create sample JavaScript files
            await writeFile(&#39;index.js&#39;, `// Main application entry point
const express = require(&#39;express&#39;);
const app = express();

app.get(&#39;/&#39;, (req, res) =&gt; {
    res.send(&#39;Hello, World!&#39;);
});

app.listen(3000, () =&gt; {
    console.log(&#39;Server running on port 3000&#39;);
});`);

            await writeFile(&#39;utils.js&#39;, `// Utility functions
function formatDate(date) {
    return date.toISOString().split(&#39;T&#39;)[0];
}

function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

module.exports = { formatDate, capitalize };`);

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateText: false,
                generateMarkdown: true,
                generateHtml: false,
                generatedFileName: &#39;test-fusion&#39;,
                parsedFileExtensions: {
                    web: [&#39;.js&#39;]
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            const mdContent = await readFile(&#39;test-fusion.md&#39;, &#39;utf8&#39;);
            
            // Normalize timestamps for consistent snapshots
            const normalizedMd = mdContent
                .replace(/\*\*Generated:\*\* [^\n]+/g, &#39;**Generated:** [TIMESTAMP]&#39;)
                .replace(/\*\*UTC:\*\* [^\n]+/g, &#39;**UTC:** [UTC_TIMESTAMP]&#39;);
            
            // Test structure and content
            expect(normalizedMd).toMatchSnapshot(&#39;javascript-files.md&#39;);
        });

        it(&#39;should generate consistent markdown format for TypeScript files&#39;, async () =&gt; {
            await writeFile(&#39;types.ts&#39;, `// Type definitions
export interface User {
    id: number;
    name: string;
    email: string;
    createdAt: Date;
}

export type UserRole = &#39;admin&#39; | &#39;user&#39; | &#39;moderator&#39;;

export interface CreateUserRequest {
    name: string;
    email: string;
    role?: UserRole;
}`);

            await writeFile(&#39;service.ts&#39;, `// User service
import { User, CreateUserRequest, UserRole } from &#39;./types.js&#39;;

export class UserService {
    private users: User[] = [];
    private nextId = 1;

    createUser(request: CreateUserRequest): User {
        const user: User = {
            id: this.nextId++,
            name: request.name,
            email: request.email,
            createdAt: new Date()
        };
        
        this.users.push(user);
        return user;
    }

    findUser(id: number): User | undefined {
        return this.users.find(user =&gt; user.id === id);
    }
}`);

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateText: false,
                generateMarkdown: true,
                generateHtml: false,
                generatedFileName: &#39;typescript-fusion&#39;,
                parsedFileExtensions: {
                    web: [&#39;.ts&#39;]
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            const mdContent = await readFile(&#39;typescript-fusion.md&#39;, &#39;utf8&#39;);
            
            // Normalize timestamps for consistent snapshots
            const normalizedMd = mdContent
                .replace(/\*\*Generated:\*\* [^\n]+/g, &#39;**Generated:** [TIMESTAMP]&#39;)
                .replace(/\*\*UTC:\*\* [^\n]+/g, &#39;**UTC:** [UTC_TIMESTAMP]&#39;);
                
            expect(normalizedMd).toMatchSnapshot(&#39;typescript-files.md&#39;);
        });

        it(&#39;should generate consistent markdown format for mixed file types&#39;, async () =&gt; {
            await writeFile(&#39;config.json&#39;, `{
  &quot;name&quot;: &quot;test-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;dependencies&quot;: {
    &quot;express&quot;: &quot;^4.18.0&quot;,
    &quot;typescript&quot;: &quot;^5.0.0&quot;
  },
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;node index.js&quot;,
    &quot;build&quot;: &quot;tsc&quot;
  }
}`);

            await writeFile(&#39;README.md&#39;, `# Test Project

This is a test project for snapshot testing.

## Features

- **Fast**: Built with performance in mind
- **Secure**: Follows security best practices
- **Reliable**: Comprehensive test coverage

## Installation

\`\`\`bash
npm install
npm start
\`\`\`

## License

MIT License`);

            await writeFile(&#39;script.sh&#39;, `#!/bin/bash
# Deployment script

echo &quot;Starting deployment...&quot;

# Build the project
npm run build

# Run tests
npm test

# Deploy to production
echo &quot;Deploying to production...&quot;
rsync -av dist/ user@server:/var/www/app/

echo &quot;Deployment complete!&quot;`);

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateText: false,
                generateMarkdown: true,
                generateHtml: false,
                generatedFileName: &#39;mixed-fusion&#39;,
                parsedFileExtensions: {
                    config: [&#39;.json&#39;],
                    doc: [&#39;.md&#39;],
                    scripts: [&#39;.sh&#39;]
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            const mdContent = await readFile(&#39;mixed-fusion.md&#39;, &#39;utf8&#39;);
            
            // Normalize timestamps for consistent snapshots
            const normalizedMd = mdContent
                .replace(/\*\*Generated:\*\* [^\n]+/g, &#39;**Generated:** [TIMESTAMP]&#39;)
                .replace(/\*\*UTC:\*\* [^\n]+/g, &#39;**UTC:** [UTC_TIMESTAMP]&#39;);
                
            expect(normalizedMd).toMatchSnapshot(&#39;mixed-files.md&#39;);
        });
    });

    describe(&#39;HTML Format Snapshots&#39;, () =&gt; {
        it(&#39;should generate consistent HTML format for JavaScript files&#39;, async () =&gt; {
            await writeFile(&#39;app.js&#39;, `// Simple Express application
const express = require(&#39;express&#39;);
const path = require(&#39;path&#39;);

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(express.json());
app.use(express.static(&#39;public&#39;));

// Routes
app.get(&#39;/&#39;, (req, res) =&gt; {
    res.sendFile(path.join(__dirname, &#39;index.html&#39;));
});

app.get(&#39;/api/health&#39;, (req, res) =&gt; {
    res.json({ status: &#39;ok&#39;, timestamp: new Date().toISOString() });
});

// Start server
app.listen(PORT, () =&gt; {
    console.log(\`Server running on http://localhost:\${PORT}\`);
});`);

            await writeFile(&#39;helpers.js&#39;, `// Helper functions
const crypto = require(&#39;crypto&#39;);

/**
 * Generate a random ID
 * @param {number} length - Length of the ID
 * @returns {string} Random ID
 */
function generateId(length = 8) {
    return crypto.randomBytes(length).toString(&#39;hex&#39;);
}

/**
 * Validate email format
 * @param {string} email - Email to validate
 * @returns {boolean} True if valid
 */
function isValidEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
}

module.exports = {
    generateId,
    isValidEmail
};`);

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateText: false,
                generateMarkdown: false,
                generateHtml: true,
                generatedFileName: &#39;html-test&#39;,
                parsedFileExtensions: {
                    web: [&#39;.js&#39;]
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            const htmlContent = await readFile(&#39;html-test.html&#39;, &#39;utf8&#39;);
            
            // Normalize timestamps for consistent snapshots
            const normalizedHtml = htmlContent
                .replace(/Generated:&lt;\/strong&gt; [^&lt;]+/g, &#39;Generated:&lt;/strong&gt; [TIMESTAMP]&#39;)
                .replace(/UTC:&lt;\/strong&gt; [^&lt;]+/g, &#39;UTC:&lt;/strong&gt; [UTC_TIMESTAMP]&#39;);
            
            expect(normalizedHtml).toMatchSnapshot(&#39;javascript-files.html&#39;);
        });

        it(&#39;should generate consistent HTML format with proper escaping&#39;, async () =&gt; {
            await writeFile(&#39;template.html&#39;, `&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Test Template&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        .header {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;header&quot;&gt;
            &lt;h1&gt;Welcome to Test App&lt;/h1&gt;
            &lt;p&gt;This is a &lt;strong&gt;test&lt;/strong&gt; application with &lt;em&gt;HTML&lt;/em&gt; content.&lt;/p&gt;
        &lt;/div&gt;
        
        &lt;main&gt;
            &lt;h2&gt;Features &amp; Benefits&lt;/h2&gt;
            &lt;ul&gt;
                &lt;li&gt;Fast &amp; reliable&lt;/li&gt;
                &lt;li&gt;Secure by design&lt;/li&gt;
                &lt;li&gt;Easy to use&lt;/li&gt;
            &lt;/ul&gt;
            
            &lt;p&gt;Contact us at: &lt;a href=&quot;mailto:test@example.com&quot;&gt;test@example.com&lt;/a&gt;&lt;/p&gt;
        &lt;/main&gt;
    &lt;/div&gt;
    
    &lt;script&gt;
        console.log(&#39;Page loaded successfully!&#39;);
        document.addEventListener(&#39;DOMContentLoaded&#39;, () =&gt; {
            console.log(&#39;DOM ready&#39;);
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`);

            await writeFile(&#39;styles.css&#39;, `/* Global styles */
* {
    box-sizing: border-box;
}

body {
    margin: 0;
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, &#39;Segoe UI&#39;, sans-serif;
    line-height: 1.6;
    color: #333;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 20px;
}

/* Button styles */
.btn {
    display: inline-block;
    padding: 12px 24px;
    background: #007bff;
    color: white;
    text-decoration: none;
    border-radius: 4px;
    transition: background 0.3s ease;
}

.btn:hover {
    background: #0056b3;
}

/* Responsive design */
@media (max-width: 768px) {
    .container {
        padding: 0 10px;
    }
    
    .btn {
        display: block;
        text-align: center;
        margin: 10px 0;
    }
}`);

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateText: false,
                generateMarkdown: false,
                generateHtml: true,
                generatedFileName: &#39;html-escape-test&#39;,
                parsedFileExtensions: {
                    web: [&#39;.html&#39;, &#39;.css&#39;]
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            const htmlContent = await readFile(&#39;html-escape-test.html&#39;, &#39;utf8&#39;);
            
            // Normalize timestamps
            const normalizedHtml = htmlContent
                .replace(/Generated:&lt;\/strong&gt; [^&lt;]+/g, &#39;Generated:&lt;/strong&gt; [TIMESTAMP]&#39;)
                .replace(/UTC:&lt;\/strong&gt; [^&lt;]+/g, &#39;UTC:&lt;/strong&gt; [UTC_TIMESTAMP]&#39;);
            
            expect(normalizedHtml).toMatchSnapshot(&#39;html-with-escaping.html&#39;);
        });

        it(&#39;should generate HTML with proper table of contents structure&#39;, async () =&gt; {
            await mkdir(&#39;api&#39;, { recursive: true });
            await mkdir(&#39;components&#39;, { recursive: true });
            await mkdir(&#39;utils&#39;, { recursive: true });
            
            await writeFile(&#39;api/users.js&#39;, &#39;const users = [];&#39;);
            await writeFile(&#39;api/posts.js&#39;, &#39;const posts = [];&#39;);
            await writeFile(&#39;components/Header.js&#39;, &#39;export default function Header() {}&#39;);
            await writeFile(&#39;components/Footer.js&#39;, &#39;export default function Footer() {}&#39;);
            await writeFile(&#39;utils/database.js&#39;, &#39;class Database {}&#39;);

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateText: false,
                generateMarkdown: false,
                generateHtml: true,
                generatedFileName: &#39;toc-test&#39;,
                parsedFileExtensions: {
                    web: [&#39;.js&#39;]
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            const htmlContent = await readFile(&#39;toc-test.html&#39;, &#39;utf8&#39;);
            
            // Check TOC structure
            expect(htmlContent).toContain(&#39;&lt;div class=&quot;toc&quot;&gt;&#39;);
            expect(htmlContent).toContain(&#39;&lt;h2&gt;üìÅ Table of Contents&lt;/h2&gt;&#39;);
            expect(htmlContent).toContain(&#39;href=&quot;#api-users-js&quot;&#39;);
            expect(htmlContent).toContain(&#39;href=&quot;#components-header-js&quot;&#39;);
            
            // Normalize and snapshot
            const normalizedHtml = htmlContent
                .replace(/Generated:&lt;\/strong&gt; [^&lt;]+/g, &#39;Generated:&lt;/strong&gt; [TIMESTAMP]&#39;)
                .replace(/UTC:&lt;\/strong&gt; [^&lt;]+/g, &#39;UTC:&lt;/strong&gt; [UTC_TIMESTAMP]&#39;);
            
            expect(normalizedHtml).toMatchSnapshot(&#39;html-with-toc.html&#39;);
        });
    });

    describe(&#39;Cross-Format Consistency&#39;, () =&gt; {
        it(&#39;should maintain content consistency between markdown and HTML formats&#39;, async () =&gt; {
            await writeFile(&#39;example.ts&#39;, `// Example TypeScript module
export interface Config {
    apiUrl: string;
    timeout: number;
    retries: number;
}

export class ApiClient {
    constructor(private config: Config) {}
    
    async get&lt;T&gt;(path: string): Promise&lt;T&gt; {
        const response = await fetch(\`\${this.config.apiUrl}\${path}\`);
        if (!response.ok) {
            throw new Error(\`HTTP \${response.status}\`);
        }
        return response.json();
    }
}`);

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateText: false,
                generateMarkdown: true,
                generateHtml: true,
                generatedFileName: &#39;consistency-test&#39;,
                parsedFileExtensions: {
                    web: [&#39;.ts&#39;]
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            const mdContent = await readFile(&#39;consistency-test.md&#39;, &#39;utf8&#39;);
            const htmlContent = await readFile(&#39;consistency-test.html&#39;, &#39;utf8&#39;);

            // Both should contain the same source code
            expect(mdContent).toContain(&#39;export interface Config&#39;);
            expect(htmlContent).toContain(&#39;export interface Config&#39;);
            
            expect(mdContent).toContain(&#39;export class ApiClient&#39;);
            expect(htmlContent).toContain(&#39;export class ApiClient&#39;);
            
            // Both should reference the same file
            expect(mdContent).toContain(&#39;example.ts&#39;);
            expect(htmlContent).toContain(&#39;example.ts&#39;);
            
            // Both should have proper structure
            expect(mdContent).toContain(&#39;## üìÑ example.ts&#39;);
            expect(htmlContent).toContain(&#39;üìÑ example.ts&#39;);
        });
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-types-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/types.test.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for type definitions and branded types
 */
import { describe, expect, it } from &#39;vitest&#39;;
import { createFilePath, FusionError } from &#39;../src/types.js&#39;;
import type { FilePath, FusionErrorCode, FusionErrorSeverity } from &#39;../src/types.js&#39;;

describe(&#39;Branded Types&#39;, () =&gt; {
    describe(&#39;createFilePath&#39;, () =&gt; {
        it(&#39;should create a valid FilePath from a string&#39;, () =&gt; {
            const path = createFilePath(&#39;/valid/path/to/file.txt&#39;);
            expect(path).toBe(&#39;/valid/path/to/file.txt&#39;);
            expect(typeof path).toBe(&#39;string&#39;);
        });
        
        it(&#39;should throw FusionError for invalid inputs&#39;, () =&gt; {
            expect(() =&gt; createFilePath(&#39;&#39;)).toThrow(FusionError);
            expect(() =&gt; createFilePath(&#39;&#39;)).toThrow(&#39;Invalid file path provided&#39;);
            
            // @ts-expect-error Testing invalid input
            expect(() =&gt; createFilePath(null)).toThrow(FusionError);
            
            // @ts-expect-error Testing invalid input
            expect(() =&gt; createFilePath(undefined)).toThrow(FusionError);
            
            // @ts-expect-error Testing invalid input
            expect(() =&gt; createFilePath(123)).toThrow(FusionError);
        });
        
        it(&#39;should handle paths with special characters&#39;, () =&gt; {
            const specialPaths = [
                &#39;/path with spaces/file.txt&#39;,
                &#39;/path-with-dashes/file.txt&#39;,
                &#39;/path_with_underscores/file.txt&#39;,
                &#39;/path/with/unicode/Êñá‰ª∂.txt&#39;,
                &#39;C:\\Windows\\System32\\file.txt&#39;,
                &#39;./relative/path/file.txt&#39;,
                &#39;../parent/path/file.txt&#39;
            ];
            
            specialPaths.forEach(p =&gt; {
                const filePath = createFilePath(p);
                expect(filePath).toBe(p);
            });
        });
        
        it(&#39;should maintain type safety&#39;, () =&gt; {
            const path = createFilePath(&#39;/test/path.txt&#39;);
            
            // This should satisfy the FilePath type
            const acceptsFilePath = (fp: FilePath): string =&gt; fp;
            expect(acceptsFilePath(path)).toBe(&#39;/test/path.txt&#39;);
        });
    });
});

describe(&#39;FusionError&#39;, () =&gt; {
    describe(&#39;constructor&#39;, () =&gt; {
        it(&#39;should create error with required parameters&#39;, () =&gt; {
            const error = new FusionError(&#39;Test error&#39;, &#39;INVALID_PATH&#39;);
            
            expect(error).toBeInstanceOf(Error);
            expect(error).toBeInstanceOf(FusionError);
            expect(error.message).toBe(&#39;Test error&#39;);
            expect(error.code).toBe(&#39;INVALID_PATH&#39;);
            expect(error.severity).toBe(&#39;error&#39;); // Default severity
            expect(error.name).toBe(&#39;FusionError&#39;);
            expect(error.context).toBeUndefined();
        });
        
        it(&#39;should accept custom severity&#39;, () =&gt; {
            const errorSeverity = new FusionError(&#39;Error&#39;, &#39;INVALID_PATH&#39;, &#39;error&#39;);
            const warningSeverity = new FusionError(&#39;Warning&#39;, &#39;UNKNOWN_EXTENSION_GROUP&#39;, &#39;warning&#39;);
            const infoSeverity = new FusionError(&#39;Info&#39;, &#39;INVALID_PATH&#39;, &#39;info&#39;);
            
            expect(errorSeverity.severity).toBe(&#39;error&#39;);
            expect(warningSeverity.severity).toBe(&#39;warning&#39;);
            expect(infoSeverity.severity).toBe(&#39;info&#39;);
        });
        
        it(&#39;should accept context object&#39;, () =&gt; {
            const context = {
                path: &#39;/test/file.txt&#39;,
                line: 42,
                details: &#39;Additional information&#39;
            };
            
            const error = new FusionError(
                &#39;Error with context&#39;,
                &#39;INVALID_PATH&#39;,
                &#39;error&#39;,
                context
            );
            
            expect(error.context).toEqual(context);
        });
        
        it(&#39;should have proper stack trace&#39;, () =&gt; {
            const error = new FusionError(&#39;Stack test&#39;, &#39;INVALID_PATH&#39;);
            
            expect(error.stack).toBeDefined();
            expect(error.stack).toContain(&#39;FusionError: Stack test&#39;);
            expect(error.stack).toContain(&#39;types.test.ts&#39;);
        });
    });
    
    describe(&#39;Error Codes&#39;, () =&gt; {
        it(&#39;should only accept valid error codes&#39;, () =&gt; {
            const validCodes: FusionErrorCode[] = [
                &#39;INVALID_PATH&#39;,
                &#39;UNKNOWN_EXTENSION_GROUP&#39;
            ];
            
            validCodes.forEach(code =&gt; {
                const error = new FusionError(&#39;Test&#39;, code);
                expect(error.code).toBe(code);
            });
        });
        
        it(&#39;should maintain type safety for error codes&#39;, () =&gt; {
            // This should compile
            const error1 = new FusionError(&#39;Test&#39;, &#39;INVALID_PATH&#39;);
            const error2 = new FusionError(&#39;Test&#39;, &#39;UNKNOWN_EXTENSION_GROUP&#39;);
            
            expect(error1.code).toBe(&#39;INVALID_PATH&#39;);
            expect(error2.code).toBe(&#39;UNKNOWN_EXTENSION_GROUP&#39;);
            
            // TypeScript should prevent invalid codes at compile time
            // @ts-expect-error Invalid error code
            const invalidError = new FusionError(&#39;Test&#39;, &#39;INVALID_CODE&#39;);
        });
    });
    
    describe(&#39;Error Severity&#39;, () =&gt; {
        it(&#39;should only accept valid severity levels&#39;, () =&gt; {
            const validSeverities: FusionErrorSeverity[] = [
                &#39;error&#39;,
                &#39;warning&#39;,
                &#39;info&#39;
            ];
            
            validSeverities.forEach(severity =&gt; {
                const error = new FusionError(&#39;Test&#39;, &#39;INVALID_PATH&#39;, severity);
                expect(error.severity).toBe(severity);
            });
        });
        
        it(&#39;should maintain type safety for severity&#39;, () =&gt; {
            // Valid severities
            const error1 = new FusionError(&#39;Test&#39;, &#39;INVALID_PATH&#39;, &#39;error&#39;);
            const error2 = new FusionError(&#39;Test&#39;, &#39;INVALID_PATH&#39;, &#39;warning&#39;);
            const error3 = new FusionError(&#39;Test&#39;, &#39;INVALID_PATH&#39;, &#39;info&#39;);
            
            expect(error1.severity).toBe(&#39;error&#39;);
            expect(error2.severity).toBe(&#39;warning&#39;);
            expect(error3.severity).toBe(&#39;info&#39;);
            
            // TypeScript should prevent invalid severity at compile time
            // @ts-expect-error Invalid severity
            const invalidError = new FusionError(&#39;Test&#39;, &#39;INVALID_PATH&#39;, &#39;critical&#39;);
        });
    });
    
    describe(&#39;Error Usage Patterns&#39;, () =&gt; {
        it(&#39;should be catchable as FusionError&#39;, () =&gt; {
            try {
                throw new FusionError(&#39;Catchable error&#39;, &#39;INVALID_PATH&#39;);
            } catch (error) {
                expect(error).toBeInstanceOf(FusionError);
                if (error instanceof FusionError) {
                    expect(error.code).toBe(&#39;INVALID_PATH&#39;);
                    expect(error.severity).toBe(&#39;error&#39;);
                }
            }
        });
        
        it(&#39;should be catchable as generic Error&#39;, () =&gt; {
            try {
                throw new FusionError(&#39;Generic error&#39;, &#39;UNKNOWN_EXTENSION_GROUP&#39;);
            } catch (error) {
                expect(error).toBeInstanceOf(Error);
                if (error instanceof Error) {
                    expect(error.message).toBe(&#39;Generic error&#39;);
                }
            }
        });
        
        it(&#39;should support error chaining with context&#39;, () =&gt; {
            const originalError = new Error(&#39;Original error&#39;);
            
            const fusionError = new FusionError(
                &#39;Wrapped error: &#39; + originalError.message,
                &#39;INVALID_PATH&#39;,
                &#39;error&#39;,
                { originalError: originalError.message, timestamp: Date.now() }
            );
            
            expect(fusionError.message).toContain(&#39;Original error&#39;);
            expect(fusionError.context).toHaveProperty(&#39;originalError&#39;);
            expect(fusionError.context?.originalError).toBe(&#39;Original error&#39;);
        });
        
        it(&#39;should be serializable&#39;, () =&gt; {
            const error = new FusionError(
                &#39;Serializable error&#39;,
                &#39;INVALID_PATH&#39;,
                &#39;warning&#39;,
                { data: &#39;test&#39; }
            );
            
            const serialized = JSON.stringify({
                message: error.message,
                code: error.code,
                severity: error.severity,
                context: error.context
            });
            
            const deserialized = JSON.parse(serialized);
            
            expect(deserialized.message).toBe(&#39;Serializable error&#39;);
            expect(deserialized.code).toBe(&#39;INVALID_PATH&#39;);
            expect(deserialized.severity).toBe(&#39;warning&#39;);
            expect(deserialized.context).toEqual({ data: &#39;test&#39; });
        });
    });
    
    describe(&#39;Integration with createFilePath&#39;, () =&gt; {
        it(&#39;should throw FusionError with correct code&#39;, () =&gt; {
            try {
                createFilePath(&#39;&#39;);
            } catch (error) {
                expect(error).toBeInstanceOf(FusionError);
                if (error instanceof FusionError) {
                    expect(error.code).toBe(&#39;INVALID_PATH&#39;);
                    expect(error.severity).toBe(&#39;error&#39;);
                    expect(error.message).toBe(&#39;Invalid file path provided&#39;);
                }
            }
        });
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-utility-types-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/utility-types.test.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for utility types
 */
import { describe, it, expect } from &#39;vitest&#39;;
import {
    type NonEmptyArray,
    isNonEmptyArray,
    createNonEmptyArray,
    type ExtensionGroupName,
    EXTENSION_GROUPS,
    isValidExtensionGroup,
    getExtensionsForGroup,
    FusionError
} from &#39;../src/types.js&#39;;

describe(&#39;Utility Types&#39;, () =&gt; {
    describe(&#39;NonEmptyArray&#39;, () =&gt; {
        it(&#39;should correctly identify non-empty arrays&#39;, () =&gt; {
            expect(isNonEmptyArray([1, 2, 3])).toBe(true);
            expect(isNonEmptyArray([&#39;a&#39;])).toBe(true);
            expect(isNonEmptyArray([])).toBe(false);
        });

        it(&#39;should create non-empty arrays from valid arrays&#39;, () =&gt; {
            const result = createNonEmptyArray([1, 2, 3]);
            expect(result).toEqual([1, 2, 3]);
            
            // TypeScript should infer this as NonEmptyArray&lt;number&gt;
            const first: number = result[0];
            expect(first).toBe(1);
        });

        it(&#39;should throw error for empty arrays&#39;, () =&gt; {
            expect(() =&gt; createNonEmptyArray([])).toThrow(FusionError);
            expect(() =&gt; createNonEmptyArray([])).toThrow(&#39;Array must contain at least one element&#39;);
        });

        it(&#39;should preserve readonly nature&#39;, () =&gt; {
            const readonlyArray = [1, 2, 3] as const;
            const result = createNonEmptyArray(readonlyArray);
            
            // Should be assignable to NonEmptyArray
            const typed: NonEmptyArray&lt;number&gt; = result;
            expect(typed[0]).toBe(1);
        });
    });

    describe(&#39;ExtensionGroup&#39;, () =&gt; {
        it(&#39;should have correct extension groups defined&#39;, () =&gt; {
            expect(EXTENSION_GROUPS.web).toContain(&#39;.js&#39;);
            expect(EXTENSION_GROUPS.web).toContain(&#39;.ts&#39;);
            expect(EXTENSION_GROUPS.backend).toContain(&#39;.py&#39;);
            expect(EXTENSION_GROUPS.config).toContain(&#39;.json&#39;);
            expect(EXTENSION_GROUPS.cpp).toContain(&#39;.cpp&#39;);
            expect(EXTENSION_GROUPS.scripts).toContain(&#39;.sh&#39;);
            expect(EXTENSION_GROUPS.godot).toContain(&#39;.gd&#39;);
            expect(EXTENSION_GROUPS.doc).toContain(&#39;.md&#39;);
        });

        it(&#39;should validate extension group names&#39;, () =&gt; {
            expect(isValidExtensionGroup(&#39;web&#39;)).toBe(true);
            expect(isValidExtensionGroup(&#39;backend&#39;)).toBe(true);
            expect(isValidExtensionGroup(&#39;config&#39;)).toBe(true);
            expect(isValidExtensionGroup(&#39;invalid&#39;)).toBe(false);
            expect(isValidExtensionGroup(&#39;&#39;)).toBe(false);
        });

        it(&#39;should get extensions for valid groups&#39;, () =&gt; {
            const webExtensions = getExtensionsForGroup(&#39;web&#39;);
            expect(webExtensions).toContain(&#39;.js&#39;);
            expect(webExtensions).toContain(&#39;.ts&#39;);
            
            const backendExtensions = getExtensionsForGroup(&#39;backend&#39;);
            expect(backendExtensions).toContain(&#39;.py&#39;);
            expect(backendExtensions).toContain(&#39;.java&#39;);
        });

        it(&#39;should have all extensions as non-empty arrays&#39;, () =&gt; {
            const groupNames: ExtensionGroupName[] = Object.keys(EXTENSION_GROUPS) as ExtensionGroupName[];
            
            for (const groupName of groupNames) {
                const extensions = getExtensionsForGroup(groupName);
                expect(isNonEmptyArray(extensions)).toBe(true);
                expect(extensions.length).toBeGreaterThan(0);
            }
        });

        it(&#39;should have extensions starting with dot&#39;, () =&gt; {
            const groupNames: ExtensionGroupName[] = Object.keys(EXTENSION_GROUPS) as ExtensionGroupName[];
            
            for (const groupName of groupNames) {
                const extensions = getExtensionsForGroup(groupName);
                for (const ext of extensions) {
                    expect(ext.startsWith(&#39;.&#39;)).toBe(true);
                    expect(ext.length).toBeGreaterThan(1);
                }
            }
        });

        it(&#39;should not have duplicate extensions within groups&#39;, () =&gt; {
            const groupNames: ExtensionGroupName[] = Object.keys(EXTENSION_GROUPS) as ExtensionGroupName[];
            
            for (const groupName of groupNames) {
                const extensions = getExtensionsForGroup(groupName);
                const uniqueExtensions = new Set(extensions);
                expect(uniqueExtensions.size).toBe(extensions.length);
            }
        });

        it(&#39;should have extensions in alphabetical order within groups&#39;, () =&gt; {
            const groupNames: ExtensionGroupName[] = Object.keys(EXTENSION_GROUPS) as ExtensionGroupName[];
            
            for (const groupName of groupNames) {
                const extensions = getExtensionsForGroup(groupName);
                const sortedExtensions = [...extensions].sort();
                expect(extensions).toEqual(sortedExtensions);
            }
        });
    });

    describe(&#39;Type Safety&#39;, () =&gt; {
        it(&#39;should prevent invalid extension group access at compile time&#39;, () =&gt; {
            // This should work fine
            const validGroup: ExtensionGroupName = &#39;web&#39;;
            const extensions = getExtensionsForGroup(validGroup);
            expect(extensions).toBeDefined();
            
            // This would cause a TypeScript error if uncommented:
            // const invalidGroup: ExtensionGroupName = &#39;invalid&#39;;
            // getExtensionsForGroup(invalidGroup);
        });

        it(&#39;should enforce non-empty array constraints&#39;, () =&gt; {
            // This should work
            const validArray: NonEmptyArray&lt;string&gt; = [&#39;.js&#39;, &#39;.ts&#39;];
            expect(validArray[0]).toBe(&#39;.js&#39;);
            
            // This would cause a TypeScript error if uncommented:
            // const invalidArray: NonEmptyArray&lt;string&gt; = [];
        });
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-utils-coverage-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/utils-coverage.test.ts</h2>
        </div>
        <pre><code class="typescript">// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Additional tests to achieve 100% coverage for utils.ts
 */
import { describe, it, expect, beforeEach, afterEach, vi } from &#39;vitest&#39;;
import { join } from &#39;node:path&#39;;
import { writeFile, mkdir, rm, chmod, readFile } from &#39;fs-extra&#39;;
import { existsSync } from &#39;node:fs&#39;;
import {
    loadConfig,
    writeLog,
    validateSecurePath,
    validateNoSymlinks,
    isBinaryFile,
    getMarkdownLanguage
} from &#39;../src/utils.js&#39;;
import { FusionError } from &#39;../src/types.js&#39;;

describe(&#39;Utils Coverage Tests&#39;, () =&gt; {
    const testDir = join(process.cwd(), &#39;temp&#39;, &#39;utils-coverage-test&#39;);
    const originalCwd = process.cwd();

    beforeEach(async () =&gt; {
        // Clear all mocks before each test
        vi.clearAllMocks();
        
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        await mkdir(testDir, { recursive: true });
        process.chdir(testDir);
    });

    afterEach(async () =&gt; {
        process.chdir(originalCwd);
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    describe(&#39;loadConfig error handling&#39;, () =&gt; {
        it(&#39;should handle unknown validation errors&#39;, async () =&gt; {
            const consoleSpy = vi.spyOn(console, &#39;error&#39;).mockImplementation(() =&gt; {});
            
            // Create config with invalid JSON structure
            await writeFile(&#39;project-fusion.json&#39;, &#39;{&quot;schemaVersion&quot;: []}&#39;);

            const config = await loadConfig();
            
            expect(config).toEqual(expect.objectContaining({
                schemaVersion: 1,
                generatedFileName: &#39;project-fusioned&#39;
            }));
            
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining(&#39;Configuration validation failed&#39;));
            
            consoleSpy.mockRestore();
        });

    });

    describe(&#39;writeLog error handling&#39;, () =&gt; {
        it(&#39;should handle log write errors gracefully&#39;, async () =&gt; {
            const consoleSpy = vi.spyOn(console, &#39;error&#39;).mockImplementation(() =&gt; {});
            
            // Try to write to an invalid path
            await writeLog(&#39;/invalid/path/that/does/not/exist.log&#39;, &#39;test content&#39;);
            
            expect(consoleSpy).toHaveBeenCalledWith(&#39;Error writing log:&#39;, expect.any(Error));
            
            consoleSpy.mockRestore();
        });
    });


    describe(&#39;validateSecurePath error handling&#39;, () =&gt; {
        it(&#39;should detect path traversal attacks&#39;, () =&gt; {
            expect(() =&gt; {
                validateSecurePath(&#39;../../../etc/passwd&#39;, &#39;/safe/directory&#39;);
            }).toThrow(FusionError);
        });

        it(&#39;should handle invalid paths&#39;, () =&gt; {
            expect(() =&gt; {
                validateSecurePath(&#39;\x00invalid&#39;, &#39;/safe/directory&#39;);
            }).toThrow(FusionError);
        });

        it(&#39;should validate safe paths&#39;, () =&gt; {
            const safePath = validateSecurePath(&#39;./file.txt&#39;, process.cwd());
            expect(safePath).toBeDefined();
        });
    });

    describe(&#39;validateNoSymlinks&#39;, () =&gt; {
        it(&#39;should handle nonexistent files&#39;, async () =&gt; {
            const result = await validateNoSymlinks(&#39;/nonexistent/file.txt&#39;);
            expect(result).toBe(false);
        });

        it(&#39;should allow regular files&#39;, async () =&gt; {
            await writeFile(&#39;regular.txt&#39;, &#39;content&#39;);
            const result = await validateNoSymlinks(&#39;./regular.txt&#39;);
            expect(result).toBe(true);
        });
    });

    describe(&#39;isBinaryFile edge cases&#39;, () =&gt; {
        it(&#39;should handle empty files&#39;, async () =&gt; {
            await writeFile(&#39;empty.txt&#39;, &#39;&#39;);
            const result = await isBinaryFile(&#39;./empty.txt&#39;);
            expect(result).toBe(false);
        });

        it(&#39;should detect binary files with null bytes&#39;, async () =&gt; {
            // Create a file with null bytes
            const binaryContent = Buffer.from([0x00, 0x01, 0x02, 0x03]);
            await writeFile(&#39;binary.bin&#39;, binaryContent);
            
            const result = await isBinaryFile(&#39;./binary.bin&#39;);
            expect(result).toBe(true);
        });

        it(&#39;should detect files with high ratio of non-printable characters&#39;, async () =&gt; {
            // Create content with lots of non-printable characters
            const nonPrintableContent = Buffer.from(Array.from({ length: 1000 }, (_, i) =&gt; i % 256));
            await writeFile(&#39;nonprintable.bin&#39;, nonPrintableContent);
            
            const result = await isBinaryFile(&#39;./nonprintable.bin&#39;);
            expect(result).toBe(true);
        });

        it(&#39;should handle file read errors&#39;, async () =&gt; {
            // File that doesn&#39;t exist
            const result = await isBinaryFile(&#39;./nonexistent.txt&#39;);
            expect(result).toBe(false);
        });

        it(&#39;should handle files with undefined bytes gracefully&#39;, async () =&gt; {
            // This tests the byte checking logic with edge cases
            const content = Buffer.alloc(100);
            content.fill(32); // Fill with spaces (printable)
            await writeFile(&#39;spaces.txt&#39;, content);
            
            const result = await isBinaryFile(&#39;./spaces.txt&#39;);
            expect(result).toBe(false);
        });
    });

    describe(&#39;getMarkdownLanguage comprehensive mapping&#39;, () =&gt; {
        it(&#39;should handle case sensitivity&#39;, () =&gt; {
            expect(getMarkdownLanguage(&#39;.JS&#39;)).toBe(&#39;javascript&#39;);
            expect(getMarkdownLanguage(&#39;.dockerfile&#39;)).toBe(&#39;dockerfile&#39;);
            expect(getMarkdownLanguage(&#39;Dockerfile&#39;)).toBe(&#39;dockerfile&#39;);
        });

        it(&#39;should handle special file basenames&#39;, () =&gt; {
            expect(getMarkdownLanguage(&#39;Makefile&#39;)).toBe(&#39;makefile&#39;);
            expect(getMarkdownLanguage(&#39;Gemfile&#39;)).toBe(&#39;ruby&#39;);
            expect(getMarkdownLanguage(&#39;Vagrantfile&#39;)).toBe(&#39;ruby&#39;);
            expect(getMarkdownLanguage(&#39;requirements.txt&#39;)).toBe(&#39;text&#39;);
        });

        it(&#39;should fall back to text for unknown extensions&#39;, () =&gt; {
            expect(getMarkdownLanguage(&#39;.unknown&#39;)).toBe(&#39;text&#39;);
            expect(getMarkdownLanguage(&#39;.weird-extension&#39;)).toBe(&#39;text&#39;);
            expect(getMarkdownLanguage(&#39;&#39;)).toBe(&#39;text&#39;);
        });

        it(&#39;should handle all supported languages&#39;, () =&gt; {
            // Test a comprehensive set of languages
            const testCases = [
                [&#39;.py&#39;, &#39;python&#39;],
                [&#39;.rs&#39;, &#39;rust&#39;],
                [&#39;.go&#39;, &#39;go&#39;],
                [&#39;.java&#39;, &#39;java&#39;],
                [&#39;.cpp&#39;, &#39;cpp&#39;],
                [&#39;.c&#39;, &#39;c&#39;],
                [&#39;.h&#39;, &#39;c&#39;],
                [&#39;.hpp&#39;, &#39;cpp&#39;],
                [&#39;.cs&#39;, &#39;csharp&#39;],
                [&#39;.php&#39;, &#39;php&#39;],
                [&#39;.rb&#39;, &#39;ruby&#39;],
                [&#39;.html&#39;, &#39;html&#39;],
                [&#39;.css&#39;, &#39;css&#39;],
                [&#39;.js&#39;, &#39;javascript&#39;],
                [&#39;.ts&#39;, &#39;typescript&#39;],
                [&#39;.jsx&#39;, &#39;jsx&#39;],
                [&#39;.tsx&#39;, &#39;tsx&#39;],
                [&#39;.vue&#39;, &#39;vue&#39;],
                [&#39;.json&#39;, &#39;json&#39;],
                [&#39;.yaml&#39;, &#39;yaml&#39;],
                [&#39;.yml&#39;, &#39;yaml&#39;],
                [&#39;.toml&#39;, &#39;toml&#39;],
                [&#39;.xml&#39;, &#39;xml&#39;],
                [&#39;.md&#39;, &#39;markdown&#39;],
                [&#39;.sh&#39;, &#39;bash&#39;],
                [&#39;.bash&#39;, &#39;bash&#39;],
                [&#39;.ps1&#39;, &#39;powershell&#39;],
                [&#39;.sql&#39;, &#39;sql&#39;],
                [&#39;.gd&#39;, &#39;gdscript&#39;]
            ];

            for (const [ext, expected] of testCases) {
                expect(getMarkdownLanguage(ext)).toBe(expected);
            }
        });
    });
});</code></pre>
    </div>

    <div class="file-section" id="tests-utils-test-ts">
        <div class="file-title">
            <h2>üìÑ tests/utils.test.ts</h2>
        </div>
        <pre><code class="typescript">import { describe, it, expect, beforeEach, afterEach } from &#39;vitest&#39;;
import fs from &#39;fs-extra&#39;;
import path from &#39;path&#39;;
import { 
  getMarkdownLanguage, 
  getExtensionsFromGroups, 
  formatTimestamp,
  formatLocalTimestamp,
  loadConfig,
  writeLog,
  ensureDirectoryExists
} from &#39;../src/utils.js&#39;;
import { defaultConfig } from &#39;../src/utils.js&#39;;

describe(&#39;utils&#39;, () =&gt; {
  describe(&#39;getMarkdownLanguage&#39;, () =&gt; {
    it(&#39;should return correct language for file extensions&#39;, () =&gt; {
      expect(getMarkdownLanguage(&#39;.ts&#39;)).toBe(&#39;typescript&#39;);
      expect(getMarkdownLanguage(&#39;.js&#39;)).toBe(&#39;javascript&#39;);
      expect(getMarkdownLanguage(&#39;.py&#39;)).toBe(&#39;python&#39;);
      expect(getMarkdownLanguage(&#39;.json&#39;)).toBe(&#39;json&#39;);
    });

    it(&#39;should return correct language for files without extensions&#39;, () =&gt; {
      expect(getMarkdownLanguage(&#39;Dockerfile&#39;)).toBe(&#39;dockerfile&#39;);
      expect(getMarkdownLanguage(&#39;Makefile&#39;)).toBe(&#39;makefile&#39;);
      expect(getMarkdownLanguage(&#39;Jenkinsfile&#39;)).toBe(&#39;groovy&#39;);
    });

    it(&#39;should return text for unknown extensions&#39;, () =&gt; {
      expect(getMarkdownLanguage(&#39;.unknown&#39;)).toBe(&#39;text&#39;);
      expect(getMarkdownLanguage(&#39;UnknownFile&#39;)).toBe(&#39;text&#39;);
    });

    it(&#39;should handle case insensitive extensions&#39;, () =&gt; {
      expect(getMarkdownLanguage(&#39;.TS&#39;)).toBe(&#39;typescript&#39;);
      expect(getMarkdownLanguage(&#39;.JS&#39;)).toBe(&#39;javascript&#39;);
    });
  });

  describe(&#39;getExtensionsFromGroups&#39;, () =&gt; {
    it(&#39;should return all extensions when no groups specified&#39;, () =&gt; {
      const extensions = getExtensionsFromGroups(defaultConfig);
      expect(extensions.length).toBeGreaterThan(0);
      expect(extensions).toContain(&#39;.js&#39;);
      expect(extensions).toContain(&#39;.py&#39;);
      expect(extensions).toContain(&#39;.json&#39;);
    });

    it(&#39;should return extensions for specific groups&#39;, () =&gt; {
      const extensions = getExtensionsFromGroups(defaultConfig, [&#39;web&#39;]);
      expect(extensions).toContain(&#39;.js&#39;);
      expect(extensions).toContain(&#39;.ts&#39;);
      expect(extensions).toContain(&#39;.html&#39;);
      expect(extensions).not.toContain(&#39;.py&#39;);
    });

    it(&#39;should return extensions for multiple groups&#39;, () =&gt; {
      const extensions = getExtensionsFromGroups(defaultConfig, [&#39;web&#39;, &#39;backend&#39;]);
      expect(extensions).toContain(&#39;.js&#39;);
      expect(extensions).toContain(&#39;.py&#39;);
      expect(extensions).toContain(&#39;.go&#39;);
    });

    it(&#39;should handle unknown groups gracefully&#39;, () =&gt; {
      // Should return empty array for unknown groups and log warning
      const result = getExtensionsFromGroups(defaultConfig, [&#39;unknown&#39;]);
      expect(result).toEqual([]);
    });
  });

  describe(&#39;formatTimestamp&#39;, () =&gt; {
    it(&#39;should format current date when no date provided&#39;, () =&gt; {
      const timestamp = formatTimestamp();
      expect(timestamp).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/);
    });

    it(&#39;should format provided date&#39;, () =&gt; {
      const date = new Date(&#39;2025-01-01T12:00:00.000Z&#39;);
      const timestamp = formatTimestamp(date);
      expect(timestamp).toBe(&#39;2025-01-01T12:00:00.000Z&#39;);
    });
  });

  describe(&#39;formatLocalTimestamp&#39;, () =&gt; {
    it(&#39;should format current date when no date provided&#39;, () =&gt; {
      const timestamp = formatLocalTimestamp();
      expect(timestamp).toMatch(/^\d{2}\/\d{2}\/\d{4} \d{2}:\d{2}:\d{2}/);
    });

    it(&#39;should format provided date&#39;, () =&gt; {
      const date = new Date(&#39;2025-01-01T12:00:00.000Z&#39;);
      const timestamp = formatLocalTimestamp(date);
      expect(timestamp).toContain(&#39;01/01/2025&#39;);
    });
  });

  describe(&#39;file operations&#39;, () =&gt; {
    const testDir = path.resolve(&#39;./temp/test-utils&#39;);
    const testFile = path.join(testDir, &#39;test.txt&#39;);

    beforeEach(async () =&gt; {
      await fs.ensureDir(testDir);
    });

    afterEach(async () =&gt; {
      await fs.remove(testDir);
    });

    describe(&#39;ensureDirectoryExists&#39;, () =&gt; {
      it(&#39;should create directory if it does not exist&#39;, async () =&gt; {
        const newDir = path.join(testDir, &#39;new-dir&#39;);
        expect(await fs.pathExists(newDir)).toBe(false);
        
        await ensureDirectoryExists(newDir);
        expect(await fs.pathExists(newDir)).toBe(true);
      });

      it(&#39;should not fail if directory already exists&#39;, async () =&gt; {
        await ensureDirectoryExists(testDir);
        // Should not throw
        await ensureDirectoryExists(testDir);
        expect(await fs.pathExists(testDir)).toBe(true);
      });
    });


    describe(&#39;writeLog&#39;, () =&gt; {
      it(&#39;should write log content to file&#39;, async () =&gt; {
        const logFile = path.join(testDir, &#39;test.log&#39;);
        const logContent = &#39;Log entry&#39;;
        
        await writeLog(logFile, logContent);
        expect(await fs.pathExists(logFile)).toBe(true);
        const content = await fs.readFile(logFile, &#39;utf8&#39;);
        expect(content).toBe(logContent + &#39;\n&#39;);
      });

      it(&#39;should append log content when append is true&#39;, async () =&gt; {
        const logFile = path.join(testDir, &#39;test.log&#39;);
        const firstEntry = &#39;First entry&#39;;
        const secondEntry = &#39;Second entry&#39;;
        
        await writeLog(logFile, firstEntry);
        await writeLog(logFile, secondEntry, true);
        
        const content = await fs.readFile(logFile, &#39;utf8&#39;);
        expect(content).toBe(firstEntry + &#39;\n&#39; + secondEntry + &#39;\n&#39;);
      });

      it(&#39;should overwrite log content when append is false&#39;, async () =&gt; {
        const logFile = path.join(testDir, &#39;test.log&#39;);
        const firstEntry = &#39;First entry&#39;;
        const secondEntry = &#39;Second entry&#39;;
        
        await writeLog(logFile, firstEntry);
        await writeLog(logFile, secondEntry, false);
        
        const content = await fs.readFile(logFile, &#39;utf8&#39;);
        expect(content).toBe(secondEntry + &#39;\n&#39;);
      });
    });
  });

  describe(&#39;loadConfig&#39;, () =&gt; {
    const testDir = path.resolve(&#39;./temp/test-config&#39;);
    const configFile = path.join(testDir, &#39;project-fusion.json&#39;);

    beforeEach(async () =&gt; {
      await fs.ensureDir(testDir);
      // Set working directory to test directory
      process.chdir(testDir);
    });

    afterEach(async () =&gt; {
      // Restore original working directory
      process.chdir(path.resolve(&#39;./../../&#39;));
      await fs.remove(testDir);
    });

    it(&#39;should return default config when no config file exists&#39;, async () =&gt; {
      const config = await loadConfig();
      expect(config).toEqual(defaultConfig);
    });

    it(&#39;should load valid config from file&#39;, async () =&gt; {
      const validConfig = {
        schemaVersion: 1,
        generatedFileName: &#39;custom-fusion&#39;,
        copyToClipboard: true,
        generateText: true,
        generateMarkdown: false,
        generateHtml: true,
        parsedFileExtensions: {
          web: [&#39;.js&#39;, &#39;.ts&#39;]
        },
        parseSubDirectories: false,
        rootDirectory: &#39;.&#39;,
        maxFileSizeKB: 512,
        ignorePatterns: [&#39;*.log&#39;],
        useGitIgnoreForExcludes: false
      };

      await fs.writeJson(configFile, validConfig);
      const config = await loadConfig();
      // Config will be merged with defaults, so just check our specific values
      expect(config.schemaVersion).toBe(validConfig.schemaVersion);
      expect(config.generatedFileName).toBe(validConfig.generatedFileName);
      expect(config.copyToClipboard).toBe(validConfig.copyToClipboard);
      expect(config.generateText).toBe(validConfig.generateText);
      expect(config.generateMarkdown).toBe(validConfig.generateMarkdown);
      expect(config.generateHtml).toBe(validConfig.generateHtml);
      expect(config.parsedFileExtensions.web).toEqual(validConfig.parsedFileExtensions.web);
      expect(config.parseSubDirectories).toBe(validConfig.parseSubDirectories);
      expect(config.rootDirectory).toBe(validConfig.rootDirectory);
      expect(config.maxFileSizeKB).toBe(validConfig.maxFileSizeKB);
      expect(config.ignorePatterns).toEqual(validConfig.ignorePatterns);
      expect(config.useGitIgnoreForExcludes).toBe(validConfig.useGitIgnoreForExcludes);
    });

    it(&#39;should return default config for invalid JSON&#39;, async () =&gt; {
      await fs.writeFile(configFile, &#39;invalid json {&#39;);
      const config = await loadConfig();
      expect(config).toEqual(defaultConfig);
    });

    it(&#39;should return default config for invalid schema&#39;, async () =&gt; {
      const invalidConfig = {
        schemaVersion: &#39;invalid&#39;,
        invalidField: true
      };

      await fs.writeJson(configFile, invalidConfig);
      const config = await loadConfig();
      expect(config).toEqual(defaultConfig);
    });
  });
});</code></pre>
    </div>

    <div class="file-section" id="todo-md">
        <div class="file-title">
            <h2>üìÑ TODO.md</h2>
        </div>
        <pre><code class="markdown">- [ ] Plugin marketplace avec exemples
- [ ] Support formats additionnels (PDF, docx)
- [ ] Interface web pour configuration
- [ ] M√©triques et analytics d&#39;usage
- [ ] Support multi-langues pour documentation</code></pre>
    </div>

    <div class="file-section" id="tsconfig-json">
        <div class="file-title">
            <h2>üìÑ tsconfig.json</h2>
        </div>
        <pre><code class="json">{
    &quot;compilerOptions&quot;: {
        &quot;target&quot;: &quot;ES2022&quot;,
        &quot;module&quot;: &quot;NodeNext&quot;,
        &quot;moduleResolution&quot;: &quot;NodeNext&quot;,
        &quot;esModuleInterop&quot;: true,
        &quot;resolveJsonModule&quot;: true,
        &quot;strict&quot;: true,
        &quot;declaration&quot;: true,
        &quot;skipLibCheck&quot;: true,
        &quot;forceConsistentCasingInFileNames&quot;: true,
        &quot;noUncheckedIndexedAccess&quot;: true,
        &quot;exactOptionalPropertyTypes&quot;: true,
        &quot;verbatimModuleSyntax&quot;: true,
        &quot;useUnknownInCatchVariables&quot;: true,
        &quot;noPropertyAccessFromIndexSignature&quot;: true,
        &quot;noImplicitReturns&quot;: true,
        &quot;moduleDetection&quot;: &quot;force&quot;,
        &quot;outDir&quot;: &quot;./dist&quot;,
        &quot;rootDir&quot;: &quot;./src&quot;
    },
    &quot;include&quot;: [&quot;src/**/*&quot;],
    &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;dist&quot;]
}</code></pre>
    </div>

    <div class="file-section" id="vitest-config-ts">
        <div class="file-title">
            <h2>üìÑ vitest.config.ts</h2>
        </div>
        <pre><code class="typescript">import { defineConfig } from &#39;vitest/config&#39;;

export default defineConfig({
  test: {
    globals: true,
    environment: &#39;node&#39;,
    coverage: {
      provider: &#39;v8&#39;,
      reporter: [&#39;text&#39;, &#39;json&#39;, &#39;html&#39;],
      reportsDirectory: &#39;./coverage&#39;,
      include: [&#39;src/**/*.ts&#39;],
      exclude: [
        &#39;src/**/*.d.ts&#39;,
        &#39;src/cli.ts&#39;, // CLI entry point - harder to test
        &#39;node_modules/**&#39;
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      }
    }
  },
});</code></pre>
    </div>

</body>
</html>

<!-- ============================================================ -->
<!-- FILE: README.md                                              -->
<!-- ============================================================ -->
# Project Fusion

Project Fusion merges multiple project files into a single file for sharing and collaboration. It generates three output formats: plain text (.txt), markdown (.md), and HTML (.html) with syntax highlighting.

## Prerequisites

- **Node.js** version 18.0.0 or higher

## Installation

Install Project Fusion globally with npm:

```bash
npm install -g project-fusion
```

## Quick Start

1. **Initialize** Project Fusion in your project directory to customize settings (optional):
   ```bash
   cd your-project-directory
   project-fusion init
   ```

2. **Create fusion files** containing your project files:
   ```bash
   project-fusion
   ```
   This creates three files:
   - `project-fusioned.txt` - Plain text format with clear file separators and metadata header
   - `project-fusioned.md` - Markdown format with syntax highlighting, table of contents, and clickable navigation
   - `project-fusioned.html` - HTML format with responsive design, interactive table of contents, and styled code blocks

3. **Share the fusion files** for collaboration or analysis

## Commands

- `project-fusion` - Create fusion files from project files (default action)
- `project-fusion init` - Create Project Fusion setting file (optional) in current directory
- `project-fusion config-check` - Validate configuration and show active settings
- `project-fusion --help` - Show help information

## Documentation

- **[CLAUDE.md](./CLAUDE.md)** - AI context and technical documentation
- **[DEVELOPMENT.md](./DEVELOPMENT.md)** - Development workflows and testing
- **[CONTRIBUTING.md](./CONTRIBUTING.md)** - How to contribute to the project
- **[LICENSE](./LICENSE)** - MIT License terms

## Usage Workflow

When sharing your code:

1. Run `project-fusion` to create merged files
2. Choose the appropriate format:
   - **`.txt`** - Universal compatibility, plain text with clear file separators and metadata
   - **`.md`** - GitHub-compatible markdown with syntax highlighting and clickable table of contents
   - **`.html`** - Web-ready format with responsive design, interactive navigation, and styled code blocks
3. Share the fusion file with colleagues or collaborators
4. Use for code review, AI analysis, documentation, or project overview

The fusion files contain your project files in a single, organized format.

## Configuration

Project Fusion creates a `project-fusion.json` configuration file when you run `init`. You can customize:
- File extensions to include (organized by category: web, backend, config, etc.)
- Directories to scan or ignore
- Output file names and locations
- Use of .gitignore patterns
- Clipboard copying behavior

### Supported File Extensions

Project Fusion supports 38 file extensions organized by category:
- **Web**: .css, .html, .js, .jsx, .svelte, .ts, .tsx, .vue
- **Backend**: .cs, .go, .java, .php, .py, .rb, .rs
- **Config**: .json, .toml, .xml, .yaml, .yml
- **Scripts**: .bat, .cmd, .ps1, .sh
- **C/C++**: .c, .cc, .cpp, .h, .hpp
- **Godot**: .cfg, .cs, .gd, .import, .tscn, .tres
- **Documentation**: .adoc, .md, .rst

The markdown output applies syntax highlighting for each file type.

### Output Formats

Project Fusion generates three output formats simultaneously, each optimized for different use cases:

#### Text Format (`.txt`)
- **Purpose**: Universal compatibility for any text editor or system
- **Features**:
  - Clear file separators with descriptive headers (`<!-- FILE: path/to/file.js -->`)
  - Metadata header with project name, generation time, and file count
  - Raw code content without modification for maximum compatibility
  - Works with any text viewer, email, or system that supports plain text

#### Markdown Format (`.md`)
- **Purpose**: GitHub-compatible documentation with enhanced readability
- **Features**:
  - Automatic syntax highlighting based on file extensions
  - Interactive table of contents with anchor links to each file
  - Formatted headers and metadata for better visual presentation
  - Compatible with GitHub, GitLab, VS Code preview, and markdown renderers
  - Each file wrapped in appropriate code blocks (```language)

#### HTML Format (`.html`)
- **Purpose**: Web-ready sharing with professional presentation
- **Features**:
  - Responsive design for desktop and mobile devices
  - Interactive table of contents with smooth scrolling navigation
  - Styled code blocks with proper syntax highlighting
  - Professional typography and spacing for readability
  - Self-contained file with embedded CSS (no external dependencies)
  - Click-to-navigate between files with anchor links

### Format Configuration

You can control which formats are generated in your `project-fusion.json` configuration:

```json
{
  "generateText": true,     // Enable .txt format
  "generateMarkdown": true, // Enable .md format  
  "generateHtml": true      // Enable .html format
}
```

All formats are enabled by default for flexibility.

### Performance Features

- **File Size Limiting**: Configure `maxFileSizeKB` to skip large files (default: 1MB)
- **Streaming Support**: Process large projects with reduced memory usage
- **Performance Metrics**: Benchmarks logged including throughput and memory usage
- **Filtering**: Ignores binary files, images, archives, and compiled files

### Security Features

Project Fusion implements several security measures to protect against common attack vectors:

- **Path Traversal Protection**: All file paths are validated to ensure they remain within the configured root directory, preventing `../../../etc/passwd` style attacks
- **Symbolic Link Protection**: Symbolic links are detected and blocked by default to prevent directory traversal and access to files outside the project scope
- **Binary File Detection**: Binary files are automatically detected and skipped during processing to prevent corruption and improve performance
- **XSS Prevention**: All HTML output is properly escaped to prevent cross-site scripting attacks when sharing HTML fusion files
- **File System Security**: Uses `follow: false` in glob patterns to prevent following symbolic links during file discovery
- **Safe Error Handling**: Security-related errors are logged but don't expose sensitive path information to end users

These security features are enabled by default and require no additional configuration. All security validations are tested with comprehensive security test suites.

## Programmatic API

Project Fusion can be used as a library in other Node.js projects, such as VS Code extensions or build tools.

### Installation as a Dependency

```bash
npm install project-fusion
```

### Basic Usage

```typescript
import { fusionAPI, createConfig, runFusion } from 'project-fusion';

// Method 1: Simple API with partial config
const result = await fusionAPI({
    rootDirectory: '/path/to/project',
    generateHtml: false,
    parsedFileExtensions: {
        web: ['.ts', '.tsx'],
        backend: ['.py']
    }
});

// Method 2: Create config then run
const config = createConfig({
    generateHtml: false,
    maxFileSizeKB: 2048,
    ignorePatterns: ['tests/', '*.spec.ts']
});
const result = await runFusion(config);

// Method 3: Direct fusion with options
const result = await runFusion(
    { rootDirectory: '/my/project' },
    { extensionGroups: ['web', 'backend'] }
);
```

### VS Code Extension Example

```typescript
import * as vscode from 'vscode';
import { fusionAPI } from 'project-fusion';

export async function activate(context: vscode.ExtensionContext) {
    const disposable = vscode.commands.registerCommand('extension.fusionProject', async () => {
        const workspacePath = vscode.workspace.rootPath;
        
        if (!workspacePath) {
            vscode.window.showErrorMessage('No workspace folder open');
            return;
        }
        
        try {
            // Run fusion with dynamic config
            const result = await fusionAPI({
                rootDirectory: workspacePath,
                generateHtml: true,
                generateMarkdown: true,
                generateText: false,
                copyToClipboard: false,
                // Custom extensions for this workspace
                parsedFileExtensions: {
                    web: ['.ts', '.tsx', '.jsx'],
                    backend: [],
                    config: ['.json'],
                    cpp: [],
                    scripts: [],
                    godot: [],
                    doc: ['.md']
                }
            });
            
            if (result.success) {
                vscode.window.showInformationMessage(`Fusion completed: ${result.filesProcessed} files processed`);
            }
        } catch (error) {
            vscode.window.showErrorMessage(`Fusion failed: ${error.message}`);
        }
    });
    
    context.subscriptions.push(disposable);
}
```

### Advanced Usage Examples

#### Building Tool Integration

```typescript
import { fusionAPI } from 'project-fusion';
import { readFileSync } from 'fs';

// Integrate with a build system
async function generateProjectDocumentation(projectPath: string) {
    const packageJson = JSON.parse(readFileSync(`${projectPath}/package.json`, 'utf8'));
    
    const result = await fusionAPI({
        rootDirectory: projectPath,
        generatedFileName: `${packageJson.name}-docs`,
        generateText: false,        // Skip .txt for documentation
        generateMarkdown: true,     // Generate .md for GitHub
        generateHtml: true,         // Generate .html for hosting
        ignorePatterns: [
            'node_modules/',
            'dist/',
            '*.test.*',
            'coverage/'
        ],
        parsedFileExtensions: {
            web: ['.ts', '.tsx', '.js', '.jsx'],
            config: ['.json'],
            doc: ['.md']
        }
    });
    
    if (result.success) {
        console.log(`Documentation generated for ${packageJson.name}`);
        return result.fusionFilePath;
    } else {
        throw new Error(`Failed to generate docs: ${result.message}`);
    }
}
```

#### CI/CD Pipeline Example

```typescript
import { runFusion } from 'project-fusion';

// Use in GitHub Actions or other CI systems
async function generateReleaseArtifacts() {
    const config = {
        rootDirectory: process.env.GITHUB_WORKSPACE || process.cwd(),
        generatedFileName: `release-${process.env.GITHUB_SHA?.slice(0, 7)}`,
        copyToClipboard: false,     // Disable in CI
        maxFileSizeKB: 2048,       // Allow larger files
        ignorePatterns: [
            '.git/',
            'node_modules/',
            '*.log',
            'temp/'
        ]
    };
    
    const result = await runFusion(config, {
        extensionGroups: ['web', 'backend', 'config', 'doc']
    });
    
    if (result.success) {
        // Upload to release assets or artifact storage
        console.log(`Generated release artifacts at ${result.fusionFilePath}`);
    }
    
    return result;
}
```

#### Monorepo Support

```typescript
import { fusionAPI } from 'project-fusion';
import { readdirSync, statSync } from 'fs';
import { join } from 'path';

// Process multiple packages in a monorepo
async function processMonorepo(monorepoPath: string) {
    const packages = readdirSync(join(monorepoPath, 'packages'))
        .filter(dir => statSync(join(monorepoPath, 'packages', dir)).isDirectory());
    
    const results = await Promise.all(
        packages.map(async (packageName) => {
            const packagePath = join(monorepoPath, 'packages', packageName);
            
            return await fusionAPI({
                rootDirectory: packagePath,
                generatedFileName: `${packageName}-fusion`,
                generateHtml: false,
                parsedFileExtensions: {
                    web: ['.ts', '.tsx'],
                    backend: ['.js'],
                    config: ['.json', '.yaml']
                },
                ignorePatterns: [
                    'node_modules/',
                    'dist/',
                    '*.spec.*'
                ]
            });
        })
    );
    
    const successful = results.filter(r => r.success);
    console.log(`Processed ${successful.length}/${packages.length} packages`);
    
    return results;
}
```

#### Custom File Processing

```typescript
import { createConfig, runFusion } from 'project-fusion';

// Create fusion for specific file types only
async function createTypescriptOnlyFusion(projectPath: string) {
    const config = createConfig({
        rootDirectory: projectPath,
        generatedFileName: 'typescript-only',
        generateText: true,
        generateMarkdown: false,
        generateHtml: false,
        parsedFileExtensions: {
            web: ['.ts', '.tsx'],      // Only TypeScript files
            backend: [],               // No backend files
            config: ['.json'],         // Only JSON configs
            scripts: [],               // No scripts
            cpp: [],                   // No C++ files
            godot: [],                 // No Godot files
            doc: []                    // No documentation files
        },
        ignorePatterns: [
            '*.test.ts',
            '*.spec.ts',
            '*.d.ts',                  // Skip type definitions
            'node_modules/',
            'dist/'
        ]
    });
    
    return await runFusion(config);
}
```

### API Reference

#### `fusionAPI(options: ProgrammaticFusionOptions): Promise<ProgrammaticFusionResult>`
Main API function for programmatic use with partial configuration.

**Parameters:**
- `options.rootDirectory?: string` - Project root directory
- `options.extensionGroups?: string[]` - Extension groups to include
- `options.generateText?: boolean` - Enable .txt format (default: true)
- `options.generateMarkdown?: boolean` - Enable .md format (default: true)
- `options.generateHtml?: boolean` - Enable .html format (default: true)
- `options.ignorePatterns?: string[]` - Custom ignore patterns
- `options.maxFileSizeKB?: number` - Maximum file size limit

#### `createConfig(overrides: Partial<Config>): Config`
Creates a complete configuration object with defaults.

#### `runFusion(config: Partial<Config> | Config, options?: FusionOptions): Promise<FusionResult>`
Runs fusion with a configuration object (partial or complete).

**Returns:** Promise resolving to FusionResult with success status, file paths, and error details.

### Custom Extension Groups

You can define custom extension groups beyond the predefined categories:

```javascript
{
    parsedFileExtensions: {
        web: ['.ts', '.tsx', '.js'],
        backend: ['.py', '.go'],
        // Add custom groups
        data: ['.csv', '.xlsx', '.parquet'],
        mobile: ['.swift', '.kt', '.dart']
    }
}
```

## Distribution

- **GitHub**: [github.com/the99studio/project-fusion](https://github.com/the99studio/project-fusion)
- **NPM**: [npmjs.com/package/project-fusion](https://www.npmjs.com/package/project-fusion)

## License

This project is licensed under the MIT License - see the [LICENSE](./LICENSE) file for details.

<!-- ============================================================ -->
<!-- FILE: src/adapters/file-system.ts                            -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * File system abstraction layer for I/O operations
 */
import path from 'node:path';
import fs from 'fs-extra';
import { glob } from 'glob';
import { type FilePath, createFilePath } from '../types.js';

export interface FileSystemStats {
    size: number;
    isDirectory: boolean;
    isFile: boolean;
    isSymbolicLink: boolean;
}

export interface FileSystemAdapter {
    readFile(filePath: FilePath): Promise<string>;
    writeFile(filePath: FilePath, content: string): Promise<void>;
    appendFile(filePath: FilePath, content: string): Promise<void>;
    stat(filePath: FilePath): Promise<FileSystemStats>;
    lstat(filePath: FilePath): Promise<FileSystemStats>;
    exists(filePath: FilePath): Promise<boolean>;
    ensureDir(dirPath: string): Promise<void>;
    glob(pattern: string, options?: { nodir?: boolean; follow?: boolean }): Promise<FilePath[]>;
    readBuffer(filePath: FilePath, options?: { encoding: null }): Promise<Buffer>;
}

export class DefaultFileSystemAdapter implements FileSystemAdapter {
    async readFile(filePath: FilePath): Promise<string> {
        return await fs.readFile(filePath, 'utf8');
    }

    async writeFile(filePath: FilePath, content: string): Promise<void> {
        await fs.writeFile(filePath, content);
    }

    async appendFile(filePath: FilePath, content: string): Promise<void> {
        await fs.appendFile(filePath, content);
    }

    async stat(filePath: FilePath): Promise<FileSystemStats> {
        const stats = await fs.stat(filePath);
        return {
            size: stats.size,
            isDirectory: stats.isDirectory(),
            isFile: stats.isFile(),
            isSymbolicLink: stats.isSymbolicLink()
        };
    }

    async lstat(filePath: FilePath): Promise<FileSystemStats> {
        const stats = await fs.lstat(filePath);
        return {
            size: stats.size,
            isDirectory: stats.isDirectory(),
            isFile: stats.isFile(),
            isSymbolicLink: stats.isSymbolicLink()
        };
    }

    async exists(filePath: FilePath): Promise<boolean> {
        return await fs.pathExists(filePath);
    }

    async ensureDir(dirPath: string): Promise<void> {
        await fs.ensureDir(dirPath);
    }

    async glob(pattern: string, options?: { nodir?: boolean; follow?: boolean }): Promise<FilePath[]> {
        const filePaths = await glob(pattern, options);
        return filePaths.map(createFilePath);
    }

    async readBuffer(filePath: FilePath, options?: { encoding: null }): Promise<Buffer> {
        return await fs.readFile(filePath, options);
    }
}

export class MemoryFileSystemAdapter implements FileSystemAdapter {
    private readonly files: Map<string, string> = new Map();
    private readonly directories: Set<string> = new Set();

    readFile(filePath: FilePath): Promise<string> {
        const content = this.files.get(filePath);
        if (content === undefined) {
            return Promise.reject(new Error(`File not found: ${filePath}`));
        }
        return Promise.resolve(content);
    }

    writeFile(filePath: FilePath, content: string): Promise<void> {
        const dir = path.dirname(filePath);
        this.directories.add(dir);
        this.files.set(filePath, content);
        return Promise.resolve();
    }

    async appendFile(filePath: FilePath, content: string): Promise<void> {
        const existing = this.files.get(filePath) ?? '';
        await this.writeFile(filePath, existing + content);
    }

    stat(filePath: FilePath): Promise<FileSystemStats> {
        if (this.files.has(filePath)) {
            const content = this.files.get(filePath)!;
            return Promise.resolve({
                size: Buffer.byteLength(content, 'utf8'),
                isDirectory: false,
                isFile: true,
                isSymbolicLink: false
            });
        }
        if (this.directories.has(filePath)) {
            return Promise.resolve({
                size: 0,
                isDirectory: true,
                isFile: false,
                isSymbolicLink: false
            });
        }
        return Promise.reject(new Error(`File not found: ${filePath}`));
    }

    async lstat(filePath: FilePath): Promise<FileSystemStats> {
        return this.stat(filePath);
    }

    exists(filePath: FilePath): Promise<boolean> {
        return Promise.resolve(this.files.has(filePath) || this.directories.has(filePath));
    }

    ensureDir(dirPath: string): Promise<void> {
        this.directories.add(dirPath);
        return Promise.resolve();
    }

    glob(pattern: string, options?: { nodir?: boolean; follow?: boolean }): Promise<FilePath[]> {
        const allPaths = [...this.files.keys(), ...this.directories.keys()];
        const result = allPaths
            .filter(p => {
                if (options?.nodir && this.directories.has(p)) return false;
                return true;
            })
            .map(createFilePath);
        return Promise.resolve(result);
    }

    async readBuffer(filePath: FilePath): Promise<Buffer> {
        const content = await this.readFile(filePath);
        return Buffer.from(content, 'utf8');
    }

    addFile(filePath: string, content: string): void {
        this.files.set(filePath, content);
        const dir = path.dirname(filePath);
        this.ensureParentDirectory(dir);
        this.directories.add(dir);
    }

    private ensureParentDirectory(dirPath: string): void {
        const parent = path.dirname(dirPath);
        if (parent && parent !== dirPath && parent !== '.') {
            this.ensureParentDirectory(parent);
            this.directories.add(parent);
        }
    }

    getFiles(): Map<string, string> {
        return new Map(this.files);
    }

    clear(): void {
        this.files.clear();
        this.directories.clear();
    }
}

<!-- ============================================================ -->
<!-- FILE: src/api.ts                                             -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Programmatic API for Project Fusion
 * Allows external packages to use fusion functionality without config files
 */
import path from 'node:path';

import { processFusion } from './fusion.js';
import type { Config, FilePath, FusionOptions, FusionResult } from './types.js';
import { defaultConfig } from './utils.js';

/**
 * Options for programmatic fusion
 */
export interface ProgrammaticFusionOptions extends Partial<Config> {
    /** Working directory (defaults to process.cwd()) */
    cwd?: string;
    /** Extension groups to include */
    extensionGroups?: string[];
    /** Root directory override */
    rootDir?: string;
}

/**
 * Result from programmatic fusion
 */
export interface ProgrammaticFusionResult {
    /** Error object (if failed) */
    error?: Error | undefined;
    /** Number of files processed (if successful) */
    filesProcessed?: number;
    /** Path to the fusion file (if successful) */
    fusionFilePath?: FilePath;
    /** Path to the log file */
    logFilePath?: FilePath;
    /** Status message */
    message: string;
    /** Whether the fusion was successful */
    success: boolean;
}

/**
 * Merge partial config with defaults
 * @param partialConfig Partial configuration to merge
 * @param cwd Current working directory
 * @returns Complete configuration
 */
function mergeWithDefaults(partialConfig: Partial<Config>, cwd: string): Config {
    const rootDirectory = partialConfig.rootDirectory ?? cwd;
    
    return {
        copyToClipboard: partialConfig.copyToClipboard ?? defaultConfig.copyToClipboard,
        generatedFileName: partialConfig.generatedFileName ?? defaultConfig.generatedFileName,
        generateHtml: partialConfig.generateHtml ?? defaultConfig.generateHtml,
        generateMarkdown: partialConfig.generateMarkdown ?? defaultConfig.generateMarkdown,
        generateText: partialConfig.generateText ?? defaultConfig.generateText,
        ignorePatterns: partialConfig.ignorePatterns ?? defaultConfig.ignorePatterns,
        maxFileSizeKB: partialConfig.maxFileSizeKB ?? defaultConfig.maxFileSizeKB,
        parsedFileExtensions: partialConfig.parsedFileExtensions ?? defaultConfig.parsedFileExtensions,
        parseSubDirectories: partialConfig.parseSubDirectories ?? defaultConfig.parseSubDirectories,
        rootDirectory,
        schemaVersion: 1,
        useGitIgnoreForExcludes: partialConfig.useGitIgnoreForExcludes ?? defaultConfig.useGitIgnoreForExcludes
    };
}

/**
 * Process fusion programmatically without requiring a config file
 * @param options Options for fusion including partial config
 * @returns Fusion result with optional file contents
 * 
 * @example
 * ```typescript
 * import { fusionAPI } from 'project-fusion';
 * 
 * // Use with custom configuration
 * const result = await fusionAPI({
 *     rootDirectory: '/path/to/project',
 *     generateHtml: false,
 *     parsedFileExtensions: {
 *         web: ['.ts', '.tsx'],
 *         backend: ['.py']
 *     },
 *     ignorePatterns: ['tests/', '*.spec.ts']
 * });
 * ```
 */
export async function fusionAPI(options: ProgrammaticFusionOptions = {}): Promise<ProgrammaticFusionResult> {
    const cwd = options.cwd ?? process.cwd();
    
    // Extract fusion options
    const { 
        extensionGroups,
        rootDir,
        ...configOptions 
    } = options;
    
    // Build complete configuration
    const config = mergeWithDefaults(configOptions, cwd);
    
    // Override rootDirectory if rootDir is provided in fusion options
    if (rootDir) {
        config.rootDirectory = path.resolve(cwd, rootDir);
    }
    
    // Process fusion with the merged configuration
    const fusionOptions: FusionOptions = extensionGroups 
        ? { extensionGroups }
        : {};
    
    const result = await processFusion(config, fusionOptions);
    
    // Convert FusionResult to ProgrammaticFusionResult
    if (result.success) {
        return {
            fusionFilePath: result.fusionFilePath,
            logFilePath: result.logFilePath,
            message: result.message,
            success: true
        };
    } else {
        const errorResult: ProgrammaticFusionResult = {
            message: result.message,
            success: false
        };
        if (result.logFilePath) {
            errorResult.logFilePath = result.logFilePath;
        }
        if (result.error) {
            errorResult.error = result.error;
        }
        return errorResult;
    }
}

/**
 * Create a custom configuration object for programmatic use
 * @param overrides Configuration overrides
 * @returns Complete configuration object
 * 
 * @example
 * ```typescript
 * import { createConfig, processFusion } from 'project-fusion';
 * 
 * const config = createConfig({
 *     generateHtml: false,
 *     maxFileSizeKB: 2048
 * });
 * 
 * const result = await processFusion(config);
 * ```
 */
export function createConfig(overrides: Partial<Config> = {}): Config {
    return mergeWithDefaults(overrides, process.cwd());
}

/**
 * Programmatically run fusion with a specific configuration
 * Useful for VS Code extensions and other integrations
 * 
 * @param config Complete or partial configuration
 * @param options Additional fusion options
 * @returns Fusion result
 * 
 * @example
 * ```typescript
 * import { runFusion } from 'project-fusion';
 * 
 * // With partial config (uses defaults for missing values)
 * const result = await runFusion({
 *     rootDirectory: '/my/project',
 *     generateHtml: false
 * });
 * 
 * // With extension group filter
 * const result = await runFusion(
 *     { rootDirectory: '/my/project' },
 *     { extensionGroups: ['web', 'backend'] }
 * );
 * ```
 */
export async function runFusion(
    config: Partial<Config> | Config,
    options: FusionOptions = {}
): Promise<FusionResult> {
    // Check if config has all required fields
    const isCompleteConfig = (
        'schemaVersion' in config &&
        'rootDirectory' in config &&
        'parsedFileExtensions' in config
    );
    
    const fullConfig = isCompleteConfig 
        ? config as Config
        : mergeWithDefaults(config, config.rootDirectory ?? process.cwd());
    
    return await processFusion(fullConfig, options);
}

<!-- ============================================================ -->
<!-- FILE: src/benchmark.ts                                       -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Benchmark utilities for performance monitoring
 */
import process from 'node:process';

export interface BenchmarkMetrics {
    averageFileProcessingTime: number;
    duration: number;
    filesProcessed: number;
    memoryUsed: number;
    memoryUsedMB: number;
    processingTimeMs: number;
    throughputBytesPerSec: number;
    throughputMBps: number;
    totalBytesProcessed: number;
    totalSizeMB: number;
}

export class BenchmarkTracker {
    private readonly startTime: number;
    private readonly startMemory: NodeJS.MemoryUsage;
    private readonly fileTimings: number[] = [];
    private filesProcessed = 0;
    private totalBytes = 0;

    constructor() {
        this.startTime = Date.now();
        this.startMemory = process.memoryUsage();
    }

    /**
     * Record file processing metrics
     */
    markFileProcessed(sizeBytes: number, processingTimeMs?: number): void {
        this.filesProcessed++;
        this.totalBytes += sizeBytes;
        if (processingTimeMs !== undefined) {
            this.fileTimings.push(processingTimeMs);
        }
    }


    /**
     * Calculate and return performance metrics
     */
    getMetrics(): BenchmarkMetrics {
        const endTime = Date.now();
        const endMemory = process.memoryUsage();
        
        const processingTimeMs = endTime - this.startTime; // milliseconds
        const duration = processingTimeMs / 1000; // seconds
        const memoryUsed = (endMemory.heapUsed - this.startMemory.heapUsed) / (1024 * 1024); // MB
        const memoryUsedMB = endMemory.heapUsed / (1024 * 1024); // MB - current memory usage
        const totalSizeMB = this.totalBytes / (1024 * 1024);
        
        const averageFileProcessingTime = this.fileTimings.length > 0
            ? this.fileTimings.reduce((a, b) => a + b, 0) / this.fileTimings.length
            : 0;
        
        const throughputMBps = duration > 0 ? totalSizeMB / duration : 0;
        const throughputBytesPerSec = duration > 0 ? this.totalBytes / duration : 0;

        return {
            duration,
            memoryUsed,
            memoryUsedMB,
            processingTimeMs,
            filesProcessed: this.filesProcessed,
            totalBytesProcessed: this.totalBytes,
            totalSizeMB,
            averageFileProcessingTime,
            throughputMBps,
            throughputBytesPerSec
        };
    }


}

<!-- ============================================================ -->
<!-- FILE: src/cli.ts                                             -->
<!-- ============================================================ -->
#!/usr/bin/env node
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Command-line interface for Project Fusion
 */
import { Command } from 'commander';

import pkg from '../package.json' with { type: 'json' };

import {
    runConfigCheckCommand,
    runFusionCommand,
    runInitCommand
} from './clicommands.js';

const program = new Command();

program
    .name('project-fusion')
    .description('Project Fusion - Efficient project file management and sharing')
    .version(pkg.version, '-v, --version')
    .allowUnknownOption(false)
    .showHelpAfterError(true);

// Default command (fusion) - runs when no subcommand is specified
program
    .option('--extensions <groups>', 'Comma-separated list of extension groups (e.g., backend,web)')
    .option('--root <directory>', 'Root directory to start scanning from (defaults to current directory)')
    .action((options: { extensions?: string; root?: string }) => {
        // Default action is to run fusion
        void runFusionCommand(options);
    });


// Init command
program
    .command('init')
    .description('Initialize Project Fusion in the current directory')
    .option('--force', 'Force initialization even if configuration already exists')
    .action((options: { force?: boolean }) => {
        void runInitCommand(options);
    });

// Config check command
program
    .command('config-check')
    .description('Validate project-fusion.json and display active groups/extensions')
    .action(() => {
        void runConfigCheckCommand();
    });

// Parse arguments with Commander.js
program.parse(process.argv);

<!-- ============================================================ -->
<!-- FILE: src/clicommands.ts                                     -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * CLI commands implementation
 */
import path from 'node:path';

import chalk from 'chalk';
import clipboardy from 'clipboardy';
import fs from 'fs-extra';

import { processFusion } from './fusion.js';
import { ConfigSchemaV1 } from './schema.js';
import type { Config, FusionOptions } from './types.js';
import { defaultConfig, getExtensionsFromGroups, loadConfig } from './utils.js';

/**
 * Run the fusion command
 * @param options Command options
 */
export async function runFusionCommand(options: { extensions?: string, root?: string }): Promise<void> {
    try {
        console.log(chalk.blue('üîÑ Starting Fusion Process...'));

        const config = await loadConfig();

        if (options.root) {
            config.rootDirectory = options.root;
            console.log(chalk.yellow(`‚ÑπÔ∏è Using specified directory as root: ${options.root}`));
        }

        // Parse extension groups from command line (comma-separated)
        let extensionGroups: string[] | undefined;
        if (options.extensions) {
            extensionGroups = options.extensions.split(',').map(e => e.trim());
            console.log(chalk.blue(`Using extension groups: ${extensionGroups.join(', ')}`));
        }

        const fusionOptions: FusionOptions = extensionGroups ? { extensionGroups } : {};
        const result = await processFusion(config, fusionOptions);

        if (result.success) {
            console.log(chalk.green(`‚úÖ ${result.message}`));
            console.log(chalk.green(`üìÑ Generated files:`));
            
            if (config.generateText) {
                console.log(chalk.cyan(`   - ${config.generatedFileName}.txt`));
            }
            if (config.generateMarkdown) {
                console.log(chalk.cyan(`   - ${config.generatedFileName}.md`));
            }
            if (config.generateHtml) {
                console.log(chalk.cyan(`   - ${config.generatedFileName}.html`));
            }

            // Copy fusion content to clipboard if enabled (skip in CI/non-interactive environments)
            const isNonInteractive = process.env['CI'] === 'true' || !process.stdout.isTTY;
            if (config.copyToClipboard === true && result.fusionFilePath && !isNonInteractive) {
                try {
                    const fusionContent = await fs.readFile(result.fusionFilePath, 'utf8');
                    await clipboardy.write(fusionContent);
                    console.log(chalk.blue(`üìã Fusion content copied to clipboard`));
                } catch (clipboardError) {
                    console.warn(chalk.yellow(`‚ö†Ô∏è Could not copy to clipboard: ${String(clipboardError)}`));
                }
            } else if (config.copyToClipboard === true && isNonInteractive) {
                console.log(chalk.gray(`üìã Clipboard copy skipped (non-interactive environment)`));
            }

            console.log(chalk.gray(`üìù Log file available at: ${result.logFilePath}`));
        } else {
            console.log(chalk.red(`‚ùå ${result.message}`));
            if (result.logFilePath) {
                console.log(chalk.gray(`üìù Check log file for details: ${result.logFilePath}`));
            }
        }
    } catch (error) {
        console.error(chalk.red(`‚ùå Fusion process failed: ${String(error)}`));
        process.exit(1);
    }
}


/**
 * Run the init command to initialize the config
 */
export async function runInitCommand(options: { force?: boolean } = {}): Promise<void> {
    try {
        console.log(chalk.blue('üîÑ Initializing Project Fusion...'));

        const configPath = path.resolve('./project-fusion.json');
        if (await fs.pathExists(configPath)) {
            if (!options.force) {
                console.log(chalk.yellow('‚ö†Ô∏è project-fusion.json file already exists.'));
                console.log(chalk.yellow('Use --force to override or delete project-fusion.json and run init again.'));
                process.exit(1);
            } else {
                console.log(chalk.yellow('‚ö†Ô∏è Overriding existing configuration file with --force option.'));
            }
        }

        await fs.writeJson(configPath, defaultConfig, { spaces: 4 });

        console.log(chalk.green('‚úÖ Project Fusion initialized successfully!'));
        console.log(chalk.blue('üìÅ Created:'));
        console.log(chalk.cyan('  - ./project-fusion.json'));

        console.log(chalk.blue('\nüìù Next steps:'));
        console.log(chalk.cyan('  1. Review project-fusion.json and adjust as needed'));
        console.log(chalk.cyan('  2. Run fusion: project-fusion'));
    } catch (error) {
        console.error(chalk.red(`‚ùå Initialization failed: ${String(error)}`));
        process.exit(1);
    }
}

/**
 * Run the config-check command to validate configuration
 */
export async function runConfigCheckCommand(): Promise<void> {
    try {
        console.log(chalk.blue('üîç Checking Project Fusion Configuration...'));

        const configPath = path.resolve('./project-fusion.json');
        
        // Verify configuration file exists
        if (!await fs.pathExists(configPath)) {
            console.log(chalk.yellow('‚ö†Ô∏è No project-fusion.json found.'));
            console.log(chalk.cyan('   Using default configuration.'));
            console.log(chalk.gray('   Run "project-fusion init" to create a configuration file.'));
            
            await displayConfigInfo(defaultConfig, true);
            return;
        }

        // Load and parse configuration
        let configContent: string;
        try {
            configContent = await fs.readFile(configPath, 'utf8');
        } catch (error) {
            console.log(chalk.red(`‚ùå Cannot read configuration file: ${String(error)}`));
            process.exit(1);
        }

        let parsedConfig: unknown;
        try {
            parsedConfig = JSON.parse(configContent);
        } catch (error) {
            console.log(chalk.red(`‚ùå Invalid JSON in configuration file: ${String(error)}`));
            process.exit(1);
        }

        // Validate configuration against schema
        const validation = ConfigSchemaV1.safeParse(parsedConfig);
        
        if (!validation.success) {
            console.log(chalk.red('‚ùå Configuration validation failed:'));
            
            // Show detailed validation errors
            // Display detailed validation errors with helpful context
            for (const [index, issue] of validation.error.issues.entries()) {
                const path = issue.path.length > 0 ? issue.path.join('.') : 'root';
                 
                const value = issue.path.reduce((obj: unknown, key) => {
                    if (typeof key === 'string' && obj && typeof obj === 'object') {
                        return (obj as Record<string, unknown>)[key];
                    }
                    return undefined;
                }, parsedConfig);
                console.log(chalk.red(`   ${index + 1}. Path: ${chalk.yellow(path)}`));
                console.log(chalk.red(`      Error: ${issue.message}`));
                console.log(chalk.red(`      Current value: ${chalk.cyan(JSON.stringify(value))}`));
                if (issue.code === 'invalid_type') {
                     
                    console.log(chalk.red(`      Expected: ${chalk.green(String((issue as unknown as Record<string, unknown>)['expected']))}, received: ${chalk.magenta(String((issue as unknown as Record<string, unknown>)['received']))}`));
                }
            }
            
            console.log(chalk.yellow('\nüí° Suggestions:'));
            console.log(chalk.cyan('   - Check your configuration against the schema'));
            console.log(chalk.cyan('   - Run "project-fusion init --force" to reset to default config'));
            process.exit(1);
        }

        console.log(chalk.green('‚úÖ Configuration is valid!'));
        await displayConfigInfo(validation.data, false);

    } catch (error) {
        console.error(chalk.red(`‚ùå Config check failed: ${String(error)}`));
        process.exit(1);
    }
}

/**
 * Display comprehensive configuration summary with preview
 */
async function displayConfigInfo(config: Config, isDefault: boolean): Promise<void> {
    console.log(chalk.blue('\nüìã Configuration Summary:'));
    
    if (isDefault) {
        console.log(chalk.gray('   (Using default configuration)\n'));
    } else {
        console.log('');
    }

    // Core configuration settings
    console.log(chalk.cyan('üîß Basic Settings:'));
    console.log(`   Schema Version: ${config.schemaVersion}`);
    console.log(`   Root Directory: ${config.rootDirectory}`);
    console.log(`   Scan Subdirectories: ${config.parseSubDirectories ? 'Yes' : 'No'}`);
    console.log(`   Use .gitignore: ${config.useGitIgnoreForExcludes ? 'Yes' : 'No'}`);
    console.log(`   Copy to Clipboard: ${config.copyToClipboard ? 'Yes' : 'No'}`);
    console.log(`   Max File Size: ${config.maxFileSizeKB} KB`);

    // File generation options
    console.log(chalk.cyan('\nüìÑ Output Generation:'));
    console.log(`   Generated File Name: ${config.generatedFileName}`);
    console.log(`   Generate Text: ${config.generateText ? 'Yes' : 'No'}`);
    console.log(`   Generate Markdown: ${config.generateMarkdown ? 'Yes' : 'No'}`);
    console.log(`   Generate HTML: ${config.generateHtml ? 'Yes' : 'No'}`);
    console.log(`   Log File: project-fusion.log`);

    // File type configuration
    console.log(chalk.cyan('\nüìÅ File Extension Groups:'));
    const totalExtensions = getExtensionsFromGroups(config);
    
    for (const [group, extensions] of Object.entries(config.parsedFileExtensions)) {
        if (extensions) {
            console.log(`   ${group}: ${extensions.length} extensions (${extensions.join(', ')})`);
        }
    }
    
    console.log(chalk.gray(`   Total: ${totalExtensions.length} unique extensions`));

    // Pattern exclusions
    console.log(chalk.cyan('\nüö´ Ignore Patterns:'));
    if (config.ignorePatterns.length === 0) {
        console.log('   None defined');
    } else {
        for (const pattern of config.ignorePatterns.slice(0, 10)) {
            console.log(`   ${pattern}`);
        }
        if (config.ignorePatterns.length > 10) {
            console.log(chalk.gray(`   ... and ${config.ignorePatterns.length - 10} more`));
        }
    }

    // Preview matching files using current configuration
    console.log(chalk.cyan('\nüîç File Discovery Preview:'));
    try {
        const { glob } = await import('glob');
        const rootDir = path.resolve(config.rootDirectory);
        
        // Create glob pattern to preview file discovery
        const allExtensionsPattern = totalExtensions.map(ext => ext.startsWith('.') ? ext : `.${ext}`);
        const pattern = config.parseSubDirectories
            ? `${rootDir}/**/*@(${allExtensionsPattern.join('|')})` // Recursive search
            : `${rootDir}/*@(${allExtensionsPattern.join('|')})`; // Root-only search

        const filePaths = await glob(pattern, { 
            nodir: true,
            follow: false
        });

        console.log(`   Pattern: ${pattern}`);
        console.log(`   Files found: ${filePaths.length}`);
        
        if (filePaths.length > 0) {
            console.log(`   Sample files:`);
            for (const file of filePaths.slice(0, 5)) {
                const relativePath = path.relative(rootDir, file);
                console.log(`     ${relativePath}`);
            }
            if (filePaths.length > 5) {
                console.log(chalk.gray(`     ... and ${filePaths.length - 5} more`));
            }
        }
    } catch (error) {
        console.log(chalk.yellow(`   Could not preview files: ${String(error)}`));
    }
}

<!-- ============================================================ -->
<!-- FILE: src/fluent.ts                                          -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Fluent API for Project Fusion
 * Provides a chainable interface for better developer experience
 */
import { fusionAPI, type ProgrammaticFusionOptions, type ProgrammaticFusionResult } from './api.js';
import type { Config } from './types.js';
import { defaultConfig } from './utils.js';

/**
 * Fluent API builder for Project Fusion
 * 
 * @example
 * ```typescript
 * import { projectFusion } from 'project-fusion';
 * 
 * const result = await projectFusion()
 *   .include(['web', 'backend'])
 *   .exclude(['*.test.ts', 'node_modules'])
 *   .maxSize('2MB')
 *   .output(['md', 'html'])
 *   .generate();
 * ```
 */
export class ProjectFusionBuilder {
    private options: ProgrammaticFusionOptions = {};

    /**
     * Set the root directory to scan
     * @param path Root directory path
     */
    root(path: string): this {
        this.options.rootDirectory = path;
        return this;
    }

    /**
     * Set the working directory
     * @param path Working directory path
     */
    cwd(path: string): this {
        this.options.cwd = path;
        return this;
    }

    /**
     * Include specific extension groups
     * @param groups Array of extension group names (e.g., ['web', 'backend'])
     */
    include(groups: string[]): this {
        this.options.extensionGroups = groups;
        return this;
    }

    /**
     * Add ignore patterns
     * @param patterns Array of glob patterns to ignore
     */
    exclude(patterns: string[]): this {
        this.options.ignorePatterns = patterns;
        return this;
    }

    /**
     * Set maximum file size limit
     * @param size Size limit as string (e.g., '1MB', '512KB') or number in KB
     */
    maxSize(size: string | number): this {
        if (typeof size === 'string') {
            const match = size.match(/^(\d+(?:\.\d+)?)\s*(KB|MB|GB)?$/i);
            if (!match) {
                throw new Error(`Invalid size format: ${size}. Use format like "1MB", "512KB", or number in KB`);
            }
            
            const value = parseFloat(match[1] || '0');
            const unit = (match[2] || 'KB').toUpperCase();
            
            const multipliers = { KB: 1, MB: 1024, GB: 1024 * 1024 };
            this.options.maxFileSizeKB = value * (multipliers[unit as keyof typeof multipliers] || 1);
        } else {
            this.options.maxFileSizeKB = size;
        }
        return this;
    }

    /**
     * Set output formats to generate
     * @param formats Array of format names ('text', 'md', 'html')
     */
    output(formats: Array<'text' | 'md' | 'html'>): this {
        this.options.generateText = formats.includes('text');
        this.options.generateMarkdown = formats.includes('md');
        this.options.generateHtml = formats.includes('html');
        return this;
    }

    /**
     * Set the generated file name (without extension)
     * @param name Base name for generated files
     */
    name(name: string): this {
        this.options.generatedFileName = name;
        return this;
    }

    /**
     * Enable or disable subdirectory parsing
     * @param enabled Whether to parse subdirectories
     */
    subdirectories(enabled: boolean = true): this {
        this.options.parseSubDirectories = enabled;
        return this;
    }

    /**
     * Enable or disable clipboard copying
     * @param enabled Whether to copy result to clipboard
     */
    clipboard(enabled: boolean = true): this {
        this.options.copyToClipboard = enabled;
        return this;
    }

    /**
     * Enable or disable .gitignore usage
     * @param enabled Whether to use .gitignore for exclusions
     */
    gitignore(enabled: boolean = true): this {
        this.options.useGitIgnoreForExcludes = enabled;
        return this;
    }

    /**
     * Add custom file extensions for a specific group
     * @param group Extension group name (e.g., 'web', 'backend')
     * @param extensions Array of extensions (e.g., ['.ts', '.tsx'])
     */
    extensions(group: string, extensions: string[]): this {
        if (!this.options.parsedFileExtensions) {
            this.options.parsedFileExtensions = { ...defaultConfig.parsedFileExtensions };
        }
        this.options.parsedFileExtensions[group] = extensions;
        return this;
    }

    /**
     * Set complete extension configuration
     * @param config Extension configuration object
     */
    allExtensions(config: Config['parsedFileExtensions']): this {
        this.options.parsedFileExtensions = config;
        return this;
    }

    /**
     * Apply a custom configuration function
     * @param configFn Function that receives and modifies options
     */
    configure(configFn: (options: ProgrammaticFusionOptions) => void): this {
        configFn(this.options);
        return this;
    }

    /**
     * Generate fusion files with the configured options
     * @returns Promise resolving to fusion result
     */
    async generate(): Promise<ProgrammaticFusionResult> {
        return await fusionAPI(this.options);
    }

    /**
     * Get the current configuration without generating
     * @returns Current configuration options
     */
    getConfig(): ProgrammaticFusionOptions {
        return { ...this.options };
    }

    /**
     * Reset the builder to default state
     */
    reset(): this {
        this.options = {};
        return this;
    }
}

/**
 * Create a new Project Fusion builder instance
 * 
 * @example
 * ```typescript
 * import { projectFusion } from 'project-fusion';
 * 
 * // Basic usage
 * const result = await projectFusion()
 *   .include(['web'])
 *   .generate();
 * 
 * // Advanced configuration
 * const result = await projectFusion()
 *   .root('./src')
 *   .include(['web', 'backend'])
 *   .exclude(['*.test.ts', 'node_modules/', '__tests__/'])
 *   .maxSize('2MB')
 *   .output(['md', 'html'])
 *   .name('my-project-fusion')
 *   .clipboard(false)
 *   .generate();
 * ```
 */
export function projectFusion(): ProjectFusionBuilder {
    return new ProjectFusionBuilder();
}

<!-- ============================================================ -->
<!-- FILE: src/fusion.ts                                          -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Fusion functionality - Refactored with new architecture patterns
 */
import path from 'node:path';

import ignoreLib from 'ignore';

import { type FileSystemAdapter, DefaultFileSystemAdapter } from './adapters/file-system.js';
import { BenchmarkTracker } from './benchmark.js';
import { PluginManager } from './plugins/plugin-system.js';
import { 
    type FileInfo, 
    type OutputContext,
    OutputStrategyManager
} from './strategies/output-strategy.js';
import { type Config, type FilePath, type FusionOptions, type FusionResult, createFilePath } from './types.js';
import {
    formatLocalTimestamp,
    formatTimestamp,
    getExtensionsFromGroups,
    isBinaryFile,
    validateNoSymlinks,
    validateSecurePath,
    writeLog
} from './utils.js';

export async function processFusion(
    config: Config,
    options: FusionOptions = {}
): Promise<FusionResult> {
    const benchmark = new BenchmarkTracker();
    const fs = options.fs || new DefaultFileSystemAdapter();
    const outputManager = new OutputStrategyManager();
    const pluginManager = new PluginManager(fs);

    try {
        const logFilePath = createFilePath(path.resolve(config.rootDirectory, `${config.generatedFileName}.log`));
        const startTime = new Date();

        await fs.writeFile(logFilePath, '');

        if (options.pluginsDir) {
            await pluginManager.loadPluginsFromDirectory(options.pluginsDir);
        }

        if (options.enabledPlugins) {
            for (const pluginName of options.enabledPlugins) {
                pluginManager.configurePlugin(pluginName, { name: pluginName, enabled: true });
            }
        }

        await pluginManager.initializePlugins(config);

        const additionalStrategies = pluginManager.getAdditionalOutputStrategies();
        for (const strategy of additionalStrategies) {
            outputManager.registerStrategy(strategy);
        }

        const additionalExtensions = pluginManager.getAdditionalFileExtensions();
        const mergedConfig = {
            ...config,
            parsedFileExtensions: {
                ...config.parsedFileExtensions,
                ...additionalExtensions
            }
        };

        const extensions = getExtensionsFromGroups(mergedConfig, options.extensionGroups);
        console.log(`Processing ${extensions.length} file extensions from ${Object.keys(mergedConfig.parsedFileExtensions).length} categories`);
        
        if (extensions.length === 0) {
            const message = 'No file extensions to process.';
            await writeLog(logFilePath, `Status: Fusion failed\nReason: ${message}`, true);
            return { success: false, message, logFilePath };
        }

        const ig = ignoreLib();
        const rootDir = path.resolve(config.rootDirectory);

        if (config.useGitIgnoreForExcludes) {
            const gitIgnorePath = path.join(rootDir, '.gitignore');
            if (await fs.exists(createFilePath(gitIgnorePath))) {
                const gitIgnoreContent = await fs.readFile(createFilePath(gitIgnorePath));
                ig.add(gitIgnoreContent);
            }
        }

        if (config.ignorePatterns.length > 0) {
            const patterns = config.ignorePatterns
                .filter(pattern => pattern.trim() !== '' && !pattern.startsWith('#'))
                .join('\n');
            ig.add(patterns);
        }

        const allExtensionsPattern = extensions.map(ext => ext.startsWith('.') ? ext : `.${ext}`);
        const pattern = config.parseSubDirectories
            ? `${rootDir}/**/*@(${allExtensionsPattern.join('|')})`
            : `${rootDir}/*@(${allExtensionsPattern.join('|')})`;

        let filePaths = await fs.glob(pattern, { 
            nodir: true,
            follow: false
        });

        const originalFileCount = filePaths.length;
        filePaths = filePaths.filter(file => {
            const relativePath = path.relative(rootDir, file);
            return !ig.ignores(relativePath);
        });

        console.log(`Found ${originalFileCount} files, ${filePaths.length} after filtering (${((originalFileCount - filePaths.length) / originalFileCount * 100).toFixed(1)}% filtered)`);

        if (filePaths.length === 0) {
            const message = 'No files found to process.';
            const endTime = new Date();
            await writeLog(logFilePath, `Status: Fusion failed\nReason: ${message}\nStart time: ${formatTimestamp(startTime)}\nEnd time: ${formatTimestamp(endTime)}\nDuration: ${((endTime.getTime() - startTime.getTime()) / 1000).toFixed(2)}s`, true);
            return { success: false, message, logFilePath };
        }

        const projectName = path.basename(process.cwd());
        let packageName = "";
        let projectVersion = "";
        const packageJsonPath = path.join(process.cwd(), 'package.json');
        if (await fs.exists(createFilePath(packageJsonPath))) {
            try {
                const packageJsonContent = await fs.readFile(createFilePath(packageJsonPath));
                const packageJson = JSON.parse(packageJsonContent) as Record<string, unknown>;
                if (typeof packageJson['name'] === 'string') {
                    packageName = packageJson['name'];
                }
                if (typeof packageJson['version'] === 'string') {
                    projectVersion = packageJson['version'];
                }
            } catch (error) {
                console.warn('Error reading package.json:', error);
            }
        }

        filePaths.sort((a, b) => path.relative(rootDir, a).localeCompare(path.relative(rootDir, b)));

        const maxFileSizeKB = config.maxFileSizeKB;
        const filesToProcess: FileInfo[] = [];
        const skippedFiles: string[] = [];
        let skippedCount = 0;
        let totalSizeBytes = 0;

        for (const filePath of filePaths) {
            const relativePath = path.relative(rootDir, filePath);

            try {
                const stats = await fs.stat(filePath);
                const sizeKB = stats.size / 1024;
                totalSizeBytes += stats.size;

                if (sizeKB > maxFileSizeKB) {
                    skippedCount++;
                    skippedFiles.push(relativePath);
                    await writeLog(logFilePath, `Skipped large file: ${relativePath} (${sizeKB.toFixed(2)} KB)`, true);
                } else {
                    const safePath = validateSecurePath(filePath, config.rootDirectory);
                    await validateNoSymlinks(createFilePath(safePath), false);
                    
                    if (await isBinaryFile(safePath)) {
                        await writeLog(logFilePath, `Skipping binary file: ${relativePath}`, true);
                        console.warn(`Skipping binary file: ${relativePath}`);
                        continue;
                    }
                    
                    const content = await fs.readFile(createFilePath(safePath));
                    
                    let fileInfo: FileInfo = {
                        content,
                        relativePath,
                        path: filePath,
                        size: stats.size
                    };

                    fileInfo = await pluginManager.executeBeforeFileProcessing(fileInfo, config) || fileInfo;
                    
                    if (fileInfo) {
                        filesToProcess.push(fileInfo);
                    }
                }
            } catch (error) {
                await writeLog(logFilePath, `Error checking file ${filePath}: ${String(error)}`, true);
                console.error(`Error checking file ${filePath}:`, error);
            }
        }

        const beforeFusionResult = await pluginManager.executeBeforeFusion(mergedConfig, filesToProcess);
        const finalConfig = beforeFusionResult.config;
        const finalFilesToProcess = beforeFusionResult.filesToProcess;

        const projectTitle = packageName && packageName.toLowerCase() !== projectName.toLowerCase() 
            ? `${projectName} / ${packageName}` 
            : projectName;
        const versionInfo = projectVersion ? ` v${projectVersion}` : '';

        const outputContext: OutputContext = {
            projectTitle,
            versionInfo,
            filesToProcess: finalFilesToProcess,
            config: finalConfig
        };

        const enabledStrategies = outputManager.getEnabledStrategies(finalConfig);
        const generatedPaths: FilePath[] = [];

        for (const strategy of enabledStrategies) {
            try {
                const outputPath = await outputManager.generateOutput(strategy, outputContext, fs);
                generatedPaths.push(outputPath);
                benchmark.markFileProcessed(0);
            } catch (error) {
                await writeLog(logFilePath, `Error generating ${strategy.name} output: ${String(error)}`, true);
                console.error(`Error generating ${strategy.name} output:`, error);
            }
        }

        const message = `Fusion completed successfully. ${finalFilesToProcess.length} files processed${skippedCount > 0 ? `, ${skippedCount} skipped` : ''}.`;
        const endTime = new Date();
        const duration = ((endTime.getTime() - startTime.getTime()) / 1000).toFixed(2);
        const totalSizeMB = (totalSizeBytes / (1024 * 1024)).toFixed(2);
        
        await writeLog(logFilePath, `Status: Fusion completed successfully`, true);
        await writeLog(logFilePath, `Start time: ${formatTimestamp(startTime)}`, true);
        await writeLog(logFilePath, `End time: ${formatTimestamp(endTime)}`, true);
        await writeLog(logFilePath, `Duration: ${duration}s`, true);
        await writeLog(logFilePath, `Total data processed: ${totalSizeMB} MB`, true);
        
        const metrics = benchmark.getMetrics();
        await writeLog(logFilePath, `\nPerformance Metrics:`, true);
        await writeLog(logFilePath, `  Memory Used: ${metrics.memoryUsed.toFixed(2)} MB`, true);
        await writeLog(logFilePath, `  Throughput: ${metrics.throughputMBps.toFixed(2)} MB/s`, true);
        await writeLog(logFilePath, `  Files/second: ${(metrics.filesProcessed / metrics.duration).toFixed(2)}`, true);
        
        await writeLog(logFilePath, `Files found: ${originalFileCount}`, true);
        await writeLog(logFilePath, `Files processed successfully: ${finalFilesToProcess.length}`, true);
        await writeLog(logFilePath, `Files skipped (too large): ${skippedCount}`, true);
        await writeLog(logFilePath, `Files filtered out: ${originalFileCount - filePaths.length}`, true);
        
        const generatedFormats = enabledStrategies.map(s => s.extension);
        
        const result = {
            success: true as const,
            message: `${message} Generated formats: ${generatedFormats.join(', ')}.`,
            fusionFilePath: generatedPaths[0] || logFilePath,
            logFilePath
        };

        const finalResult = await pluginManager.executeAfterFusion(result, finalConfig);
        
        await pluginManager.cleanupPlugins();
        
        return finalResult;

    } catch (error) {
        const errorMessage = `Fusion process failed: ${String(error)}`;
        console.error(errorMessage);

        try {
            await pluginManager.cleanupPlugins();
        } catch (cleanupError) {
            console.error('Error during plugin cleanup:', cleanupError);
        }

        try {
            let logFilePath: FilePath;
            try {
                logFilePath = createFilePath(path.resolve(config.rootDirectory, `${config.generatedFileName}.log`));
                const endTime = new Date();
                await writeLog(logFilePath, `Status: Fusion failed due to error\nError details: ${errorMessage}\nEnd time: ${formatTimestamp(endTime)}`, true);
            } catch {
                logFilePath = createFilePath(path.resolve(`${config.generatedFileName}.log`));
                const endTime = new Date();
                await writeLog(logFilePath, `Status: Fusion failed due to error\nError details: ${errorMessage}\nEnd time: ${formatTimestamp(endTime)}`, true);
            }

            return {
                success: false,
                message: errorMessage,
                logFilePath,
                error: error as Error
            };
        } catch (logError) {
            console.error('Could not write to log file:', logError);
            return {
                success: false,
                message: errorMessage,
                error: error as Error
            };
        }
    }
}

<!-- ============================================================ -->
<!-- FILE: src/index.ts                                           -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Entry point for Project Fusion
 */

// Architecture exports (alphabetical)
export { DefaultFileSystemAdapter, MemoryFileSystemAdapter } from './adapters/file-system.js';
export type { FileSystemAdapter } from './adapters/file-system.js';
export { PluginManager, BasePlugin, createPlugin } from './plugins/plugin-system.js';
export type { Plugin, PluginHooks, PluginMetadata } from './plugins/plugin-system.js';
export { 
    OutputStrategyManager, 
    TextOutputStrategy, 
    MarkdownOutputStrategy, 
    HtmlOutputStrategy 
} from './strategies/output-strategy.js';
export type { OutputStrategy, OutputContext } from './strategies/output-strategy.js';

// Core API (alphabetical)
export { 
    createConfig,
    fusionAPI,
    runFusion,
    type ProgrammaticFusionOptions,
    type ProgrammaticFusionResult 
} from './api.js';
export { BenchmarkTracker, type BenchmarkMetrics } from './benchmark.js';
export { 
    projectFusion,
    ProjectFusionBuilder 
} from './fluent.js';
export { processFusion } from './fusion.js';

// Schemas and types (alphabetical)
export * from './schema.js';
export * from './types.js';
export * from './utils.js';


<!-- ============================================================ -->
<!-- FILE: src/plugins/plugin-system.ts                           -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Plugin system for extending Project Fusion functionality
 */
import path from 'node:path';
import type { FileSystemAdapter } from '../adapters/file-system.js';
import type { FileInfo, OutputStrategy } from '../strategies/output-strategy.js';
import { type Config, createFilePath } from '../types.js';

export interface PluginMetadata {
    name: string;
    version: string;
    description: string;
    author?: string;
    homepage?: string;
}

export interface PluginHooks {
    beforeFileProcessing?(fileInfo: FileInfo, config: Config): Promise<FileInfo | null>;
    afterFileProcessing?(fileInfo: FileInfo, processedContent: string, config: Config): Promise<string>;
    beforeFusion?(config: Config, filesToProcess: FileInfo[]): Promise<{ config: Config; filesToProcess: FileInfo[] }>;
    afterFusion?(result: unknown, config: Config): Promise<unknown>;
    registerOutputStrategies?(): OutputStrategy[];
    registerFileExtensions?(): Record<string, string[]>;
}

export interface Plugin extends PluginHooks {
    metadata: PluginMetadata;
    initialize?(config: Config): Promise<void>;
    cleanup?(): Promise<void>;
}

export interface PluginConfig {
    name: string;
    enabled: boolean;
    options?: Record<string, unknown>;
}

export class PluginManager {
    private readonly plugins: Map<string, Plugin> = new Map();
    private readonly pluginConfigs: Map<string, PluginConfig> = new Map();
    private readonly fs: FileSystemAdapter;

    constructor(fs: FileSystemAdapter) {
        this.fs = fs;
    }

    async loadPlugin(pluginPath: string): Promise<void> {
        try {
            const pluginModule = await import(pluginPath) as { default?: Plugin; plugin?: Plugin };
            const plugin: Plugin = pluginModule.default ?? pluginModule.plugin ?? pluginModule as Plugin;
            
            if (!plugin.metadata) {
                throw new Error(`Plugin at ${pluginPath} is missing metadata`);
            }
            
            this.plugins.set(plugin.metadata.name, plugin);
            console.log(`Loaded plugin: ${plugin.metadata.name} v${plugin.metadata.version}`);
        } catch (error) {
            console.error(`Failed to load plugin from ${pluginPath}:`, error);
            throw error;
        }
    }

    async loadPluginsFromDirectory(pluginsDir: string): Promise<void> {
        try {
            if (!(await this.fs.exists(createFilePath(pluginsDir)))) {
                return;
            }

            const pluginFiles = await this.fs.glob(path.join(pluginsDir, '**/*.js'));
            
            for (const pluginFile of pluginFiles) {
                try {
                    await this.loadPlugin(pluginFile);
                } catch (error) {
                    console.warn(`Skipping plugin ${pluginFile} due to error:`, error);
                }
            }
        } catch (error) {
            console.error(`Error loading plugins from directory ${pluginsDir}:`, error);
        }
    }

    registerPlugin(plugin: Plugin): void {
        this.plugins.set(plugin.metadata.name, plugin);
    }

    unregisterPlugin(name: string): void {
        this.plugins.delete(name);
        this.pluginConfigs.delete(name);
    }

    configurePlugin(name: string, config: PluginConfig): void {
        this.pluginConfigs.set(name, config);
    }

    getPlugin(name: string): Plugin | undefined {
        return this.plugins.get(name);
    }

    getEnabledPlugins(): Plugin[] {
        return [...this.plugins.values()].filter(plugin => {
            const config = this.pluginConfigs.get(plugin.metadata.name);
            return config?.enabled !== false;
        });
    }

    async initializePlugins(config: Config): Promise<void> {
        const enabledPlugins = this.getEnabledPlugins();
        
        for (const plugin of enabledPlugins) {
            try {
                if (plugin.initialize) {
                    await plugin.initialize(config);
                }
            } catch (error) {
                console.error(`Error initializing plugin ${plugin.metadata.name}:`, error);
            }
        }
    }

    async cleanupPlugins(): Promise<void> {
        const enabledPlugins = this.getEnabledPlugins();
        
        for (const plugin of enabledPlugins) {
            try {
                if (plugin.cleanup) {
                    await plugin.cleanup();
                }
            } catch (error) {
                console.error(`Error cleaning up plugin ${plugin.metadata.name}:`, error);
            }
        }
    }

    async executeBeforeFileProcessing(fileInfo: FileInfo, config: Config): Promise<FileInfo | null> {
        let currentFileInfo = fileInfo;
        
        for (const plugin of this.getEnabledPlugins()) {
            if (plugin.beforeFileProcessing) {
                try {
                    const result = await plugin.beforeFileProcessing(currentFileInfo, config);
                    if (result === null) {
                        return null;
                    }
                    currentFileInfo = result;
                } catch (error) {
                    console.error(`Error in plugin ${plugin.metadata.name} beforeFileProcessing:`, error);
                }
            }
        }
        
        return currentFileInfo;
    }

    async executeAfterFileProcessing(
        fileInfo: FileInfo, 
        processedContent: string, 
        config: Config
    ): Promise<string> {
        let currentContent = processedContent;
        
        for (const plugin of this.getEnabledPlugins()) {
            if (plugin.afterFileProcessing) {
                try {
                    currentContent = await plugin.afterFileProcessing(fileInfo, currentContent, config);
                } catch (error) {
                    console.error(`Error in plugin ${plugin.metadata.name} afterFileProcessing:`, error);
                }
            }
        }
        
        return currentContent;
    }

    async executeBeforeFusion(
        config: Config, 
        filesToProcess: FileInfo[]
    ): Promise<{ config: Config; filesToProcess: FileInfo[] }> {
        let currentConfig = config;
        let currentFiles = filesToProcess;
        
        for (const plugin of this.getEnabledPlugins()) {
            if (plugin.beforeFusion) {
                try {
                    const result = await plugin.beforeFusion(currentConfig, currentFiles);
                    currentConfig = result.config;
                    currentFiles = result.filesToProcess;
                } catch (error) {
                    console.error(`Error in plugin ${plugin.metadata.name} beforeFusion:`, error);
                }
            }
        }
        
        return { config: currentConfig, filesToProcess: currentFiles };
    }

    async executeAfterFusion<T>(result: T, config: Config): Promise<T> {
        let currentResult = result;
        
        for (const plugin of this.getEnabledPlugins()) {
            if (plugin.afterFusion) {
                try {
                    currentResult = await plugin.afterFusion(currentResult, config) as T;
                } catch (error) {
                    console.error(`Error in plugin ${plugin.metadata.name} afterFusion:`, error);
                }
            }
        }
        
        return currentResult;
    }

    getAdditionalOutputStrategies(): OutputStrategy[] {
        const strategies: OutputStrategy[] = [];
        
        for (const plugin of this.getEnabledPlugins()) {
            if (plugin.registerOutputStrategies) {
                try {
                    const pluginStrategies = plugin.registerOutputStrategies();
                    strategies.push(...pluginStrategies);
                } catch (error) {
                    console.error(`Error getting output strategies from plugin ${plugin.metadata.name}:`, error);
                }
            }
        }
        
        return strategies;
    }

    getAdditionalFileExtensions(): Record<string, string[]> {
        const extensions: Record<string, string[]> = {};
        
        for (const plugin of this.getEnabledPlugins()) {
            if (plugin.registerFileExtensions) {
                try {
                    const pluginExtensions = plugin.registerFileExtensions();
                    Object.assign(extensions, pluginExtensions);
                } catch (error) {
                    console.error(`Error getting file extensions from plugin ${plugin.metadata.name}:`, error);
                }
            }
        }
        
        return extensions;
    }

    listPlugins(): PluginMetadata[] {
        return [...this.plugins.values()].map(plugin => plugin.metadata);
    }
}

export abstract class BasePlugin implements Plugin {
    abstract metadata: PluginMetadata;

    async initialize?(): Promise<void> {
        // Default implementation - can be overridden
    }

    async cleanup?(): Promise<void> {
        // Default implementation - can be overridden
    }
}

export function createPlugin(metadata: PluginMetadata, hooks: PluginHooks = {}): Plugin {
    return {
        metadata,
        ...hooks
    };
}

<!-- ============================================================ -->
<!-- FILE: src/schema.ts                                          -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Configuration schema definitions for Project Fusion
 */
import { z } from 'zod';

/**
 * File extension groups with support for custom categories
 */
const ParsedFileExtensionsSchema = z.object({
    backend: z.array(z.string()).default([".cs", ".go", ".java", ".php", ".py", ".rb", ".rs"]),
    config: z.array(z.string()).default([".json", ".toml", ".xml", ".yaml", ".yml"]),
    cpp: z.array(z.string()).default([".c", ".cc", ".cpp", ".h", ".hpp"]),
    doc: z.array(z.string()).default([".adoc", ".md", ".rst"]),
    godot: z.array(z.string()).default([".cfg", ".cs", ".gd", ".import", ".tscn", ".tres"]),
    scripts: z.array(z.string()).default([".bat", ".cmd", ".ps1", ".sh"]),
    web: z.array(z.string()).default([".css", ".html", ".js", ".jsx", ".svelte", ".ts", ".tsx", ".vue"]),
}).and(z.record(z.string(), z.array(z.string())));

/**
 * Complete configuration schema for version 1
 */
export const ConfigSchemaV1 = z.object({
    copyToClipboard: z.boolean().default(false),
    generatedFileName: z.string().default("project-fusioned"),
    generateHtml: z.boolean().default(true),
    generateMarkdown: z.boolean().default(true),
    generateText: z.boolean().default(true),
    maxFileSizeKB: z.number().default(1024),
    parseSubDirectories: z.boolean().default(true),
    parsedFileExtensions: ParsedFileExtensionsSchema.default({
        backend: [".cs", ".go", ".java", ".php", ".py", ".rb", ".rs"],
        config: [".json", ".toml", ".xml", ".yaml", ".yml"],
        cpp: [".c", ".cc", ".cpp", ".h", ".hpp"],
        doc: [".adoc", ".md", ".rst"],
        godot: [".cfg", ".cs", ".gd", ".import", ".tscn", ".tres"],
        scripts: [".bat", ".cmd", ".ps1", ".sh"],
        web: [".css", ".html", ".js", ".jsx", ".svelte", ".ts", ".tsx", ".vue"]
    }),
    ignorePatterns: z.array(z.string()).default([
        "project-fusion.json",
        "project-fusion.log",
        "project-fusioned.*",
        "node_modules/",
        "package-lock.json",
        "pnpm-lock.yaml",
        "yarn.lock",
        "dist/",
        "build/",
        "*.min.js",
        "*.min.css",
        ".env",
        ".env.*",
        "*.key",
        "*.pem",
        "**/credentials/*",
        "**/secrets/*",
        "*.log",
        "logs/",
        ".DS_Store",
        "Thumbs.db",
        ".vscode/",
        ".idea/",
        "*.swp",
        "*.swo",
        "*.zip",
        "*.tar",
        "*.tgz",
        "*.gz",
        "*.7z",
        "*.rar",
        "*.png",
        "*.jpg",
        "*.jpeg",
        "*.gif",
        "*.bmp",
        "*.ico",
        "*.svg",
        "*.webp",
        "*.pdf",
        "*.doc",
        "*.docx",
        "*.xls",
        "*.xlsx",
        "*.ppt",
        "*.pptx",
        "*.mp3",
        "*.mp4",
        "*.avi",
        "*.mov",
        "*.wmv",
        "*.flv",
        "*.wav",
        "*.flac",
        "*.unitypackage",
        "*.uasset",
        "*.fbx",
        "*.obj",
        "*.blend",
        "*.exe",
        "*.dll",
        "*.so",
        "*.dylib",
        "*.a",
        "*.o",
        "*.pyc",
        "*.pyo",
        "*.class",
        "*.jar",
        "*.war"
    ]),
    rootDirectory: z.string().default("."),
    schemaVersion: z.literal(1).default(1),
    useGitIgnoreForExcludes: z.boolean().default(true),
});

<!-- ============================================================ -->
<!-- FILE: src/strategies/output-strategy.ts                      -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Output strategy pattern for different fusion formats
 */
import { WriteStream, createWriteStream } from 'node:fs';
import path from 'node:path';
import type { FileSystemAdapter } from '../adapters/file-system.js';
import { type Config, type FilePath, createFilePath } from '../types.js';
import { formatLocalTimestamp, formatTimestamp, getMarkdownLanguage } from '../utils.js';

export interface FileInfo {
    content: string;
    relativePath: string;
    path: FilePath;
    size: number;
}

export interface OutputContext {
    projectTitle: string;
    versionInfo: string;
    filesToProcess: FileInfo[];
    config: Config;
}

export interface OutputStrategy {
    readonly name: string;
    readonly extension: string;
    generateHeader(context: OutputContext): string;
    processFile(fileInfo: FileInfo, context: OutputContext): string;
    generateFooter?(context: OutputContext): string;
    createStream?(outputPath: FilePath): WriteStream;
}

function escapeHtml(text: string): string {
    return text
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll('\'', '&#39;');
}

export class TextOutputStrategy implements OutputStrategy {
    readonly name = 'text';
    readonly extension = '.txt';

    generateHeader(context: OutputContext): string {
        return `# Generated Project Fusion File
# Project: ${context.projectTitle}${context.versionInfo}
# Generated: ${formatLocalTimestamp()}
# UTC: ${formatTimestamp()}
# Files: ${context.filesToProcess.length}
# Generated by: project-fusion

`;
    }

    processFile(fileInfo: FileInfo): string {
        return `<!-- ============================================================ -->
<!-- FILE: ${fileInfo.relativePath.padEnd(54)} -->
<!-- ============================================================ -->
${fileInfo.content}

`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath);
    }
}

export class MarkdownOutputStrategy implements OutputStrategy {
    readonly name = 'markdown';
    readonly extension = '.md';

    generateHeader(context: OutputContext): string {
        const tocEntries = context.filesToProcess
            .map(fileInfo => `- [${fileInfo.relativePath}](#${fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, '-').toLowerCase()})`)
            .join('\n');

        return `# Generated Project Fusion File

**Project:** ${context.projectTitle}${context.versionInfo}

**Generated:** ${formatLocalTimestamp()}

**UTC:** ${formatTimestamp()}

**Files:** ${context.filesToProcess.length}

**Generated by:** [project-fusion](https://github.com/the99studio/project-fusion)

---

## üìÅ Table of Contents

${tocEntries}

---

`;
    }

    processFile(fileInfo: FileInfo): string {
        const fileExt = path.extname(fileInfo.path).toLowerCase();
        const basename = path.basename(fileInfo.path);
        const language = getMarkdownLanguage(fileExt || basename);

        return `## üìÑ ${fileInfo.relativePath}

\`\`\`${language}
${fileInfo.content}
\`\`\`

`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath);
    }
}

export class HtmlOutputStrategy implements OutputStrategy {
    readonly name = 'html';
    readonly extension = '.html';

    generateHeader(context: OutputContext): string {
        const tocEntries = context.filesToProcess
            .map(fileInfo => `            <li><a href="#${fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, '-').toLowerCase()}">${escapeHtml(fileInfo.relativePath)}</a></li>`)
            .join('\n');

        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Fusion - ${escapeHtml(context.projectTitle)}${escapeHtml(context.versionInfo)}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { border-bottom: 2px solid #eee; padding-bottom: 20px; margin-bottom: 30px; }
        .file-section { margin-bottom: 40px; border: 1px solid #ddd; border-radius: 8px; padding: 20px; }
        .file-title { background: #f5f5f5; margin: -20px -20px 20px -20px; padding: 15px 20px; border-radius: 8px 8px 0 0; }
        pre { background: #f8f9fa; padding: 15px; border-radius: 6px; overflow-x: auto; }
        code { font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; }
        .toc { background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 30px; }
        .toc ul { margin: 0; padding-left: 20px; }
        .toc a { text-decoration: none; color: #0366d6; }
        .toc a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Generated Project Fusion File</h1>
        <p><strong>Project:</strong> ${escapeHtml(context.projectTitle)}${escapeHtml(context.versionInfo)}</p>
        <p><strong>Generated:</strong> ${formatLocalTimestamp()}</p>
        <p><strong>UTC:</strong> ${formatTimestamp()}</p>
        <p><strong>Files:</strong> ${context.filesToProcess.length}</p>
        <p><strong>Generated by:</strong> <a href="https://github.com/the99studio/project-fusion">project-fusion</a></p>
    </div>
    <div class="toc">
        <h2>üìÅ Table of Contents</h2>
        <ul>
${tocEntries}
        </ul>
    </div>
`;
    }

    processFile(fileInfo: FileInfo): string {
        const fileExt = path.extname(fileInfo.path).toLowerCase();
        const basename = path.basename(fileInfo.path);
        const language = getMarkdownLanguage(fileExt || basename);
        const escapedContent = escapeHtml(fileInfo.content);
        const fileAnchor = fileInfo.relativePath.replaceAll(/[^\dA-Za-z]/g, '-').toLowerCase();

        return `    <div class="file-section" id="${fileAnchor}">
        <div class="file-title">
            <h2>üìÑ ${escapeHtml(fileInfo.relativePath)}</h2>
        </div>
        <pre><code class="${language}">${escapedContent}</code></pre>
    </div>

`;
    }

    generateFooter(): string {
        return `</body>
</html>`;
    }

    createStream(outputPath: FilePath): WriteStream {
        return createWriteStream(outputPath);
    }
}

export class OutputStrategyManager {
    private readonly strategies: Map<string, OutputStrategy> = new Map();

    constructor() {
        this.registerStrategy(new TextOutputStrategy());
        this.registerStrategy(new MarkdownOutputStrategy());
        this.registerStrategy(new HtmlOutputStrategy());
    }

    registerStrategy(strategy: OutputStrategy): void {
        this.strategies.set(strategy.name, strategy);
    }

    getStrategy(name: string): OutputStrategy | undefined {
        return this.strategies.get(name);
    }

    getEnabledStrategies(config: Config): OutputStrategy[] {
        const enabled: OutputStrategy[] = [];
        
        if (config.generateText) {
            const strategy = this.getStrategy('text');
            if (strategy) enabled.push(strategy);
        }
        
        if (config.generateMarkdown) {
            const strategy = this.getStrategy('markdown');
            if (strategy) enabled.push(strategy);
        }
        
        if (config.generateHtml) {
            const strategy = this.getStrategy('html');
            if (strategy) enabled.push(strategy);
        }
        
        return enabled;
    }

    getOutputPath(strategy: OutputStrategy, config: Config): FilePath {
        return createFilePath(path.resolve(config.rootDirectory, `${config.generatedFileName}${strategy.extension}`));
    }

    async generateOutput(
        strategy: OutputStrategy, 
        context: OutputContext, 
        fs: FileSystemAdapter
    ): Promise<FilePath> {
        const outputPath = this.getOutputPath(strategy, context.config);
        
        await fs.ensureDir(path.dirname(outputPath));
        
        let content = strategy.generateHeader(context);
        
        for (const fileInfo of context.filesToProcess) {
            content += strategy.processFile(fileInfo, context);
        }
        
        if (strategy.generateFooter) {
            content += strategy.generateFooter(context);
        }
        
        await fs.writeFile(outputPath, content);
        
        return outputPath;
    }
}

<!-- ============================================================ -->
<!-- FILE: src/types.ts                                           -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Type definitions for the fusion functionality
 */

// Branded types for type-safe handling
export type FilePath = string & { readonly __brand: unique symbol };

export const createFilePath = (path: string): FilePath => {
    if (!path || typeof path !== 'string') {
        throw new FusionError('Invalid file path provided', 'INVALID_PATH', 'error');
    }
    return path as FilePath;
};

// Utility types for enhanced type safety
export type NonEmptyArray<T> = readonly [T, ...T[]];

export const isNonEmptyArray = <T>(array: readonly T[]): array is NonEmptyArray<T> => {
    return array.length > 0;
};

export const createNonEmptyArray = <T>(items: readonly T[]): NonEmptyArray<T> => {
    if (!isNonEmptyArray(items)) {
        throw new FusionError('Array must contain at least one element', 'EMPTY_ARRAY', 'error');
    }
    return items;
};

// Extension groups with type safety (alphabetically sorted)
export const EXTENSION_GROUPS = {
    web: ['.css', '.html', '.js', '.jsx', '.svelte', '.ts', '.tsx', '.vue'],
    backend: ['.cs', '.go', '.java', '.php', '.py', '.rb', '.rs'],
    config: ['.cfg', '.json', '.toml', '.xml', '.yaml', '.yml'],
    cpp: ['.c', '.cc', '.cpp', '.h', '.hpp'],
    scripts: ['.bat', '.cmd', '.ps1', '.sh'],
    godot: ['.gd', '.import', '.tres', '.tscn'],
    doc: ['.adoc', '.md', '.rst']
} as const;

export type ExtensionGroupName = keyof typeof EXTENSION_GROUPS;
export type ExtensionGroup = typeof EXTENSION_GROUPS[ExtensionGroupName];

export const isValidExtensionGroup = (group: string): group is ExtensionGroupName => {
    return group in EXTENSION_GROUPS;
};

export const getExtensionsForGroup = (groupName: ExtensionGroupName): ExtensionGroup => {
    return EXTENSION_GROUPS[groupName];
};

// Enhanced error hierarchy with codes and severity
export type FusionErrorCode = 
    | 'INVALID_PATH'
    | 'UNKNOWN_EXTENSION_GROUP'
    | 'EMPTY_ARRAY'
    | 'PATH_TRAVERSAL'
    | 'SYMLINK_NOT_ALLOWED';

export type FusionErrorSeverity = 'error' | 'warning' | 'info';

export class FusionError extends Error {
    public readonly code: FusionErrorCode;
    public readonly severity: FusionErrorSeverity;
    public readonly context: Record<string, unknown> | undefined;

    constructor(
        message: string, 
        code: FusionErrorCode, 
        severity: FusionErrorSeverity = 'error',
        context?: Record<string, unknown>
    ) {
        super(message);
        this.name = 'FusionError';
        this.code = code;
        this.severity = severity;
        this.context = context;
    }
}

/**
 * Main configuration interface
 */
export interface Config {
    copyToClipboard: boolean;
    generatedFileName: string;
    generateHtml: boolean;
    generateMarkdown: boolean;
    generateText: boolean;
    ignorePatterns: string[];
    maxFileSizeKB: number;
    parsedFileExtensions: {
        backend?: string[];
        config?: string[];
        cpp?: string[];
        doc?: string[];
        godot?: string[];
        scripts?: string[];
        web?: string[];
        [key: string]: string[] | undefined;
    };
    parseSubDirectories: boolean;
    rootDirectory: string;
    schemaVersion: number;
    useGitIgnoreForExcludes: boolean;
}


/**
 * Options for the fusion process
 */
export interface FusionOptions {
    extensionGroups?: string[];
    pluginsDir?: string;
    enabledPlugins?: string[];
    fs?: import('./adapters/file-system.js').FileSystemAdapter;
}

/**
 * Type-safe fusion result with discriminated union for success/failure states
 */
export type FusionResult = 
    | {
        fusionFilePath: FilePath;
        logFilePath: FilePath;
        message: string;
        success: true;
    }
    | {
        error?: Error;
        logFilePath?: FilePath;
        message: string;
        success: false;
    };

<!-- ============================================================ -->
<!-- FILE: src/utils.ts                                           -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Utilities for Project Fusion
 */
import path from 'node:path';

import fs from 'fs-extra';
import { z } from 'zod';

import { ConfigSchemaV1 } from './schema.js';
import { type Config, FusionError, isNonEmptyArray, isValidExtensionGroup } from './types.js';


/**
 * Default configuration for Project Fusion
 */
export const defaultConfig = {
    copyToClipboard: false,
    generatedFileName: "project-fusioned",
    generateHtml: true,
    generateMarkdown: true,
    generateText: true,
    maxFileSizeKB: 1024,
    parseSubDirectories: true,
    parsedFileExtensions: {
        backend: [".cs", ".go", ".java", ".php", ".py", ".rb", ".rs"] as const,
        config: [".json", ".toml", ".xml", ".yaml", ".yml"] as const,
        cpp: [".c", ".cc", ".cpp", ".h", ".hpp"] as const,
        doc: [".adoc", ".md", ".rst"] as const,
        godot: [".cfg", ".cs", ".gd", ".import", ".tscn", ".tres"] as const,
        scripts: [".bat", ".cmd", ".ps1", ".sh"] as const,
        web: [".css", ".html", ".js", ".jsx", ".svelte", ".ts", ".tsx", ".vue"] as const
    },
    ignorePatterns: [
        "project-fusion.json",
        "project-fusion.log",
        "project-fusioned.*",
        "node_modules/",
        "package-lock.json",
        "pnpm-lock.yaml",
        "yarn.lock",
        "dist/",
        "build/",
        "*.min.js",
        "*.min.css",
        ".env",
        ".env.*",
        "*.key",
        "*.pem",
        "**/credentials/*",
        "**/secrets/*",
        "*.log",
        "logs/",
        ".DS_Store",
        "Thumbs.db",
        ".vscode/",
        ".idea/",
        "*.swp",
        "*.swo",
        // Binary files and archives
        "*.zip",
        "*.tar",
        "*.tgz",
        "*.gz",
        "*.7z",
        "*.rar",
        // Images
        "*.png",
        "*.jpg",
        "*.jpeg",
        "*.gif",
        "*.bmp",
        "*.ico",
        "*.svg",
        "*.webp",
        // Documents
        "*.pdf",
        "*.doc",
        "*.docx",
        "*.xls",
        "*.xlsx",
        "*.ppt",
        "*.pptx",
        // Media
        "*.mp3",
        "*.mp4",
        "*.avi",
        "*.mov",
        "*.wmv",
        "*.flv",
        "*.wav",
        "*.flac",
        // Game engine assets
        "*.unitypackage",
        "*.uasset",
        "*.fbx",
        "*.obj",
        "*.blend",
        // Compiled/Binary
        "*.exe",
        "*.dll",
        "*.so",
        "*.dylib",
        "*.a",
        "*.o",
        "*.pyc",
        "*.pyo",
        "*.class",
        "*.jar",
        "*.war"
    ],
    rootDirectory: ".",
    schemaVersion: 1,
    useGitIgnoreForExcludes: true
} as const satisfies Config;


/**
 * Load and validate configuration with fallback to defaults
 * @returns The loaded configuration or default config if invalid/missing
 */
export async function loadConfig(): Promise<Config> {
    try {
        const configPath = path.resolve('./project-fusion.json');
        
        let configContent: string;
        try {
            configContent = await fs.readFile(configPath, 'utf8');
        } catch {
            return defaultConfig;
        }

        const parsedConfig = JSON.parse(configContent) as unknown;

        try {
            const validatedConfig = ConfigSchemaV1.parse(parsedConfig);
            return validatedConfig;
        } catch (zodError: unknown) {
            // Graceful degradation with detailed error reporting
            if (zodError instanceof z.ZodError) {
                console.error('Configuration validation failed (will use default config):');
                for (const [index, issue] of zodError.issues.entries()) {
                    const path = issue.path.length > 0 ? issue.path.join('.') : 'root';
                     
                    const value = issue.path.reduce((obj: unknown, key) => {
                        if (typeof key === 'string' && obj && typeof obj === 'object') {
                            return (obj as Record<string, unknown>)[key];
                        }
                        return undefined;
                    }, parsedConfig);
                    console.error(`  ${index + 1}. Path: ${path}`);
                    console.error(`     Error: ${issue.message}`);
                    console.error(`     Current value: ${JSON.stringify(value)}`);
                    if (issue.code === 'invalid_type') {
                         
                        console.error(`     Expected type: ${String((issue as unknown as Record<string, unknown>)['expected'])}, received: ${String((issue as unknown as Record<string, unknown>)['received'])}`);
                    }
                }
            } else {
                console.error('Unknown validation error (will use default config):', zodError);
            }
            return defaultConfig;
        }
    } catch (error) {
        const typedError = error instanceof Error ? error : new Error(String(error));

        console.error('Error loading configuration, will use default configuration:', {
            message: typedError.message,
            stack: typedError.stack,
            context: 'loadConfig',
            configPath: path.resolve('./project-fusion.json')
        });

        return defaultConfig;
    }
}

/**
 * Create directory if it doesn't exist
 * @param directory Directory path
 */
export async function ensureDirectoryExists(directory: string): Promise<void> {
    await fs.ensureDir(directory);
}

/**
 * Write content to log file with optional console output
 * @param logFilePath Path to log file
 * @param content Content to log
 * @param append If true, append to existing file
 * @param consoleOutput If true, also display on console
 */
export async function writeLog(
    logFilePath: string,
    content: string,
    append = false,
    consoleOutput = false
): Promise<void> {
    try {
        await ensureDirectoryExists(path.dirname(logFilePath));
        await (append ? fs.appendFile(logFilePath, `${content  }\n`) : fs.writeFile(logFilePath, `${content  }\n`));

        if (consoleOutput) {
            console.log(content);
        }
    } catch (error) {
        console.error('Error writing log:', error);
    }
}


/**
 * Format a timestamp
 * @param date Optional date to format, defaults to current date
 * @returns Formatted timestamp
 */
export function formatTimestamp(date?: Date): string {
    return (date ?? new Date()).toISOString();
}

/**
 * Format a local timestamp for display
 * @param date Optional date to format, defaults to current date
 * @returns Formatted local timestamp
 */
export function formatLocalTimestamp(date?: Date): string {
    const now = date ?? new Date();
    return now.toLocaleString('fr-FR', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        timeZoneName: 'short'
    });
}


/**
 * Extract file extensions from configuration groups
 * @param config Config object
 * @param groups Extension groups to include (all if undefined)
 * @returns Array of file extensions
 */
export function getExtensionsFromGroups(
    config: Config,
    groups?: string[]
): string[] {
    // Return all extensions if no specific groups requested
    if (!groups || groups.length === 0) {
        return Object.values(config.parsedFileExtensions)
            .filter((extensions): extensions is string[] => Boolean(extensions))
            .flat();
    }

    // Validate and collect extensions from specified groups
    return groups.reduce((acc: string[], group: string) => {
        // Type-safe group validation
        if (!isValidExtensionGroup(group)) {
            console.warn(`Unknown extension group '${group}'. Valid groups: ${Object.keys(config.parsedFileExtensions).join(', ')}`);
            return acc;
        }

        const extensions = config.parsedFileExtensions[group];
        if (extensions && isNonEmptyArray(extensions)) {
            acc.push(...extensions);
        } else {
            console.warn(`Extension group '${group}' is empty or not found in configuration`);
        }
        return acc;
    }, []);
}

/**
 * Validate that a file path is safe and doesn't escape the root directory
 * @param filePath Path to validate
 * @param rootDirectory Root directory that files must stay within
 * @returns Normalized absolute path if valid
 * @throws FusionError if path is unsafe
 */
export function validateSecurePath(filePath: string, rootDirectory: string): string {
    try {
        // Resolve both paths to absolute paths
        const resolvedRoot = path.resolve(rootDirectory);
        const resolvedFile = path.resolve(filePath);
        
        // Use path.relative for more robust validation
        const relativePath = path.relative(resolvedRoot, resolvedFile);
        
        // If relative path starts with '..' or is absolute, the file escapes the root
        if (relativePath.startsWith('..') || path.isAbsolute(relativePath)) {
            throw new FusionError(
                `Path traversal detected: '${filePath}' escapes root directory '${rootDirectory}'`,
                'PATH_TRAVERSAL',
                'error',
                { filePath, rootDirectory, resolvedFile, resolvedRoot, relativePath }
            );
        }
        
        return resolvedFile;
    } catch (error) {
        if (error instanceof FusionError) {
            throw error;
        }
        throw new FusionError(
            `Invalid path: '${filePath}'`,
            'INVALID_PATH',
            'error',
            { filePath, rootDirectory, originalError: error }
        );
    }
}

/**
 * Check if a path is a symbolic link and validate it's allowed
 * @param filePath Path to check
 * @param allowSymlinks Whether symbolic links are allowed
 * @returns True if the path is safe to process
 * @throws FusionError if symlink is found and not allowed
 */
export async function validateNoSymlinks(filePath: string, allowSymlinks: boolean = false): Promise<boolean> {
    try {
        const stats = await fs.lstat(filePath);
        
        if (stats.isSymbolicLink()) {
            if (!allowSymlinks) {
                throw new FusionError(
                    `Symbolic link not allowed: '${filePath}'`,
                    'SYMLINK_NOT_ALLOWED',
                    'error',
                    { filePath }
                );
            }
            // If symlinks are allowed, we still want to log them for transparency
            console.warn(`Processing symbolic link: ${filePath}`);
        }
        
        return true;
    } catch (error) {
        if (error instanceof FusionError) {
            throw error;
        }
        // If lstat fails, the file doesn't exist or is inaccessible
        return false;
    }
}

/**
 * Detect if a file appears to be binary
 * @param filePath Path to the file
 * @param sampleSize Number of bytes to sample (default: 1024)
 * @returns True if the file appears to be binary
 */
export async function isBinaryFile(filePath: string, sampleSize: number = 1024): Promise<boolean> {
    try {
        const stats = await fs.stat(filePath);
        if (stats.size === 0) {
            return false; // Empty file is not binary
        }
        
        // Read only the first part of the file for analysis
        const bytesToRead = Math.min(stats.size, sampleSize);
        const buffer = await fs.readFile(filePath, { encoding: null });
        const actualBytesToCheck = Math.min(buffer.length, bytesToRead);
        
        // Check for null bytes which indicate binary content
        for (let i = 0; i < actualBytesToCheck; i++) {
            if (buffer[i] === 0) {
                return true;
            }
        }
        
        // Check for high ratio of non-printable characters
        let nonPrintable = 0;
        for (let i = 0; i < actualBytesToCheck; i++) {
            const byte = buffer[i];
            if (byte === undefined) continue; // Skip undefined bytes
            // Allow common whitespace chars: space(32), tab(9), newline(10), carriage return(13)
            if (byte < 32 && byte !== 9 && byte !== 10 && byte !== 13) {
                nonPrintable++;
            } else if (byte > 126) {
                nonPrintable++;
            }
        }
        
        // If more than 30% non-printable, consider it binary
        return (nonPrintable / actualBytesToCheck) > 0.3;
    } catch {
        // If we can't read the file, assume it's not binary
        return false;
    }
}

/**
 * Map file extensions to syntax highlighting languages for markdown/HTML
 * @param extensionOrBasename File extension or special basename
 * @returns Language identifier for syntax highlighting
 */
export function getMarkdownLanguage(extensionOrBasename: string): string {
    // Comprehensive mapping for syntax highlighting across multiple formats
    const languageMap: Record<string, string> = {
        // Backend (alphabetized)
        '.cs': 'csharp',
        '.go': 'go',
        '.java': 'java',
        '.kt': 'kotlin',
        '.lua': 'lua',
        '.perl': 'perl',
        '.php': 'php',
        '.pl': 'perl',
        '.py': 'python',
        '.r': 'r',
        '.rb': 'ruby',
        '.rs': 'rust',
        '.scala': 'scala',
        '.swift': 'swift',
        
        // C/C++ (alphabetized)
        '.c': 'c',
        '.cc': 'cpp',
        '.cpp': 'cpp',
        '.cxx': 'cpp',
        '.h': 'c',
        '.hpp': 'cpp',
        '.hxx': 'cpp',
        
        // Config (alphabetized)
        '.env': 'bash',
        '.ini': 'ini',
        '.json': 'json',
        '.toml': 'toml',
        '.xml': 'xml',
        '.yaml': 'yaml',
        '.yml': 'yaml',
        
        // Database
        '.sql': 'sql',
        
        // Documentation (alphabetized)
        '.md': 'markdown',
        '.mdx': 'markdown',
        '.rst': 'rst',
        '.tex': 'latex',
        
        // Godot (alphabetized)
        '.cfg': 'ini',
        '.gd': 'gdscript',
        '.import': 'ini',
        '.tres': 'gdscript',
        '.tscn': 'gdscript',
        
        // Other (alphabetized)
        '.cmake': 'cmake',
        '.dockerfile': 'dockerfile',
        '.Dockerfile': 'dockerfile',
        '.gql': 'graphql',
        '.gradle': 'gradle',
        '.graphql': 'graphql',
        '.makefile': 'makefile',
        '.Makefile': 'makefile',
        '.proto': 'protobuf',
        
        // Shell/Scripts (alphabetized)
        '.bash': 'bash',
        '.bat': 'batch',
        '.cmd': 'batch',
        '.fish': 'bash',
        '.ps1': 'powershell',
        '.sh': 'bash',
        '.zsh': 'bash',
        
        // Web (alphabetized)
        '.css': 'css',
        '.html': 'html',
        '.js': 'javascript',
        '.jsx': 'jsx',
        '.less': 'less',
        '.sass': 'sass',
        '.scss': 'scss',
        '.svelte': 'svelte',
        '.ts': 'typescript',
        '.tsx': 'tsx',
        '.vue': 'vue',
        
        // Files without extensions (alphabetized by basename)
        '.gitattributes': 'text',
        '.gitignore': 'text',
        '.htaccess': 'apache',
        'Cargo.lock': 'toml',
        'Cargo.toml': 'toml',
        'CMakeLists.txt': 'cmake',
        dockerfile: 'dockerfile',
        Dockerfile: 'dockerfile',
        Gemfile: 'ruby',
        'go.mod': 'go',
        'go.sum': 'text',
        Jenkinsfile: 'groovy',
        makefile: 'makefile',
        Makefile: 'makefile',
        'nginx.conf': 'nginx',
        Rakefile: 'ruby',
        'requirements.txt': 'text',
        Vagrantfile: 'ruby',
    };
    
    // Case-insensitive lookup with fallback to 'text'
    const lang = languageMap[extensionOrBasename.toLowerCase()] ?? languageMap[extensionOrBasename];
    return lang ?? 'text';
}

<!-- ============================================================ -->
<!-- FILE: tests/api.test.ts                                      -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for programmatic API
 */
import { existsSync } from 'node:fs';
import { join } from 'node:path';
import { mkdir, rm, writeFile } from 'node:fs/promises';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { createConfig, fusionAPI, runFusion } from '../src/api.js';
import { defaultConfig } from '../src/utils.js';
import type { Config } from '../src/types.js';

describe('API Tests', () => {
    const testDir = join(process.cwd(), 'temp', 'test-api');
    const testProjectDir = join(testDir, 'test-project');
    
    beforeEach(async () => {
        // Create test directories
        await mkdir(testProjectDir, { recursive: true });
        
        // Create test files
        await writeFile(join(testProjectDir, 'index.js'), 'console.log("Hello");');
        await writeFile(join(testProjectDir, 'app.ts'), 'const app = "test";');
        await writeFile(join(testProjectDir, 'style.css'), 'body { margin: 0; }');
        await writeFile(join(testProjectDir, 'config.json'), '{"test": true}');
        await writeFile(join(testProjectDir, 'README.md'), '# Test Project');
        await writeFile(join(testProjectDir, 'script.py'), 'print("Python")');
    });
    
    afterEach(async () => {
        // Clean up test directories
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        
        // Clean up generated files in current directory if any
        const generatedFiles = [
            'project-fusioned.txt',
            'project-fusioned.md',
            'project-fusioned.html',
            'project-fusioned.log'
        ];
        for (const file of generatedFiles) {
            const filePath = join(testProjectDir, file);
            if (existsSync(filePath)) {
                await rm(filePath, { force: true });
            }
        }
    });
    
    describe('createConfig', () => {
        it('should create a complete config with defaults', () => {
            const config = createConfig();
            
            expect(config.schemaVersion).toBe(1);
            expect(config.copyToClipboard).toBe(defaultConfig.copyToClipboard);
            expect(config.generatedFileName).toBe(defaultConfig.generatedFileName);
            expect(config.generateHtml).toBe(defaultConfig.generateHtml);
            expect(config.generateMarkdown).toBe(defaultConfig.generateMarkdown);
            expect(config.generateText).toBe(defaultConfig.generateText);
            expect(config.maxFileSizeKB).toBe(defaultConfig.maxFileSizeKB);
            expect(config.parsedFileExtensions).toEqual(defaultConfig.parsedFileExtensions);
            expect(config.parseSubDirectories).toBe(defaultConfig.parseSubDirectories);
            expect(config.rootDirectory).toBe(process.cwd());
            expect(config.useGitIgnoreForExcludes).toBe(defaultConfig.useGitIgnoreForExcludes);
        });
        
        it('should override defaults with provided values', () => {
            const overrides = {
                generateHtml: false,
                maxFileSizeKB: 2048,
                rootDirectory: '/custom/path'
            };
            
            const config = createConfig(overrides);
            
            expect(config.generateHtml).toBe(false);
            expect(config.maxFileSizeKB).toBe(2048);
            expect(config.rootDirectory).toBe('/custom/path');
            expect(config.generateMarkdown).toBe(defaultConfig.generateMarkdown);
        });
        
        it('should handle partial parsedFileExtensions override', () => {
            const config = createConfig({
                parsedFileExtensions: {
                    web: ['.ts', '.tsx'],
                    backend: ['.py']
                }
            });
            
            expect(config.parsedFileExtensions).toEqual({
                web: ['.ts', '.tsx'],
                backend: ['.py']
            });
        });
    });
    
    describe('fusionAPI', () => {
        it('should process fusion with default config', async () => {
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            expect(result.message).toContain('Fusion completed');
            expect(result.fusionFilePath).toBeDefined();
            expect(result.logFilePath).toBeDefined();
            
            // Check files were created
            expect(existsSync(join(testProjectDir, 'project-fusioned.txt'))).toBe(true);
            expect(existsSync(join(testProjectDir, 'project-fusioned.md'))).toBe(true);
            expect(existsSync(join(testProjectDir, 'project-fusioned.log'))).toBe(true);
        });
        
        it('should handle custom extensions', async () => {
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                parsedFileExtensions: {
                    web: ['.js', '.ts'],
                    backend: [],
                    config: [],
                    cpp: [],
                    doc: [],
                    godot: [],
                    scripts: []
                },
                generateHtml: false,
                generateMarkdown: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            
            // Check that only .js and .ts files were processed
            const content = await import('node:fs').then(fs => 
                fs.promises.readFile(join(testProjectDir, 'project-fusioned.txt'), 'utf8')
            );
            expect(content).toContain('index.js');
            expect(content).toContain('app.ts');
            expect(content).not.toContain('style.css');
            expect(content).not.toContain('config.json');
        });
        
        it('should respect extensionGroups filter', async () => {
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                extensionGroups: ['web'],
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            
            const content = await import('node:fs').then(fs => 
                fs.promises.readFile(join(testProjectDir, 'project-fusioned.txt'), 'utf8')
            );
            expect(content).toContain('index.js');
            expect(content).toContain('app.ts');
            expect(content).toContain('style.css');
            expect(content).not.toContain('config.json');
            expect(content).not.toContain('script.py');
        });
        
        it('should handle rootDir option', async () => {
            const result = await fusionAPI({
                cwd: testDir,
                rootDir: 'test-project',
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            expect(existsSync(join(testProjectDir, 'project-fusioned.txt'))).toBe(true);
        });
        
        it('should handle errors gracefully', async () => {
            const result = await fusionAPI({
                rootDirectory: '/non/existent/path',
                copyToClipboard: false
            });
            
            expect(result.success).toBe(false);
            expect(result.message).toContain('failed');
            expect(result.error).toBeDefined();
        });
    });
    
    describe('runFusion', () => {
        it('should work with partial config', async () => {
            const result = await runFusion({
                rootDirectory: testProjectDir,
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            expect(result.message).toContain('Fusion completed');
        });
        
        it('should work with complete config', async () => {
            const config = createConfig({
                rootDirectory: testProjectDir,
                generateHtml: false,
                generateMarkdown: false,
                copyToClipboard: false
            });
            
            const result = await runFusion(config);
            
            expect(result.success).toBe(true);
            expect(existsSync(join(testProjectDir, 'project-fusioned.txt'))).toBe(true);
            expect(existsSync(join(testProjectDir, 'project-fusioned.md'))).toBe(false);
            expect(existsSync(join(testProjectDir, 'project-fusioned.html'))).toBe(false);
        });
        
        it('should accept fusion options', async () => {
            const result = await runFusion(
                { rootDirectory: testProjectDir, copyToClipboard: false },
                { extensionGroups: ['config', 'doc'] }
            );
            
            expect(result.success).toBe(true);
            
            const content = await import('node:fs').then(fs => 
                fs.promises.readFile(join(testProjectDir, 'project-fusioned.txt'), 'utf8')
            );
            expect(content).toContain('config.json');
            expect(content).toContain('README.md');
            expect(content).not.toContain('index.js');
            expect(content).not.toContain('script.py');
        });
        
        it('should handle empty extension groups', async () => {
            const result = await runFusion(
                { 
                    rootDirectory: testProjectDir,
                    parsedFileExtensions: {
                        backend: [],
                        config: [],
                        cpp: [],
                        doc: [],
                        godot: [],
                        scripts: [],
                        web: []
                    },
                    copyToClipboard: false
                }
            );
            
            expect(result.success).toBe(false);
            expect(result.message).toContain('No file extensions to process');
        });
    });
    
    describe('Integration Tests', () => {
        it('should handle complex nested project structure', async () => {
            // Create nested structure
            const nestedDir = join(testProjectDir, 'src', 'components');
            await mkdir(nestedDir, { recursive: true });
            await writeFile(join(nestedDir, 'Button.tsx'), 'export const Button = () => <button />;');
            await writeFile(join(nestedDir, 'Card.tsx'), 'export const Card = () => <div />;');
            
            const utilsDir = join(testProjectDir, 'src', 'utils');
            await mkdir(utilsDir, { recursive: true });
            await writeFile(join(utilsDir, 'helpers.ts'), 'export const helper = () => {};');
            
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                parseSubDirectories: true,
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            
            const content = await import('node:fs').then(fs => 
                fs.promises.readFile(join(testProjectDir, 'project-fusioned.txt'), 'utf8')
            );
            expect(content).toContain('Button.tsx');
            expect(content).toContain('Card.tsx');
            expect(content).toContain('helpers.ts');
        });
        
        it('should respect ignore patterns', async () => {
            // Create test files
            await writeFile(join(testProjectDir, 'test.example.js'), 'console.log("test example");');
            await writeFile(join(testProjectDir, '.env'), 'SECRET=123');
            await writeFile(join(testProjectDir, 'main.ts'), 'const main = () => {};');
            
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                ignorePatterns: ['*.example.js', '.env'],
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            
            const content = await import('node:fs').then(fs => 
                fs.promises.readFile(join(testProjectDir, 'project-fusioned.txt'), 'utf8')
            );
            expect(content).toContain('main.ts');
            expect(content).not.toContain('test.example.js');
            expect(content).not.toContain('.env');
        });
        
        it('should handle file size limits', async () => {
            // Create a large file
            const largeContent = 'x'.repeat(2 * 1024 * 1024); // 2MB
            await writeFile(join(testProjectDir, 'large.js'), largeContent);
            
            const result = await fusionAPI({
                rootDirectory: testProjectDir,
                maxFileSizeKB: 1024, // 1MB limit
                generateHtml: false,
                copyToClipboard: false
            });
            
            expect(result.success).toBe(true);
            
            const content = await import('node:fs').then(fs => 
                fs.promises.readFile(join(testProjectDir, 'project-fusioned.txt'), 'utf8')
            );
            expect(content).not.toContain('large.js');
            expect(content).toContain('index.js'); // Small files should still be included
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/architecture.test.ts                             -->
<!-- ============================================================ -->
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs-extra';
import path from 'node:path';
import { 
    DefaultFileSystemAdapter, 
    MemoryFileSystemAdapter,
    OutputStrategyManager,
    TextOutputStrategy,
    MarkdownOutputStrategy,
    HtmlOutputStrategy,
    PluginManager,
    createPlugin,
    processFusion
} from '../src/index.js';
import { createFilePath, type Config } from '../src/types.js';

const tempDir = path.join(process.cwd(), 'temp', 'architecture-tests');

describe('Architecture Tests', () => {
    beforeEach(async () => {
        await fs.ensureDir(tempDir);
        await fs.emptyDir(tempDir);
    });

    afterEach(async () => {
        await fs.remove(tempDir);
    });

    describe('FileSystemAdapter', () => {
        it('should provide consistent interface between adapters', async () => {
            const defaultFs = new DefaultFileSystemAdapter();
            const memoryFs = new MemoryFileSystemAdapter();

            const testFilePath = createFilePath(path.join(tempDir, 'test.txt'));
            const content = 'Hello World';

            await defaultFs.writeFile(testFilePath, content);
            memoryFs.addFile(testFilePath, content);

            expect(await defaultFs.readFile(testFilePath)).toBe(content);
            expect(await memoryFs.readFile(testFilePath)).toBe(content);

            const defaultStats = await defaultFs.stat(testFilePath);
            const memoryStats = await memoryFs.stat(testFilePath);

            expect(defaultStats.isFile).toBe(true);
            expect(memoryStats.isFile).toBe(true);
            expect(defaultStats.size).toBeGreaterThan(0);
            expect(memoryStats.size).toBeGreaterThan(0);
        });
    });

    describe('OutputStrategy Pattern', () => {
        it('should provide consistent output generation across strategies', async () => {
            const manager = new OutputStrategyManager();
            const memoryFs = new MemoryFileSystemAdapter();

            const context = {
                projectTitle: 'Test Project',
                versionInfo: ' v1.0.0',
                filesToProcess: [{
                    content: 'console.log("hello");',
                    relativePath: 'test.js',
                    path: createFilePath('/test.js'),
                    size: 100
                }],
                config: {
                    rootDirectory: tempDir,
                    generatedFileName: 'test-fusion'
                } as Config
            };

            const textStrategy = manager.getStrategy('text');
            const mdStrategy = manager.getStrategy('markdown');
            const htmlStrategy = manager.getStrategy('html');

            expect(textStrategy).toBeDefined();
            expect(mdStrategy).toBeDefined();
            expect(htmlStrategy).toBeDefined();

            if (textStrategy && mdStrategy && htmlStrategy) {
                const textOutput = await manager.generateOutput(textStrategy, context, memoryFs);
                const mdOutput = await manager.generateOutput(mdStrategy, context, memoryFs);
                const htmlOutput = await manager.generateOutput(htmlStrategy, context, memoryFs);

                expect(textOutput).toContain('.txt');
                expect(mdOutput).toContain('.md');
                expect(htmlOutput).toContain('.html');

                const textContent = await memoryFs.readFile(textOutput);
                const mdContent = await memoryFs.readFile(mdOutput);
                const htmlContent = await memoryFs.readFile(htmlOutput);

                expect(textContent).toContain('console.log("hello");');
                expect(mdContent).toContain('console.log("hello");');
                expect(htmlContent).toContain('console.log(&quot;hello&quot;);');
            }
        });
    });

    describe('Plugin System', () => {
        it('should support plugin registration and execution', async () => {
            const fs = new MemoryFileSystemAdapter();
            const manager = new PluginManager(fs);

            let beforeCalled = false;
            let afterCalled = false;

            const testPlugin = createPlugin(
                {
                    name: 'test-plugin',
                    version: '1.0.0',
                    description: 'Test plugin'
                },
                {
                    beforeFileProcessing: async (fileInfo) => {
                        beforeCalled = true;
                        return fileInfo;
                    },
                    afterFileProcessing: async (fileInfo, content) => {
                        afterCalled = true;
                        return content + '\n// Plugin processed';
                    }
                }
            );

            manager.registerPlugin(testPlugin);
            manager.configurePlugin('test-plugin', { name: 'test-plugin', enabled: true });

            const fileInfo = {
                content: 'test content',
                relativePath: 'test.js',
                path: createFilePath('/test.js'),
                size: 100
            };

            const config = { rootDirectory: tempDir } as Config;

            const processedFile = await manager.executeBeforeFileProcessing(fileInfo, config);
            expect(beforeCalled).toBe(true);
            expect(processedFile).toEqual(fileInfo);

            const processedContent = await manager.executeAfterFileProcessing(fileInfo, 'content', config);
            expect(afterCalled).toBe(true);
            expect(processedContent).toBe('content\n// Plugin processed');
        });
    });

    describe('Fusion V2 Integration', () => {
        it('should process fusion with new architecture', async () => {
            const testDir = path.join(tempDir, 'fusion-v2-test');
            await fs.ensureDir(testDir);

            await fs.writeFile(path.join(testDir, 'test.js'), 'console.log("test");');
            await fs.writeFile(path.join(testDir, 'test.ts'), 'const x: string = "test";');

            const config: Config = {
                schemaVersion: 1,
                copyToClipboard: false,
                generatedFileName: 'test-fusion',
                generateHtml: true,
                generateMarkdown: true,
                generateText: true,
                maxFileSizeKB: 1024,
                parseSubDirectories: false,
                parsedFileExtensions: {
                    web: ['.js', '.ts']
                },
                ignorePatterns: [],
                rootDirectory: testDir,
                useGitIgnoreForExcludes: false
            };

            const result = await processFusion(config, {
                extensionGroups: ['web']
            });

            expect(result.success).toBe(true);
            expect(result.message).toContain('2 files processed');

            const txtPath = path.join(testDir, 'test-fusion.txt');
            const mdPath = path.join(testDir, 'test-fusion.md');
            const htmlPath = path.join(testDir, 'test-fusion.html');

            expect(await fs.pathExists(txtPath)).toBe(true);
            expect(await fs.pathExists(mdPath)).toBe(true);
            expect(await fs.pathExists(htmlPath)).toBe(true);

            const txtContent = await fs.readFile(txtPath, 'utf8');
            const mdContent = await fs.readFile(mdPath, 'utf8');
            const htmlContent = await fs.readFile(htmlPath, 'utf8');

            expect(txtContent).toContain('console.log("test");');
            expect(txtContent).toContain('const x: string = "test";');

            expect(mdContent).toContain('```javascript');
            expect(mdContent).toContain('```typescript');

            expect(htmlContent).toContain('<html');
            expect(htmlContent).toContain('</html>');
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/benchmark.test.ts                                -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for benchmark functionality
 */
import { describe, expect, it, vi, beforeEach, afterEach } from 'vitest';
import { BenchmarkTracker } from '../src/benchmark.js';

describe('BenchmarkTracker', () => {
    let originalMemoryUsage: NodeJS.MemoryUsage;
    
    beforeEach(() => {
        // Mock process.memoryUsage
        originalMemoryUsage = process.memoryUsage();
        vi.spyOn(process, 'memoryUsage').mockReturnValue({
            rss: 100 * 1024 * 1024, // 100MB
            heapTotal: 80 * 1024 * 1024,
            heapUsed: 50 * 1024 * 1024,
            external: 10 * 1024 * 1024,
            arrayBuffers: 5 * 1024 * 1024
        });
    });
    
    afterEach(() => {
        vi.restoreAllMocks();
    });
    
    describe('constructor', () => {
        it('should initialize with zero values', () => {
            const tracker = new BenchmarkTracker();
            const metrics = tracker.getMetrics();
            
            expect(metrics.filesProcessed).toBe(0);
            expect(metrics.totalBytesProcessed).toBe(0);
            expect(metrics.memoryUsedMB).toBeGreaterThan(0);
            expect(metrics.processingTimeMs).toBeGreaterThanOrEqual(0);
        });
    });
    
    describe('markFileProcessed', () => {
        it('should track file metrics', () => {
            const tracker = new BenchmarkTracker();
            
            tracker.markFileProcessed(1024);
            tracker.markFileProcessed(2048);
            
            const metrics = tracker.getMetrics();
            expect(metrics.filesProcessed).toBe(2);
            expect(metrics.totalBytesProcessed).toBe(3072);
        });
        
        it('should handle empty files', () => {
            const tracker = new BenchmarkTracker();
            
            tracker.markFileProcessed(0);
            
            const metrics = tracker.getMetrics();
            expect(metrics.filesProcessed).toBe(1);
            expect(metrics.totalBytesProcessed).toBe(0);
        });
        
        it('should handle large files', () => {
            const tracker = new BenchmarkTracker();
            const largeSize = 10 * 1024 * 1024; // 10MB
            
            tracker.markFileProcessed(largeSize);
            
            const metrics = tracker.getMetrics();
            expect(metrics.filesProcessed).toBe(1);
            expect(metrics.totalBytesProcessed).toBe(largeSize);
        });
    });
    
    describe('getMetrics', () => {
        it('should calculate processing time', async () => {
            const tracker = new BenchmarkTracker();
            
            // Wait a bit to ensure processing time > 0
            await new Promise(resolve => setTimeout(resolve, 10));
            
            const metrics = tracker.getMetrics();
            expect(metrics.processingTimeMs).toBeGreaterThan(0);
        });
        
        it('should calculate throughput correctly', () => {
            const tracker = new BenchmarkTracker();
            
            // Add files
            tracker.markFileProcessed(1024 * 1024); // 1MB
            tracker.markFileProcessed(1024 * 1024); // 1MB
            
            const metrics = tracker.getMetrics();
            
            // Throughput should be total bytes / time in seconds
            if (metrics.processingTimeMs > 0) {
                const expectedThroughput = (2 * 1024 * 1024) / (metrics.processingTimeMs / 1000);
                expect(metrics.throughputBytesPerSec).toBeCloseTo(expectedThroughput, 0);
            }
        });
        
        it('should handle zero processing time', () => {
            const tracker = new BenchmarkTracker();
            
            // Mock Date.now to return same value
            const now = Date.now();
            vi.spyOn(Date, 'now').mockReturnValue(now);
            
            tracker.markFileProcessed(1024);
            const metrics = tracker.getMetrics();
            
            expect(metrics.processingTimeMs).toBe(0);
            expect(metrics.throughputBytesPerSec).toBe(0);
        });
        
        it('should report memory usage', () => {
            const tracker = new BenchmarkTracker();
            const metrics = tracker.getMetrics();
            
            // Based on our mock: 50MB heap used
            expect(metrics.memoryUsedMB).toBeCloseTo(50, 1);
        });
    });
    
    
    describe('Edge Cases', () => {
        it('should handle rapid successive recordings', () => {
            const tracker = new BenchmarkTracker();
            
            for (let i = 0; i < 1000; i++) {
                tracker.markFileProcessed(i);
            }
            
            const metrics = tracker.getMetrics();
            expect(metrics.filesProcessed).toBe(1000);
            expect(metrics.totalBytesProcessed).toBe(499500); // Sum of 0 to 999
        });
        
        it('should handle special characters in filenames', () => {
            const tracker = new BenchmarkTracker();
            
            tracker.markFileProcessed(100);
            tracker.markFileProcessed(200);
            tracker.markFileProcessed(300);
            tracker.markFileProcessed(400);
            
            const metrics = tracker.getMetrics();
            expect(metrics.filesProcessed).toBe(4);
            expect(metrics.totalBytesProcessed).toBe(1000);
        });
        
        it('should maintain accuracy with floating point sizes', () => {
            const tracker = new BenchmarkTracker();
            
            tracker.markFileProcessed(0.1);
            tracker.markFileProcessed(0.2);
            tracker.markFileProcessed(0.3);
            
            const metrics = tracker.getMetrics();
            expect(metrics.totalBytesProcessed).toBeCloseTo(0.6, 10);
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/cli-e2e.test.ts                                  -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * End-to-end CLI tests for Project Fusion
 */
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { execSync } from 'node:child_process';
import { join } from 'node:path';
import { writeFile, mkdir, rm, readFile, access } from 'node:fs/promises';
import { existsSync } from 'node:fs';

describe('CLI E2E Tests', () => {
    const testDir = join(process.cwd(), 'temp', 'cli-e2e-test');
    const originalCwd = process.cwd();
    const cliBin = join(process.cwd(), 'dist', 'cli.js');

    beforeEach(async () => {
        // Clean up and create test directory
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        await mkdir(testDir, { recursive: true });
        
        // Build the project to ensure CLI is available
        try {
            execSync('npm run build', { cwd: process.cwd(), stdio: 'pipe' });
        } catch (error) {
            console.warn('Build failed, continuing with existing dist');
        }
        
        process.chdir(testDir);
    });

    afterEach(async () => {
        process.chdir(originalCwd);
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    describe('Default Command', () => {
        it('should create fusion files with default settings', async () => {
            // Create sample files
            await writeFile('test.js', 'console.log("Hello, World!");');
            await writeFile('test.ts', 'const message: string = "TypeScript";');
            
            // Run the CLI
            const output = execSync(`node "${cliBin}"`, { 
                encoding: 'utf8',
                env: { ...process.env, CI: 'true' } // Disable clipboard and TTY
            });
            
            // Check output contains success message
            expect(output).toContain('‚úÖ');
            expect(output).toContain('files processed');
            expect(output).toContain('Generated files:');
            
            // Check that fusion files were created
            expect(existsSync('project-fusioned.txt')).toBe(true);
            expect(existsSync('project-fusioned.md')).toBe(true);
            expect(existsSync('project-fusioned.html')).toBe(true);
            expect(existsSync('project-fusioned.log')).toBe(true);
            
            // Check content of text file
            const txtContent = await readFile('project-fusioned.txt', 'utf8');
            expect(txtContent).toContain('test.js');
            expect(txtContent).toContain('test.ts');
            expect(txtContent).toContain('Hello, World!');
            expect(txtContent).toContain('TypeScript');
            
            // Check content of markdown file
            const mdContent = await readFile('project-fusioned.md', 'utf8');
            expect(mdContent).toContain('## üìÑ test.js');
            expect(mdContent).toContain('## üìÑ test.ts');
            expect(mdContent).toContain('```javascript');
            expect(mdContent).toContain('```typescript');
            
            // Check content of HTML file
            const htmlContent = await readFile('project-fusioned.html', 'utf8');
            expect(htmlContent).toContain('<!DOCTYPE html>');
            expect(htmlContent).toContain('üìÑ test.js');
            expect(htmlContent).toContain('üìÑ test.ts');
            expect(htmlContent).toContain('<pre><code class="javascript">');
            expect(htmlContent).toContain('<pre><code class="typescript">');
        });

        it('should handle empty directory gracefully', async () => {
            // Run CLI in empty directory
            const output = execSync(`node "${cliBin}"`, { 
                encoding: 'utf8',
                env: { ...process.env, CI: 'true' }
            });
            
            expect(output).toContain('‚ùå');
            expect(output).toContain('No files found to process');
            
            // Should still create a log file
            expect(existsSync('project-fusioned.log')).toBe(true);
        });

        it('should respect command line options', async () => {
            // Create sample files
            await writeFile('test.js', 'console.log("Test");');
            await writeFile('test.py', 'print("Python")');
            
            // Run CLI with specific root directory and extensions
            const output = execSync(`node "${cliBin}" --extensions web`, { 
                encoding: 'utf8',
                env: { ...process.env, CI: 'true' }
            });
            
            expect(output).toContain('‚úÖ');
            expect(output).toContain('Using extension groups: web');
            
            // Check that only JS file was processed (web extensions)
            const txtContent = await readFile('project-fusioned.txt', 'utf8');
            expect(txtContent).toContain('test.js');
            expect(txtContent).not.toContain('test.py'); // Python not in web group
        });
    });

    describe('Init Command', () => {
        it('should create configuration file', async () => {
            const output = execSync(`node "${cliBin}" init`, { 
                encoding: 'utf8',
                env: { ...process.env, CI: 'true' }
            });
            
            expect(output).toContain('‚úÖ Project Fusion initialized successfully!');
            expect(output).toContain('Created:');
            expect(output).toContain('project-fusion.json');
            
            // Check config file was created
            expect(existsSync('project-fusion.json')).toBe(true);
            
            // Validate config content
            const config = JSON.parse(await readFile('project-fusion.json', 'utf8'));
            expect(config).toHaveProperty('schemaVersion', 1);
            expect(config).toHaveProperty('generatedFileName', 'project-fusioned');
            expect(config).toHaveProperty('parsedFileExtensions');
            expect(config.parsedFileExtensions).toHaveProperty('web');
            expect(config.parsedFileExtensions).toHaveProperty('backend');
        });

        it('should not overwrite existing config without force flag', async () => {
            // Create initial config
            await writeFile('project-fusion.json', '{"custom": "config"}');
            
            // Try to init again without force
            try {
                execSync(`node "${cliBin}" init`, { 
                    encoding: 'utf8',
                    env: { ...process.env, CI: 'true' }
                });
                expect.fail('Should have thrown an error');
            } catch (error: any) {
                expect(error.status).toBe(1);
                expect(error.stdout).toContain('already exists');
                expect(error.stdout).toContain('Use --force to override');
            }
            
            // Config should be unchanged
            const config = await readFile('project-fusion.json', 'utf8');
            expect(config).toContain('"custom": "config"');
        });

        it('should overwrite existing config with force flag', async () => {
            // Create initial config
            await writeFile('project-fusion.json', '{"custom": "config"}');
            
            // Init with force flag
            const output = execSync(`node "${cliBin}" init --force`, { 
                encoding: 'utf8',
                env: { ...process.env, CI: 'true' }
            });
            
            expect(output).toContain('‚úÖ Project Fusion initialized successfully!');
            expect(output).toContain('Overriding existing configuration');
            
            // Config should be replaced with default
            const config = JSON.parse(await readFile('project-fusion.json', 'utf8'));
            expect(config).not.toHaveProperty('custom');
            expect(config).toHaveProperty('schemaVersion', 1);
        });
    });

    describe('Config Check Command', () => {
        it('should validate valid configuration', async () => {
            // Create valid config
            const validConfig = {
                schemaVersion: 1,
                generatedFileName: "test-fusion",
                generateHtml: true,
                generateMarkdown: true,
                generateText: true,
                maxFileSizeKB: 1024,
                parseSubDirectories: true,
                parsedFileExtensions: {
                    web: [".js", ".ts"],
                    backend: [".py"]
                },
                rootDirectory: ".",
                useGitIgnoreForExcludes: true,
                copyToClipboard: false,
                ignorePatterns: ["node_modules/"]
            };
            
            await writeFile('project-fusion.json', JSON.stringify(validConfig, null, 2));
            
            const output = execSync(`node "${cliBin}" config-check`, { 
                encoding: 'utf8',
                env: { ...process.env, CI: 'true' }
            });
            
            expect(output).toContain('‚úÖ Configuration is valid!');
            expect(output).toContain('Configuration Summary:');
            expect(output).toContain('Schema Version: 1');
            expect(output).toContain('Generated File Name: test-fusion');
            expect(output).toContain('web: 2 extensions (.js, .ts)');
            expect(output).toContain('backend: 1 extensions (.py)');
        });

        it('should handle invalid configuration', async () => {
            // Create invalid config
            const invalidConfig = {
                schemaVersion: "invalid",
                generateHtml: "not-boolean",
                parsedFileExtensions: "not-object"
            };
            
            await writeFile('project-fusion.json', JSON.stringify(invalidConfig));
            
            try {
                execSync(`node "${cliBin}" config-check`, { 
                    encoding: 'utf8',
                    env: { ...process.env, CI: 'true' }
                });
                expect.fail('Should have thrown an error');
            } catch (error: any) {
                expect(error.status).toBe(1);
                expect(error.stdout).toContain('‚ùå Configuration validation failed:');
                expect(error.stdout).toContain('schemaVersion');
                expect(error.stdout).toContain('expected 1');
            }
        });

        it('should handle missing configuration file', async () => {
            const output = execSync(`node "${cliBin}" config-check`, { 
                encoding: 'utf8',
                env: { ...process.env, CI: 'true' }
            });
            
            expect(output).toContain('‚ö†Ô∏è No project-fusion.json found.');
            expect(output).toContain('Using default configuration.');
            expect(output).toContain('Configuration Summary:');
            expect(output).toContain('(Using default configuration)');
        });

        it('should handle malformed JSON', async () => {
            // Create malformed JSON
            await writeFile('project-fusion.json', '{ invalid json');
            
            try {
                execSync(`node "${cliBin}" config-check`, { 
                    encoding: 'utf8',
                    env: { ...process.env, CI: 'true' }
                });
                expect.fail('Should have thrown an error');
            } catch (error: any) {
                expect(error.status).toBe(1);
                expect(error.stdout).toContain('‚ùå Invalid JSON in configuration file:');
            }
        });
    });

    describe('Clipboard and Environment Handling', () => {
        it('should skip clipboard copy in CI environment', async () => {
            // Create sample file
            await writeFile('test.js', 'console.log("test");');
            
            // Create config with clipboard enabled
            const configWithClipboard = {
                schemaVersion: 1,
                copyToClipboard: true,
                generatedFileName: "project-fusioned",
                generateHtml: true,
                generateMarkdown: true,
                generateText: true,
                maxFileSizeKB: 1024,
                parseSubDirectories: true,
                parsedFileExtensions: { web: [".js"] },
                rootDirectory: ".",
                useGitIgnoreForExcludes: true,
                ignorePatterns: []
            };
            
            await writeFile('project-fusion.json', JSON.stringify(configWithClipboard));
            
            const output = execSync(`node "${cliBin}"`, { 
                encoding: 'utf8',
                env: { ...process.env, CI: 'true' } // Simulate CI environment
            });
            
            expect(output).toContain('‚úÖ');
            expect(output).toContain('üìã Clipboard copy skipped (non-interactive environment)');
        });

        it('should handle non-TTY environment', async () => {
            // Create sample file
            await writeFile('test.js', 'console.log("test");');
            
            const output = execSync(`node "${cliBin}"`, { 
                encoding: 'utf8',
                env: { ...process.env, CI: 'false' }, // Not CI but still non-TTY via execSync
                stdio: ['pipe', 'pipe', 'pipe'] // Force non-TTY
            });
            
            expect(output).toContain('‚úÖ');
            // Should not attempt clipboard copy even without CI flag due to non-TTY
        });
    });

    describe('Error Handling', () => {
        it('should handle invalid command line options', async () => {
            try {
                execSync(`node "${cliBin}" --unknown-option`, { 
                    encoding: 'utf8',
                    env: { ...process.env, CI: 'true' }
                });
                expect.fail('Should have thrown an error');
            } catch (error: any) {
                expect(error.status).toBe(1);
                // Commander.js should show help after error
                expect(error.stdout || error.stderr).toContain('Usage:');
            }
        });

        it('should show help information', async () => {
            const output = execSync(`node "${cliBin}" --help`, { 
                encoding: 'utf8',
                env: { ...process.env, CI: 'true' }
            });
            
            expect(output).toContain('Usage:');
            expect(output).toContain('project-fusion');
            expect(output).toContain('init');
            expect(output).toContain('config-check');
            expect(output).toContain('Options:');
        });

        it('should show version information', async () => {
            const output = execSync(`node "${cliBin}" --version`, { 
                encoding: 'utf8',
                env: { ...process.env, CI: 'true' }
            });
            
            expect(output.trim()).toMatch(/^\d+\.\d+\.\d+$/); // Version format
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/clicommands.test.ts                              -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for CLI commands
 */
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { join } from 'node:path';
import { writeFile, mkdir, rm, readFile, pathExists } from 'fs-extra';
import { existsSync } from 'node:fs';
import { 
    runFusionCommand, 
    runInitCommand, 
    runConfigCheckCommand 
} from '../src/clicommands.js';

// Mock external dependencies
vi.mock('chalk', () => ({
    default: {
        blue: (str: string) => str,
        green: (str: string) => str,
        yellow: (str: string) => str,
        red: (str: string) => str,
        cyan: (str: string) => str,
        gray: (str: string) => str,
        magenta: (str: string) => str
    }
}));

vi.mock('clipboardy', () => ({
    default: {
        write: vi.fn().mockResolvedValue(undefined)
    }
}));

describe('CLI Commands', () => {
    const testDir = join(process.cwd(), 'temp', 'clicommands-test');
    const originalCwd = process.cwd();
    const originalExit = process.exit;
    const originalConsole = {
        log: console.log,
        error: console.error,
        warn: console.warn
    };

    // Mock console and process.exit
    const mockConsole = {
        log: vi.fn(),
        error: vi.fn(),
        warn: vi.fn()
    };
    const mockExit = vi.fn();

    beforeEach(async () => {
        // Clear all mocks before each test
        vi.clearAllMocks();
        
        // Clean up and create test directory
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        await mkdir(testDir, { recursive: true });
        process.chdir(testDir);

        // Mock console and process.exit
        console.log = mockConsole.log;
        console.error = mockConsole.error;
        console.warn = mockConsole.warn;
        process.exit = mockExit as any;
    });

    afterEach(async () => {
        // Restore original functions
        console.log = originalConsole.log;
        console.error = originalConsole.error;
        console.warn = originalConsole.warn;
        process.exit = originalExit;

        process.chdir(originalCwd);
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    describe('runFusionCommand', () => {
        it('should run fusion with default options', async () => {
            // Create sample files
            await writeFile('test.js', 'console.log("Hello");');
            await writeFile('test.ts', 'const msg: string = "TypeScript";');

            await runFusionCommand({});

            // Should log success message
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('‚úÖ'));
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('Generated files:'));
        });

        it('should handle custom root directory', async () => {
            // Create subdirectory with files
            await mkdir('subdir');
            await writeFile('subdir/test.js', 'console.log("Subdir");');

            await runFusionCommand({ root: './subdir' });

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('Using specified directory as root: ./subdir'));
        });

        it('should handle extension groups', async () => {
            await writeFile('test.js', 'console.log("JS");');
            await writeFile('test.py', 'print("Python")');

            await runFusionCommand({ extensions: 'web,backend' });

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('Using extension groups: web, backend'));
        });

        it('should handle clipboard copy', async () => {
            await writeFile('test.js', 'console.log("Test");');
            
            // Create config with clipboard enabled
            const configWithClipboard = {
                schemaVersion: 1,
                copyToClipboard: true,
                generatedFileName: "project-fusioned",
                generateHtml: true,
                generateMarkdown: true,
                generateText: true,
                maxFileSizeKB: 1024,
                parseSubDirectories: true,
                parsedFileExtensions: { web: [".js"] },
                rootDirectory: ".",
                useGitIgnoreForExcludes: true,
                ignorePatterns: []
            };
            
            await writeFile('project-fusion.json', JSON.stringify(configWithClipboard));

            // Mock non-TTY environment
            const originalTTY = process.stdout.isTTY;
            process.stdout.isTTY = true;
            process.env['CI'] = 'false';

            await runFusionCommand({});

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('üìã Fusion content copied to clipboard'));

            // Restore
            process.stdout.isTTY = originalTTY;
        });

        it('should skip clipboard in CI environment', async () => {
            await writeFile('test.js', 'console.log("Test");');
            
            const configWithClipboard = {
                schemaVersion: 1,
                copyToClipboard: true,
                generatedFileName: "project-fusioned",
                generateHtml: true,
                generateMarkdown: true,
                generateText: true,
                maxFileSizeKB: 1024,
                parseSubDirectories: true,
                parsedFileExtensions: { web: [".js"] },
                rootDirectory: ".",
                useGitIgnoreForExcludes: true,
                ignorePatterns: []
            };
            
            await writeFile('project-fusion.json', JSON.stringify(configWithClipboard));

            // Mock CI environment
            process.env['CI'] = 'true';

            await runFusionCommand({});

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('üìã Clipboard copy skipped (non-interactive environment)'));
        });

        it('should handle clipboard error gracefully', async () => {
            await writeFile('test.js', 'console.log("Test");');
            
            const configWithClipboard = {
                schemaVersion: 1,
                copyToClipboard: true,
                generatedFileName: "project-fusioned",
                generateHtml: true,
                generateMarkdown: true,
                generateText: true,
                maxFileSizeKB: 1024,
                parseSubDirectories: true,
                parsedFileExtensions: { web: [".js"] },
                rootDirectory: ".",
                useGitIgnoreForExcludes: true,
                ignorePatterns: []
            };
            
            await writeFile('project-fusion.json', JSON.stringify(configWithClipboard));

            // Mock clipboard error
            const clipboardy = await import('clipboardy');
            vi.mocked(clipboardy.default.write).mockRejectedValueOnce(new Error('Clipboard error'));

            const originalTTY = process.stdout.isTTY;
            process.stdout.isTTY = true;
            process.env['CI'] = 'false';

            await runFusionCommand({});

            expect(mockConsole.warn).toHaveBeenCalledWith(expect.stringContaining('‚ö†Ô∏è Could not copy to clipboard'));

            process.stdout.isTTY = originalTTY;
        });

        it('should handle fusion failure', async () => {
            // Create empty directory (no files to process)
            await runFusionCommand({});

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('‚ùå'));
        });

    });

    describe('runInitCommand', () => {
        it('should create config file', async () => {
            await runInitCommand();

            expect(await pathExists('project-fusion.json')).toBe(true);
            
            const config = JSON.parse(await readFile('project-fusion.json', 'utf8'));
            expect(config).toHaveProperty('schemaVersion', 1);
            expect(config).toHaveProperty('generatedFileName', 'project-fusioned');

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('‚úÖ Project Fusion initialized successfully!'));
        });


        it('should overwrite existing config with force flag', async () => {
            // Create existing config
            await writeFile('project-fusion.json', '{"custom": "config"}');

            await runInitCommand({ force: true });

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('‚ö†Ô∏è Overriding existing configuration'));
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('‚úÖ Project Fusion initialized successfully!'));

            // Config should be replaced
            const config = JSON.parse(await readFile('project-fusion.json', 'utf8'));
            expect(config).not.toHaveProperty('custom');
            expect(config).toHaveProperty('schemaVersion', 1);
        });

        it('should handle write errors', async () => {
            // Create a directory named project-fusion.json to cause write error
            await mkdir('project-fusion.json');

            await runInitCommand();

            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringContaining('‚ùå Initialization failed'));
            expect(mockExit).toHaveBeenCalledWith(1);
        });
    });

    describe('runConfigCheckCommand', () => {
        it('should validate valid configuration', async () => {
            const validConfig = {
                schemaVersion: 1,
                generatedFileName: "test-fusion",
                generateHtml: true,
                generateMarkdown: true,
                generateText: true,
                maxFileSizeKB: 1024,
                parseSubDirectories: true,
                parsedFileExtensions: {
                    web: [".js", ".ts"],
                    backend: [".py"]
                },
                rootDirectory: ".",
                useGitIgnoreForExcludes: true,
                copyToClipboard: false,
                ignorePatterns: ["node_modules/"]
            };
            
            await writeFile('project-fusion.json', JSON.stringify(validConfig, null, 2));

            await runConfigCheckCommand();

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('‚úÖ Configuration is valid!'));
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('Configuration Summary:'));
        });

        it('should handle missing configuration file', async () => {
            await runConfigCheckCommand();

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('‚ö†Ô∏è No project-fusion.json found'));
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('Using default configuration'));
        });

        it('should handle invalid JSON', async () => {
            await writeFile('project-fusion.json', '{ invalid json');

            await runConfigCheckCommand();

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('‚ùå Invalid JSON in configuration file'));
            expect(mockExit).toHaveBeenCalledWith(1);
        });

        it('should handle invalid configuration schema', async () => {
            const invalidConfig = {
                schemaVersion: "invalid",
                generateHtml: "not-boolean",
                parsedFileExtensions: "not-object"
            };
            
            await writeFile('project-fusion.json', JSON.stringify(invalidConfig));

            await runConfigCheckCommand();

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('‚ùå Configuration validation failed'));
            expect(mockExit).toHaveBeenCalledWith(1);
        });

        it('should handle file read errors', async () => {
            // Create a directory instead of file to cause read error
            await mkdir('project-fusion.json');

            await runConfigCheckCommand();

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('‚ùå Cannot read configuration file'));
            expect(mockExit).toHaveBeenCalledWith(1);
        });

        it('should display config info with file preview', async () => {
            // Create some test files
            await writeFile('test.js', 'console.log("test");');
            await writeFile('test.ts', 'const x: string = "test";');

            await runConfigCheckCommand();

            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('üîß Basic Settings'));
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('üìÑ Output Generation'));
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('üìÅ File Extension Groups'));
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('üö´ Ignore Patterns'));
            expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('üîç File Discovery Preview'));
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/file-security.test.ts                            -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * File security tests for Project Fusion
 */
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { join } from 'node:path';
import { writeFile, mkdir, rm, symlink, readFile } from 'node:fs/promises';
import { existsSync } from 'node:fs';
import { validateSecurePath, validateNoSymlinks, isBinaryFile } from '../src/utils.js';
import { processFusion } from '../src/fusion.js';
import { defaultConfig } from '../src/utils.js';
import { FusionError } from '../src/types.js';

describe('File Security Tests', () => {
    const testDir = join(process.cwd(), 'temp', 'file-security-test');
    const outsideDir = join(process.cwd(), 'temp', 'outside-test');

    beforeEach(async () => {
        // Clean up and create test directories
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        if (existsSync(outsideDir)) {
            await rm(outsideDir, { recursive: true, force: true });
        }
        await mkdir(testDir, { recursive: true });
        await mkdir(outsideDir, { recursive: true });
        process.chdir(testDir);
    });

    afterEach(async () => {
        process.chdir(join(testDir, '..', '..'));
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        if (existsSync(outsideDir)) {
            await rm(outsideDir, { recursive: true, force: true });
        }
    });

    describe('Path Traversal Protection', () => {
        it('should validate safe paths within root directory', () => {
            const safePath1 = join(testDir, 'safe-file.js');
            const safePath2 = join(testDir, 'subdir', 'another-file.ts');
            
            expect(() => validateSecurePath(safePath1, testDir)).not.toThrow();
            expect(() => validateSecurePath(safePath2, testDir)).not.toThrow();
            
            const validatedPath = validateSecurePath(safePath1, testDir);
            expect(validatedPath).toBe(safePath1);
        });

        it('should reject paths that escape root directory', () => {
            const maliciousPath1 = join(testDir, '..', '..', 'etc', 'passwd');
            const maliciousPath2 = '../../../etc/passwd';
            const maliciousPath3 = join(outsideDir, 'evil.js');
            
            expect(() => validateSecurePath(maliciousPath1, testDir)).toThrow(FusionError);
            expect(() => validateSecurePath(maliciousPath2, testDir)).toThrow(FusionError);
            expect(() => validateSecurePath(maliciousPath3, testDir)).toThrow(FusionError);
            
            try {
                validateSecurePath(maliciousPath1, testDir);
            } catch (error) {
                expect(error).toBeInstanceOf(FusionError);
                expect((error as FusionError).code).toBe('PATH_TRAVERSAL');
            }
        });

        it('should handle relative paths correctly', () => {
            // When run from testDir, relative paths should be resolved relative to testDir
            const relativePath = './safe-file.js';
            const result = validateSecurePath(relativePath, testDir);
            expect(result).toBe(join(testDir, 'safe-file.js'));
        });

        it('should prevent access to root directory itself when not intended', () => {
            const rootPath = testDir;
            // Root directory itself should be valid
            expect(() => validateSecurePath(rootPath, testDir)).not.toThrow();
            
            // But parent of root should not be
            const parentPath = join(testDir, '..');
            expect(() => validateSecurePath(parentPath, testDir)).toThrow(FusionError);
        });
    });

    describe('Symbolic Link Detection', () => {
        it('should detect and reject symbolic links by default', async () => {
            const targetFile = join(testDir, 'target.js');
            const symlinkFile = join(testDir, 'symlink.js');
            
            await writeFile(targetFile, 'console.log("target");');
            await symlink(targetFile, symlinkFile);
            
            await expect(validateNoSymlinks(symlinkFile, false)).rejects.toThrow(FusionError);
            
            try {
                await validateNoSymlinks(symlinkFile, false);
            } catch (error) {
                expect(error).toBeInstanceOf(FusionError);
                expect((error as FusionError).code).toBe('SYMLINK_NOT_ALLOWED');
            }
        });

        it('should allow symbolic links when explicitly enabled', async () => {
            const targetFile = join(testDir, 'target.js');
            const symlinkFile = join(testDir, 'symlink.js');
            
            await writeFile(targetFile, 'console.log("target");');
            await symlink(targetFile, symlinkFile);
            
            await expect(validateNoSymlinks(symlinkFile, true)).resolves.toBe(true);
        });

        it('should handle non-existent files gracefully', async () => {
            const nonExistentFile = join(testDir, 'does-not-exist.js');
            await expect(validateNoSymlinks(nonExistentFile, false)).resolves.toBe(false);
        });

        it('should handle regular files correctly', async () => {
            const regularFile = join(testDir, 'regular.js');
            await writeFile(regularFile, 'console.log("regular");');
            
            await expect(validateNoSymlinks(regularFile, false)).resolves.toBe(true);
        });
    });

    describe('Binary File Detection', () => {
        it('should detect binary files with null bytes', async () => {
            const binaryFile = join(testDir, 'binary.bin');
            const binaryContent = Buffer.from([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00]); // PNG header with null
            await writeFile(binaryFile, binaryContent);
            
            expect(await isBinaryFile(binaryFile)).toBe(true);
        });

        it('should detect text files correctly', async () => {
            const textFile = join(testDir, 'text.js');
            await writeFile(textFile, 'console.log("Hello, World!");');
            
            expect(await isBinaryFile(textFile)).toBe(false);
        });

        it('should handle empty files as text', async () => {
            const emptyFile = join(testDir, 'empty.txt');
            await writeFile(emptyFile, '');
            
            expect(await isBinaryFile(emptyFile)).toBe(false);
        });

        it('should detect files with high non-printable character ratio', async () => {
            const nonPrintableFile = join(testDir, 'nonprintable.dat');
            // Create content with >30% non-printable characters
            const content = Buffer.alloc(100);
            for (let i = 0; i < 100; i++) {
                if (i < 40) {
                    content[i] = Math.floor(Math.random() * 32); // Non-printable
                } else {
                    content[i] = 65 + (i % 26); // Printable letters
                }
            }
            await writeFile(nonPrintableFile, content);
            
            expect(await isBinaryFile(nonPrintableFile)).toBe(true);
        });

        it('should handle files with common whitespace correctly', async () => {
            const whitespaceFile = join(testDir, 'whitespace.txt');
            const content = 'Line 1\nLine 2\tWith tab\rCarriage return\n';
            await writeFile(whitespaceFile, content);
            
            expect(await isBinaryFile(whitespaceFile)).toBe(false);
        });

        it('should handle non-existent files gracefully', async () => {
            const nonExistentFile = join(testDir, 'does-not-exist.bin');
            expect(await isBinaryFile(nonExistentFile)).toBe(false);
        });
    });

    describe('Integration with Fusion Process', () => {
        it('should skip binary files during fusion', async () => {
            // Create a text file and a binary file
            await writeFile('text.js', 'console.log("text");');
            
            const binaryContent = Buffer.from([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00]);
            await writeFile('binary.bin', binaryContent);
            
            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateHtml: false,
                generateMarkdown: false,
                generateText: true,
                parsedFileExtensions: {
                    web: ['.js'],
                    other: ['.bin']
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            // Check that only text file was processed
            const fusionContent = await readFile(join(testDir, 'project-fusioned.txt'), 'utf8');
            expect(fusionContent).toContain('console.log("text");');
            expect(fusionContent).not.toContain('PNG'); // Binary content shouldn't be there
            
            // Check log for binary file skip message
            const logContent = await readFile(result.logFilePath!, 'utf8');
            expect(logContent).toContain('Skipping binary file: binary.bin');
        });

        it('should prevent path traversal in fusion process', async () => {
            // Create a file inside the test directory and one outside
            await writeFile('inside.js', 'console.log("inside");');
            await writeFile(join(outsideDir, 'outside.js'), 'console.log("outside");');
            
            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateHtml: false,
                generateMarkdown: false,
                generateText: true,
                parsedFileExtensions: {
                    web: ['.js']
                }
            };

            // The fusion process should not find files outside the root directory
            // because glob patterns are constrained to the root directory
            const result = await processFusion(config);
            expect(result.success).toBe(true);
            
            const fusionContent = await readFile(join(testDir, 'project-fusioned.txt'), 'utf8');
            expect(fusionContent).toContain('inside'); // File inside should be included
            expect(fusionContent).not.toContain('outside'); // File outside should not be included
        });

        it('should reject symbolic links in fusion process', async () => {
            await writeFile('target.js', 'console.log("target");');
            await symlink(join(testDir, 'target.js'), join(testDir, 'symlink.js'));
            
            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateHtml: false,
                generateMarkdown: false,
                generateText: true,
                parsedFileExtensions: {
                    web: ['.js']
                }
            };

            // The fusion process should skip symbolic links
            const result = await processFusion(config);
            expect(result.success).toBe(true);
            
            // Check that target file was processed but symlink was skipped
            const fusionContent = await readFile(join(testDir, 'project-fusioned.txt'), 'utf8');
            expect(fusionContent).toContain('target.js'); // Target file should be included
            
            // The symlink should cause an error that's logged but doesn't fail the process
            const logContent = await readFile(result.logFilePath!, 'utf8');
            expect(logContent).toContain('symlink.js'); // Should mention the symlink file
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/fluent.test.ts                                   -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for Fluent API
 */
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { join } from 'node:path';
import { writeFile, mkdir, rm } from 'fs-extra';
import { existsSync } from 'node:fs';
import { projectFusion, ProjectFusionBuilder } from '../src/fluent.js';
import { defaultConfig } from '../src/utils.js';

// Mock external dependencies
vi.mock('chalk', () => ({
    default: {
        blue: (str: string) => str,
        green: (str: string) => str,
        yellow: (str: string) => str,
        red: (str: string) => str,
        cyan: (str: string) => str,
        gray: (str: string) => str,
        magenta: (str: string) => str
    }
}));

vi.mock('clipboardy', () => ({
    default: {
        write: vi.fn().mockResolvedValue(undefined)
    }
}));

describe('Fluent API', () => {
    const testDir = join(process.cwd(), 'temp', 'fluent-test');
    const originalCwd = process.cwd();

    beforeEach(async () => {
        // Clear all mocks before each test
        vi.clearAllMocks();
        
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        await mkdir(testDir, { recursive: true });
        process.chdir(testDir);
    });

    afterEach(async () => {
        process.chdir(originalCwd);
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    describe('ProjectFusionBuilder', () => {
        it('should create a new builder instance', () => {
            const builder = new ProjectFusionBuilder();
            expect(builder).toBeInstanceOf(ProjectFusionBuilder);
        });

        it('should support method chaining', () => {
            const builder = projectFusion()
                .root('./src')
                .include(['web'])
                .exclude(['*.test.ts'])
                .maxSize('1MB')
                .output(['md'])
                .name('test-fusion')
                .subdirectories(false)
                .clipboard(false)
                .gitignore(true);

            expect(builder).toBeInstanceOf(ProjectFusionBuilder);
        });

        describe('configuration methods', () => {
            it('should set root directory', () => {
                const builder = projectFusion().root('./src');
                const config = builder.getConfig();
                expect(config.rootDirectory).toBe('./src');
            });

            it('should set working directory', () => {
                const builder = projectFusion().cwd('/custom/cwd');
                const config = builder.getConfig();
                expect(config.cwd).toBe('/custom/cwd');
            });

            it('should set extension groups', () => {
                const builder = projectFusion().include(['web', 'backend']);
                const config = builder.getConfig();
                expect(config.extensionGroups).toEqual(['web', 'backend']);
            });

            it('should set ignore patterns', () => {
                const patterns = ['*.test.ts', 'node_modules/'];
                const builder = projectFusion().exclude(patterns);
                const config = builder.getConfig();
                expect(config.ignorePatterns).toEqual(patterns);
            });

            it('should set max file size from string with MB', () => {
                const builder = projectFusion().maxSize('2MB');
                const config = builder.getConfig();
                expect(config.maxFileSizeKB).toBe(2048);
            });

            it('should set max file size from string with KB', () => {
                const builder = projectFusion().maxSize('512KB');
                const config = builder.getConfig();
                expect(config.maxFileSizeKB).toBe(512);
            });

            it('should set max file size from number', () => {
                const builder = projectFusion().maxSize(1024);
                const config = builder.getConfig();
                expect(config.maxFileSizeKB).toBe(1024);
            });

            it('should throw error for invalid size format', () => {
                expect(() => {
                    projectFusion().maxSize('invalid');
                }).toThrow('Invalid size format');
            });

            it('should set output formats', () => {
                const builder = projectFusion().output(['md', 'html']);
                const config = builder.getConfig();
                expect(config.generateMarkdown).toBe(true);
                expect(config.generateHtml).toBe(true);
                expect(config.generateText).toBe(false);
            });

            it('should set generated file name', () => {
                const builder = projectFusion().name('custom-name');
                const config = builder.getConfig();
                expect(config.generatedFileName).toBe('custom-name');
            });

            it('should set subdirectories flag', () => {
                const builder = projectFusion().subdirectories(false);
                const config = builder.getConfig();
                expect(config.parseSubDirectories).toBe(false);
            });

            it('should set clipboard flag', () => {
                const builder = projectFusion().clipboard(true);
                const config = builder.getConfig();
                expect(config.copyToClipboard).toBe(true);
            });

            it('should set gitignore flag', () => {
                const builder = projectFusion().gitignore(false);
                const config = builder.getConfig();
                expect(config.useGitIgnoreForExcludes).toBe(false);
            });

            it('should add custom extensions for a group', () => {
                const builder = projectFusion().extensions('custom', ['.custom', '.ext']);
                const config = builder.getConfig();
                expect(config.parsedFileExtensions?.custom).toEqual(['.custom', '.ext']);
            });

            it('should set all extensions', () => {
                const extensions = { web: ['.ts'], backend: ['.py'] };
                const builder = projectFusion().allExtensions(extensions);
                const config = builder.getConfig();
                expect(config.parsedFileExtensions).toEqual(extensions);
            });

            it('should apply custom configuration function', () => {
                const builder = projectFusion().configure((options) => {
                    options.maxFileSizeKB = 9999;
                    options.generateText = false;
                });
                const config = builder.getConfig();
                expect(config.maxFileSizeKB).toBe(9999);
                expect(config.generateText).toBe(false);
            });
        });

        describe('reset method', () => {
            it('should reset configuration to defaults', () => {
                const builder = projectFusion()
                    .root('./src')
                    .include(['web'])
                    .maxSize('2MB')
                    .reset();

                const config = builder.getConfig();
                expect(config.rootDirectory).toBeUndefined();
                expect(config.extensionGroups).toBeUndefined();
                expect(config.maxFileSizeKB).toBeUndefined();
            });
        });

        describe('integration tests', () => {
            it('should generate fusion files with basic configuration', async () => {
                // Create test files
                await writeFile('test.js', 'console.log("Hello");');
                await writeFile('test.ts', 'const msg: string = "TypeScript";');

                const result = await projectFusion()
                    .include(['web'])
                    .output(['text'])
                    .generate();

                expect(result.success).toBe(true);
                expect(result.message).toContain('files processed');
            });

            it('should generate fusion files with advanced configuration', async () => {
                // Create test structure
                await mkdir('src', { recursive: true });
                await writeFile('src/app.js', 'console.log("App");');
                await writeFile('src/utils.ts', 'export const util = () => {};');
                await writeFile('test.spec.js', 'console.log("Test");');

                const result = await projectFusion()
                    .root('./src')
                    .include(['web'])
                    .exclude(['*.spec.js'])
                    .maxSize('1MB')
                    .output(['md', 'html'])
                    .name('custom-fusion')
                    .clipboard(false)
                    .generate();

                expect(result.success).toBe(true);
                expect(result.message).toContain('files processed');
            });

            it('should handle empty directory gracefully', async () => {
                const result = await projectFusion()
                    .include(['web'])
                    .generate();

                expect(result.success).toBe(false);
                expect(result.message).toContain('No files found');
            });

            it('should handle file size limits', async () => {
                // Create a small file
                await writeFile('small.js', 'console.log("small");');
                
                const result = await projectFusion()
                    .include(['web'])
                    .maxSize('1KB')
                    .generate();

                expect(result.success).toBe(true);
            });

            it('should handle custom extension groups', async () => {
                await writeFile('script.custom', 'custom file content');
                await writeFile('regular.js', 'console.log("regular");');

                const result = await projectFusion()
                    .extensions('custom', ['.custom'])
                    .include(['custom', 'web']) // Include both custom and web to ensure success
                    .generate();

                expect(result.success).toBe(true);
            });

            it('should handle multiple output formats', async () => {
                await writeFile('test.js', 'console.log("test");');

                const result = await projectFusion()
                    .include(['web'])
                    .output(['text', 'md', 'html'])
                    .generate();

                expect(result.success).toBe(true);
            });
        });

        describe('factory function', () => {
            it('should create builder via projectFusion function', () => {
                const builder = projectFusion();
                expect(builder).toBeInstanceOf(ProjectFusionBuilder);
            });

            it('should create independent builder instances', () => {
                const builder1 = projectFusion().root('./src1');
                const builder2 = projectFusion().root('./src2');

                expect(builder1.getConfig().rootDirectory).toBe('./src1');
                expect(builder2.getConfig().rootDirectory).toBe('./src2');
            });
        });

        describe('error handling', () => {
            it('should handle invalid size units gracefully', () => {
                expect(() => {
                    projectFusion().maxSize('100XB');
                }).toThrow('Invalid size format');
            });

            it('should handle malformed size strings', () => {
                expect(() => {
                    projectFusion().maxSize('not-a-number');
                }).toThrow('Invalid size format');
            });
        });

        describe('edge cases', () => {
            it('should handle subdirectories default parameter', () => {
                const builder = projectFusion().subdirectories();
                const config = builder.getConfig();
                expect(config.parseSubDirectories).toBe(true);
            });

            it('should handle clipboard default parameter', () => {
                const builder = projectFusion().clipboard();
                const config = builder.getConfig();
                expect(config.copyToClipboard).toBe(true);
            });

            it('should handle gitignore default parameter', () => {
                const builder = projectFusion().gitignore();
                const config = builder.getConfig();
                expect(config.useGitIgnoreForExcludes).toBe(true);
            });

            it('should preserve existing extensions when adding custom ones', () => {
                const builder = projectFusion()
                    .extensions('custom1', ['.ext1'])
                    .extensions('custom2', ['.ext2']);
                
                const config = builder.getConfig();
                expect(config.parsedFileExtensions?.custom1).toEqual(['.ext1']);
                expect(config.parsedFileExtensions?.custom2).toEqual(['.ext2']);
                expect(config.parsedFileExtensions?.web).toEqual(defaultConfig.parsedFileExtensions.web);
            });

            it('should handle decimal sizes', () => {
                const builder = projectFusion().maxSize('1.5MB');
                const config = builder.getConfig();
                expect(config.maxFileSizeKB).toBe(1536);
            });

            it('should handle GB units', () => {
                const builder = projectFusion().maxSize('1GB');
                const config = builder.getConfig();
                expect(config.maxFileSizeKB).toBe(1024 * 1024);
            });
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/formats.test.ts                                  -->
<!-- ============================================================ -->
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs-extra';
import path from 'path';
import { processFusion } from '../src/fusion.js';
import { Config } from '../src/types.js';

// Test configuration for multiple output formats
const testConfig: Config = {
  schemaVersion: 1,
  generatedFileName: 'test-output',
  copyToClipboard: false,
  generateText: true,
  generateMarkdown: true,
  generateHtml: true,
  parsedFileExtensions: {
    web: ['.js', '.ts'],
    doc: ['.md']
  },
  parseSubDirectories: false,
  rootDirectory: '.',
  maxFileSizeKB: 1024,
  ignorePatterns: [],
  useGitIgnoreForExcludes: false
};

const testDir = path.resolve('./temp/test-formats');
const originalCwd = process.cwd();

describe('Multiple Format Generation', () => {
  beforeEach(async () => {
    await fs.ensureDir(testDir);
    process.chdir(testDir);
    
    // Create test files
    await fs.writeFile(path.join(testDir, 'test.js'), `
console.log('Hello World');
function greet(name) {
  return \`Hello, \${name}!\`;
}
export { greet };
    `.trim());

    await fs.writeFile(path.join(testDir, 'README.md'), `
# Test Project

This is a **test** project with _markdown_ content.

## Features
- Feature 1
- Feature 2
    `.trim());
  });

  afterEach(async () => {
    process.chdir(originalCwd);
    await fs.remove(testDir);
  });

  it('should generate text format when enabled', async () => {
    const config = { ...testConfig, generateText: true, generateMarkdown: false, generateHtml: false };
    const result = await processFusion(config);
    
    expect(result.success).toBe(true);
    expect(await fs.pathExists('test-output.txt')).toBe(true);
    expect(await fs.pathExists('test-output.md')).toBe(false);
    expect(await fs.pathExists('test-output.html')).toBe(false);
  });

  it('should generate markdown format when enabled', async () => {
    const config = { ...testConfig, generateText: false, generateMarkdown: true, generateHtml: false };
    const result = await processFusion(config);
    
    expect(result.success).toBe(true);
    expect(await fs.pathExists('test-output.txt')).toBe(false);
    expect(await fs.pathExists('test-output.md')).toBe(true);
    expect(await fs.pathExists('test-output.html')).toBe(false);
  });

  it('should generate HTML format when enabled', async () => {
    const config = { ...testConfig, generateText: false, generateMarkdown: false, generateHtml: true };
    const result = await processFusion(config);
    
    expect(result.success).toBe(true);
    expect(await fs.pathExists('test-output.txt')).toBe(false);
    expect(await fs.pathExists('test-output.md')).toBe(false);
    expect(await fs.pathExists('test-output.html')).toBe(true);
  });

  it('should generate multiple formats when enabled', async () => {
    const result = await processFusion(testConfig);
    
    expect(result.success).toBe(true);
    expect(await fs.pathExists('test-output.txt')).toBe(true);
    expect(await fs.pathExists('test-output.md')).toBe(true);
    expect(await fs.pathExists('test-output.html')).toBe(true);
  });

  it('should include proper HTML structure', async () => {
    const result = await processFusion(testConfig);
    
    expect(result.success).toBe(true);
    const htmlContent = await fs.readFile('test-output.html', 'utf8');
    
    expect(htmlContent).toContain('<!DOCTYPE html>');
    expect(htmlContent).toContain('<html lang="en">');
    expect(htmlContent).toContain('<title>Project Fusion - test-formats</title>');
    expect(htmlContent).toContain('üìÅ Table of Contents');
    expect(htmlContent).toContain('üìÑ test.js');
    expect(htmlContent).toContain('üìÑ README.md');
    expect(htmlContent).toContain('</body>');
    expect(htmlContent).toContain('</html>');
  });

  it('should escape HTML in code content', async () => {
    // Add a file with HTML-like content
    await fs.writeFile('html-test.js', `
const html = '<div>Hello & <span>World</span></div>';
console.log(html);
    `.trim());

    const result = await processFusion(testConfig);
    
    expect(result.success).toBe(true);
    const htmlContent = await fs.readFile('test-output.html', 'utf8');
    
    expect(htmlContent).toContain('&lt;div&gt;Hello &amp; &lt;span&gt;World&lt;/span&gt;&lt;/div&gt;');
  });


  it('should include proper metadata in generated files', async () => {
    // Create a package.json with version info
    await fs.writeFile('package.json', JSON.stringify({
      name: 'test-package',
      version: '1.0.0'
    }, null, 2));

    const configWithPackage = {
      ...testConfig,
      parsedFileExtensions: { ...testConfig.parsedFileExtensions, config: ['.json'] }
    };

    const result = await processFusion(configWithPackage);
    
    expect(result.success).toBe(true);
    const txtContent = await fs.readFile('test-output.txt', 'utf8');
    const mdContent = await fs.readFile('test-output.md', 'utf8');
    
    expect(txtContent).toContain('# Generated Project Fusion File');
    expect(txtContent).toContain('# Project: test-formats / test-package v1.0.0');
    expect(txtContent).toContain('# Generated by: project-fusion');
    
    expect(mdContent).toContain('# Generated Project Fusion File');
    expect(mdContent).toContain('**Project:** test-formats / test-package v1.0.0');
    expect(mdContent).toContain('[project-fusion](https://github.com/the99studio/project-fusion)');
  });
});

<!-- ============================================================ -->
<!-- FILE: tests/fusion-coverage.test.ts                          -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Additional tests to achieve 100% coverage for fusion.ts
 */
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { join } from 'node:path';
import { writeFile, mkdir, rm, chmod, symlink } from 'fs-extra';
import { existsSync } from 'node:fs';
import { processFusion } from '../src/fusion.js';
import { defaultConfig } from '../src/utils.js';

describe('Fusion Coverage Tests', () => {
    const testDir = join(process.cwd(), 'temp', 'fusion-coverage-test');
    const originalCwd = process.cwd();

    beforeEach(async () => {
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        await mkdir(testDir, { recursive: true });
        process.chdir(testDir);
    });

    afterEach(async () => {
        process.chdir(originalCwd);
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    describe('processFusion edge cases', () => {
        it('should handle empty directories gracefully', async () => {
            const result = await processFusion(defaultConfig);
            
            expect(result.success).toBe(false);
            expect(result.message).toContain('No files found to process');
        });

        it('should handle very large files (size limit)', async () => {
            // Create a file larger than the default limit (1024 KB)
            const largeContent = 'x'.repeat(1024 * 1024 + 1); // 1MB + 1 byte
            await writeFile('large.txt', largeContent);

            const config = {
                ...defaultConfig,
                maxFileSizeKB: 1024,
                parsedFileExtensions: {
                    ...defaultConfig.parsedFileExtensions,
                    doc: ['.txt']
                }
            };

            const result = await processFusion(config);
            
            // Should still succeed but skip the large file
            expect(result.success).toBe(true);
            expect(result.message).toContain('files processed');
        });

        it('should handle binary files', async () => {
            // Create a binary file
            const binaryContent = Buffer.from([0x00, 0x01, 0x02, 0x03, 0xFF, 0xFE]);
            await writeFile('binary.bin', binaryContent);

            const config = {
                ...defaultConfig,
                parsedFileExtensions: {
                    ...defaultConfig.parsedFileExtensions,
                    other: ['.bin']
                }
            };

            const result = await processFusion(config);
            
            expect(result.success).toBe(true);
            // Binary files should be skipped
        });

        it('should handle files with special characters in names', async () => {
            await writeFile('file with spaces.js', 'console.log("spaces");');
            await writeFile('file-with-dashes.js', 'console.log("dashes");');
            await writeFile('file_with_underscores.js', 'console.log("underscores");');

            const result = await processFusion(defaultConfig);
            
            expect(result.success).toBe(true);
        });

        it('should handle deeply nested directories', async () => {
            // Create deeply nested structure
            await mkdir('level1/level2/level3/level4', { recursive: true });
            await writeFile('level1/level2/level3/level4/deep.js', 'console.log("deep");');

            const result = await processFusion(defaultConfig);
            
            expect(result.success).toBe(true);
        });

        it('should handle permission errors gracefully', async () => {
            if (process.platform === 'win32') {
                // Skip permission tests on Windows as they work differently
                return;
            }

            await writeFile('accessible.js', 'console.log("accessible");');
            await writeFile('restricted.js', 'console.log("restricted");');
            
            try {
                // Remove read permissions
                await chmod('restricted.js', 0o000);

                const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});

                const result = await processFusion(defaultConfig);
                
                // Should continue processing other files
                expect(result.success).toBe(true);
                
                consoleSpy.mockRestore();
                
                // Restore permissions for cleanup
                await chmod('restricted.js', 0o644);
            } catch (error) {
                // If chmod fails on this system, skip the test
                console.warn('Skipping permission test - chmod not supported properly');
            }
        });

        it('should handle symbolic links when they exist', async () => {
            if (process.platform === 'win32') {
                // Skip symlink tests on Windows
                return;
            }

            await writeFile('target.js', 'console.log("target");');
            
            try {
                await symlink('./target.js', 'link.js');
                
                const result = await processFusion(defaultConfig);
                
                expect(result.success).toBe(true);
            } catch (error) {
                // If symlink creation fails (permissions), skip the test
                console.warn('Skipping symlink test due to permissions');
            }
        });

        it('should handle gitignore parsing errors', async () => {
            // Create malformed .gitignore
            await writeFile('.gitignore', '\x00invalid\x00content\x00');
            await writeFile('test.js', 'console.log("test");');

            const result = await processFusion(defaultConfig);
            
            // Should still process files despite gitignore issues
            expect(result.success).toBe(true);
        });

        it('should handle extension groups with undefined extensions', async () => {
            const configWithUndefined = {
                ...defaultConfig,
                parsedFileExtensions: {
                    ...defaultConfig.parsedFileExtensions,
                    // @ts-expect-error - Testing undefined case
                    undefined_group: undefined
                }
            };

            await writeFile('test.js', 'console.log("test");');

            const result = await processFusion(configWithUndefined);
            
            expect(result.success).toBe(true);
        });

        it('should handle fusion options with invalid extension groups', async () => {
            await writeFile('test.js', 'console.log("test");');

            const result = await processFusion(defaultConfig, {
                extensionGroups: ['invalid_group', 'web']
            });
            
            expect(result.success).toBe(true);
        });

        it('should handle HTML generation with special characters', async () => {
            await writeFile('special.html', `<!DOCTYPE html>
<html>
<head>
    <title>Test & "Quotes" and 'Single' quotes</title>
</head>
<body>
    <p>This has <em>emphasis</em> and <strong>strong</strong> text.</p>
    <p>Special chars: &lt; &gt; &amp; " '</p>
</body>
</html>`);

            const result = await processFusion(defaultConfig);
            
            expect(result.success).toBe(true);
            
            // Verify HTML escaping in generated content
            const htmlContent = await import('fs-extra').then(fs => 
                fs.readFile(`${defaultConfig.generatedFileName}.html`, 'utf8')
            );
            expect(htmlContent).toContain('&lt;');
            expect(htmlContent).toContain('&gt;');
            expect(htmlContent).toContain('&amp;');
        });

        it('should handle markdown generation with code blocks', async () => {
            await writeFile('example.md', `# Example

\`\`\`javascript
console.log("Hello, World!");
\`\`\`

Some **bold** and *italic* text.

- List item 1
- List item 2

| Table | Header |
|-------|--------|
| Cell  | Value  |
`);

            const result = await processFusion(defaultConfig);
            
            expect(result.success).toBe(true);
        });

        it('should handle very long file names', async () => {
            const longName = 'a'.repeat(200) + '.js';
            await writeFile(longName, 'console.log("long name");');

            const result = await processFusion(defaultConfig);
            
            expect(result.success).toBe(true);
        });

        it('should handle files with no extension', async () => {
            await writeFile('Makefile', 'all:\n\techo "make target"');
            await writeFile('README', '# This is a readme file');
            // Also add a regular file to ensure fusion succeeds
            await writeFile('test.js', 'console.log("test");');

            const result = await processFusion(defaultConfig);
            
            expect(result.success).toBe(true);
        });

        it('should handle directory traversal in ignore patterns', async () => {
            await mkdir('safe/directory', { recursive: true });
            await writeFile('safe/directory/file.js', 'console.log("safe");');

            const configWithTraversal = {
                ...defaultConfig,
                ignorePatterns: ['../../../etc/passwd', 'safe/../unsafe']
            };

            const result = await processFusion(configWithTraversal);
            
            expect(result.success).toBe(true);
        });

        it('should handle benchmark tracking edge cases', async () => {
            await writeFile('test.js', 'console.log("benchmark test");');

            // Test with very quick operations to test benchmark precision
            const startTime = Date.now();
            const result = await processFusion(defaultConfig);
            const endTime = Date.now();
            
            expect(result.success).toBe(true);
            expect(endTime - startTime).toBeGreaterThanOrEqual(0);
        });

        it('should handle concurrent file processing', async () => {
            // Create many files to test concurrent processing
            const promises = [];
            for (let i = 0; i < 50; i++) {
                promises.push(writeFile(`file${i}.js`, `console.log("File ${i}");`));
            }
            await Promise.all(promises);

            const result = await processFusion(defaultConfig);
            
            expect(result.success).toBe(true);
            expect(result.message).toContain('50 files processed');
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/index.test.ts                                    -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for main index.ts exports
 */
import { describe, it, expect } from 'vitest';

describe('Index Exports', () => {
    it('should export core functionality from benchmark', async () => {
        const { BenchmarkTracker } = await import('../src/index.js');
        expect(BenchmarkTracker).toBeDefined();
        expect(typeof BenchmarkTracker).toBe('function');
    });

    it('should export core functionality from fusion', async () => {
        const { processFusion } = await import('../src/index.js');
        expect(processFusion).toBeDefined();
        expect(typeof processFusion).toBe('function');
    });

    it('should export programmatic API', async () => {
        const { 
            createConfig,
            fusionAPI,
            runFusion
        } = await import('../src/index.js');
        
        expect(createConfig).toBeDefined();
        expect(typeof createConfig).toBe('function');
        expect(fusionAPI).toBeDefined();
        expect(typeof fusionAPI).toBe('function');
        expect(runFusion).toBeDefined();
        expect(typeof runFusion).toBe('function');
    });

    it('should export schemas', async () => {
        const { ConfigSchemaV1 } = await import('../src/index.js');
        expect(ConfigSchemaV1).toBeDefined();
    });

    it('should export types', async () => {
        const { 
            FusionError,
            isValidExtensionGroup,
            isNonEmptyArray
        } = await import('../src/index.js');
        
        expect(FusionError).toBeDefined();
        expect(typeof FusionError).toBe('function');
        expect(isValidExtensionGroup).toBeDefined();
        expect(typeof isValidExtensionGroup).toBe('function');
        expect(isNonEmptyArray).toBeDefined();
        expect(typeof isNonEmptyArray).toBe('function');
    });

    it('should export utilities', async () => {
        const { 
            defaultConfig,
            loadConfig,
            getExtensionsFromGroups,
            formatTimestamp
        } = await import('../src/index.js');
        
        expect(defaultConfig).toBeDefined();
        expect(typeof defaultConfig).toBe('object');
        expect(loadConfig).toBeDefined();
        expect(typeof loadConfig).toBe('function');
        expect(getExtensionsFromGroups).toBeDefined();
        expect(typeof getExtensionsFromGroups).toBe('function');
        expect(formatTimestamp).toBeDefined();
        expect(typeof formatTimestamp).toBe('function');
    });

    it('should have consistent exports structure', async () => {
        const exports = await import('../src/index.js');
        
        // Verify no undefined exports
        const exportKeys = Object.keys(exports);
        expect(exportKeys.length).toBeGreaterThan(0);
        
        for (const key of exportKeys) {
            expect(exports[key as keyof typeof exports]).toBeDefined();
        }
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/integration.test.ts                              -->
<!-- ============================================================ -->
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs-extra';
import path from 'path';
import { processFusion } from '../src/fusion.js';
import { defaultConfig } from '../src/utils.js';
import { Config } from '../src/types.js';

describe('integration', () => {
  const testDir = path.join(process.cwd(), 'temp', 'test-integration');
  const originalCwd = process.cwd();

  beforeEach(async () => {
    // Clean up and create test directory
    await fs.remove(testDir);
    await fs.ensureDir(testDir);
    
    // Change to test directory
    process.chdir(testDir);
  });

  afterEach(async () => {
    // Restore original directory
    process.chdir(originalCwd);
    
    // Clean up test directory
    await fs.remove(testDir);
  });

  describe('processFusion', () => {
    it('should process fusion successfully with test files', async () => {
      // Create test files
      await fs.writeFile('test.js', 'console.log("Hello World");');
      await fs.writeFile('test.ts', 'const message: string = "TypeScript";');
      await fs.writeFile('Dockerfile', 'FROM node:18\nCOPY . .\nRUN npm install');
      
      // Create config for test
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        parsedFileExtensions: {
          web: ['.js', '.ts']
        }
      };

      const result = await processFusion(testConfig);

      expect(result.success).toBe(true);
      expect(result.message).toContain('2 files processed');
      expect(result.fusionFilePath).toBeDefined();
      
      // Check if fusion files were created
      expect(await fs.pathExists(result.fusionFilePath!)).toBe(true);
      expect(await fs.pathExists(result.fusionFilePath!.replace('.txt', '.md'))).toBe(true);
      
      // Check content of fusion file
      const fusionContent = await fs.readFile(result.fusionFilePath!, 'utf8');
      expect(fusionContent).toContain('test.js');
      expect(fusionContent).toContain('test.ts');
      expect(fusionContent).toContain('console.log("Hello World");');
      expect(fusionContent).toContain('const message: string = "TypeScript";');
      expect(fusionContent).not.toContain('Dockerfile'); // Not in web extensions
    });

    it('should handle empty directory gracefully', async () => {
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false
      };

      const result = await processFusion(testConfig);

      expect(result.success).toBe(false);
      expect(result.message).toContain('No files found to process');
    });

    it('should respect ignore patterns', async () => {
      // Create test files
      await fs.writeFile('test.js', 'console.log("Hello World");');
      await fs.writeFile('ignored.js', 'console.log("Should be ignored");');
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        parsedFileExtensions: {
          web: ['.js']
        },
        ignorePatterns: ['ignored.js']
      };

      const result = await processFusion(testConfig);

      expect(result.success).toBe(true);
      expect(result.message).toContain('1 files processed'); // Only test.js
      
      const fusionContent = await fs.readFile(result.fusionFilePath!, 'utf8');
      expect(fusionContent).toContain('test.js');
      expect(fusionContent).not.toContain('ignored.js');
    });

    it('should filter files by extensions correctly', async () => {
      // Create test files with different extensions
      await fs.writeFile('app.js', 'console.log("JavaScript");');
      await fs.writeFile('app.ts', 'const app: string = "TypeScript";');
      await fs.writeFile('app.py', 'print("Python")');
      await fs.writeFile('config.json', '{"test": true}');
      
      // Test web extensions only
      const webConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        parsedFileExtensions: {
          web: ['.js', '.ts']
        }
      };

      const webResult = await processFusion(webConfig);
      expect(webResult.success).toBe(true);
      expect(webResult.message).toContain('2 files processed');
      
      const webContent = await fs.readFile(webResult.fusionFilePath!, 'utf8');
      expect(webContent).toContain('app.js');
      expect(webContent).toContain('app.ts');
      expect(webContent).not.toContain('app.py');
      expect(webContent).not.toContain('config.json');

      // Test backend extensions only
      const backendConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        parsedFileExtensions: {
          backend: ['.py']
        }
      };

      const backendResult = await processFusion(backendConfig);
      expect(backendResult.success).toBe(true);
      expect(backendResult.message).toContain('1 files processed');
      
      const backendContent = await fs.readFile(backendResult.fusionFilePath!, 'utf8');
      expect(backendContent).toContain('app.py');
      expect(backendContent).not.toContain('app.js');
      expect(backendContent).not.toContain('app.ts');
    });

    it('should respect .gitignore patterns', async () => {
      // Create test files
      await fs.writeFile('app.js', 'console.log("main app");');
      await fs.writeFile('build.js', 'console.log("build file");');
      await fs.ensureDir('node_modules');
      await fs.writeFile('node_modules/lib.js', 'console.log("dependency");');
      await fs.ensureDir('dist');
      await fs.writeFile('dist/output.js', 'console.log("compiled");');
      
      // Create .gitignore
      await fs.writeFile('.gitignore', 'node_modules/\ndist/\nbuild.js');
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: true,
        useGitIgnoreForExcludes: true,
        parsedFileExtensions: {
          web: ['.js']
        }
      };

      const result = await processFusion(testConfig);
      expect(result.success).toBe(true);
      expect(result.message).toContain('1 files processed'); // Only app.js
      
      const fusionContent = await fs.readFile(result.fusionFilePath!, 'utf8');
      expect(fusionContent).toContain('app.js');
      expect(fusionContent).not.toContain('build.js');
      expect(fusionContent).not.toContain('node_modules');
      expect(fusionContent).not.toContain('dist');
    });

    it('should skip files larger than maxFileSizeKB', async () => {
      // Create small file
      await fs.writeFile('small.js', 'console.log("small");');
      
      // Create large file (2KB)
      const largeContent = 'console.log("large");' + 'x'.repeat(2000);
      await fs.writeFile('large.js', largeContent);
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        maxFileSizeKB: 1, // 1KB limit
        parsedFileExtensions: {
          web: ['.js']
        }
      };

      const result = await processFusion(testConfig);
      expect(result.success).toBe(true);
      expect(result.message).toContain('1 files processed'); // Only small.js
      
      const fusionContent = await fs.readFile(result.fusionFilePath!, 'utf8');
      expect(fusionContent).toContain('small.js');
      expect(fusionContent).not.toContain('large.js');
    });

    it('should respect non-recursive directory parsing', async () => {
      // Create files in root
      await fs.writeFile('root.js', 'console.log("root");');
      
      // Create files in subdirectory
      await fs.ensureDir('sub');
      await fs.writeFile('sub/nested.js', 'console.log("nested");');
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false, // Non-recursive
        parsedFileExtensions: {
          web: ['.js']
        }
      };

      const result = await processFusion(testConfig);
      expect(result.success).toBe(true);
      expect(result.message).toContain('1 files processed'); // Only root.js
      
      const fusionContent = await fs.readFile(result.fusionFilePath!, 'utf8');
      expect(fusionContent).toContain('root.js');
      expect(fusionContent).not.toContain('nested.js');
    });

    it('should generate HTML output when enabled', async () => {
      // Create test files
      await fs.writeFile('test.js', 'console.log("Hello HTML");');
      
      const testConfig: Config = {
        ...defaultConfig,
        rootDirectory: '.',
        parseSubDirectories: false,
        generateHtml: true,
        parsedFileExtensions: {
          web: ['.js']
        }
      };

      const result = await processFusion(testConfig);
      expect(result.success).toBe(true);
      
      // Check HTML file was created
      const htmlPath = result.fusionFilePath!.replace('.txt', '.html');
      expect(await fs.pathExists(htmlPath)).toBe(true);
      
      const htmlContent = await fs.readFile(htmlPath, 'utf8');
      expect(htmlContent).toContain('<!DOCTYPE html>');
      expect(htmlContent).toContain('<html lang="en">');
      expect(htmlContent).toContain('test.js');
      expect(htmlContent).toContain('console.log(&quot;Hello HTML&quot;);');
    });
  });
});

<!-- ============================================================ -->
<!-- FILE: tests/memory-fs.test.ts                                -->
<!-- ============================================================ -->
/**
 * Tests for MemoryFileSystemAdapter
 */
import { describe, it, expect, beforeEach } from 'vitest';
import { MemoryFileSystemAdapter } from '../src/adapters/file-system.js';
import { createFilePath } from '../src/types.js';

describe('MemoryFileSystemAdapter', () => {
    let fs: MemoryFileSystemAdapter;

    beforeEach(() => {
        fs = new MemoryFileSystemAdapter();
    });

    describe('File Operations', () => {
        it('should write and read files', async () => {
            const filePath = createFilePath('/test/file.txt');
            const content = 'Hello, World!';

            await fs.writeFile(filePath, content);
            const result = await fs.readFile(filePath);

            expect(result).toBe(content);
        });

        it('should append to files', async () => {
            const filePath = createFilePath('/test/file.txt');
            
            await fs.writeFile(filePath, 'Hello, ');
            await fs.appendFile(filePath, 'World!');
            const result = await fs.readFile(filePath);

            expect(result).toBe('Hello, World!');
        });

        it('should append to non-existent files', async () => {
            const filePath = createFilePath('/new/file.txt');
            
            await fs.appendFile(filePath, 'New content');
            const result = await fs.readFile(filePath);

            expect(result).toBe('New content');
        });

        it('should throw error when reading non-existent file', async () => {
            const filePath = createFilePath('/missing/file.txt');
            
            await expect(fs.readFile(filePath)).rejects.toThrow('File not found');
        });

        it('should read files as buffer', async () => {
            const filePath = createFilePath('/test/file.txt');
            const content = 'Hello, Buffer!';

            await fs.writeFile(filePath, content);
            const buffer = await fs.readBuffer(filePath);

            expect(buffer).toBeInstanceOf(Buffer);
            expect(buffer.toString('utf8')).toBe(content);
        });
    });

    describe('File Stats', () => {
        it('should return stats for files', async () => {
            const filePath = createFilePath('/test/file.txt');
            const content = 'Hello, World!';

            await fs.writeFile(filePath, content);
            const stats = await fs.stat(filePath);

            expect(stats.isFile).toBe(true);
            expect(stats.isDirectory).toBe(false);
            expect(stats.isSymbolicLink).toBe(false);
            expect(stats.size).toBe(Buffer.byteLength(content, 'utf8'));
        });

        it('should return stats for directories', async () => {
            const dirPath = createFilePath('/test/dir');
            
            await fs.ensureDir(dirPath);
            const stats = await fs.stat(dirPath);

            expect(stats.isFile).toBe(false);
            expect(stats.isDirectory).toBe(true);
            expect(stats.isSymbolicLink).toBe(false);
            expect(stats.size).toBe(0);
        });

        it('should throw error for non-existent paths', async () => {
            const filePath = createFilePath('/missing/file.txt');
            
            await expect(fs.stat(filePath)).rejects.toThrow('File not found');
        });

        it('should support lstat (same as stat for memory fs)', async () => {
            const filePath = createFilePath('/test/file.txt');
            
            await fs.writeFile(filePath, 'content');
            const stats = await fs.lstat(filePath);

            expect(stats.isFile).toBe(true);
            expect(stats.isSymbolicLink).toBe(false);
        });
    });

    describe('Directory Operations', () => {
        it('should ensure directories exist', async () => {
            const dirPath = '/test/nested/deep';
            
            await fs.ensureDir(dirPath);
            
            expect(await fs.exists(createFilePath(dirPath))).toBe(true);
        });

        it('should check file existence', async () => {
            const filePath = createFilePath('/test/file.txt');
            
            expect(await fs.exists(filePath)).toBe(false);
            
            await fs.writeFile(filePath, 'content');
            expect(await fs.exists(filePath)).toBe(true);
        });

        it('should check directory existence', async () => {
            const dirPath = createFilePath('/test/dir');
            
            expect(await fs.exists(dirPath)).toBe(false);
            
            await fs.ensureDir(dirPath);
            expect(await fs.exists(dirPath)).toBe(true);
        });
    });

    describe('Glob Operations', () => {
        beforeEach(async () => {
            await fs.writeFile(createFilePath('/test/file1.js'), 'content1');
            await fs.writeFile(createFilePath('/test/file2.ts'), 'content2');
            await fs.writeFile(createFilePath('/test/nested/file3.js'), 'content3');
            await fs.ensureDir('/test/empty-dir');
        });

        it('should glob all files and directories', async () => {
            const results = await fs.glob('*');
            
            expect(results.length).toBeGreaterThan(0);
            expect(results.map(p => p.toString())).toContain('/test/file1.js');
            expect(results.map(p => p.toString())).toContain('/test/file2.ts');
        });

        it('should glob files only when nodir option is set', async () => {
            const results = await fs.glob('*', { nodir: true });
            
            const paths = results.map(p => p.toString());
            expect(paths).toContain('/test/file1.js');
            expect(paths).not.toContain('/test/empty-dir');
        });

        it('should glob with follow option (no effect in memory fs)', async () => {
            const results = await fs.glob('*', { follow: true });
            
            expect(results.length).toBeGreaterThan(0);
        });
    });

    describe('Helper Methods', () => {
        it('should add files with addFile helper', async () => {
            fs.addFile('/test/file.txt', 'content');
            
            await expect(fs.readFile(createFilePath('/test/file.txt'))).resolves.toBe('content');
        });

        it('should get all files with getFiles', async () => {
            await fs.writeFile(createFilePath('/file1.txt'), 'content1');
            await fs.writeFile(createFilePath('/file2.txt'), 'content2');
            
            const files = fs.getFiles();
            
            expect(files.size).toBe(2);
            expect(files.get('/file1.txt')).toBe('content1');
            expect(files.get('/file2.txt')).toBe('content2');
        });

        it('should clear all files and directories', async () => {
            await fs.writeFile(createFilePath('/file.txt'), 'content');
            await fs.ensureDir('/dir');
            
            expect(await fs.exists(createFilePath('/file.txt'))).toBe(true);
            expect(await fs.exists(createFilePath('/dir'))).toBe(true);
            
            fs.clear();
            
            expect(await fs.exists(createFilePath('/file.txt'))).toBe(false);
            expect(await fs.exists(createFilePath('/dir'))).toBe(false);
        });
    });

    describe('Auto Directory Creation', () => {
        it('should auto-create parent directories when writing files', async () => {
            const filePath = createFilePath('/deep/nested/path/file.txt');
            
            await fs.writeFile(filePath, 'content');
            
            expect(await fs.exists(createFilePath('/deep/nested/path'))).toBe(true);
            expect(await fs.readFile(filePath)).toBe('content');
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/path-traversal-edge-cases.test.ts                -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Advanced path traversal tests for the new path.relative validation
 */
import { describe, it, expect } from 'vitest';
import { validateSecurePath } from '../src/utils.js';
import { FusionError } from '../src/types.js';
import path from 'node:path';
import os from 'node:os';

describe('Path Traversal Edge Cases', () => {
    describe('Windows Path Prefix Collision', () => {
        // These tests validate the fix for Windows path prefix collision cases
        it('should prevent C:\\foo vs C:\\foobar confusion', () => {
            // Skip on non-Windows for path format consistency
            if (os.platform() !== 'win32') {
                // Simulate Windows-style paths for testing
                const mockRoot = 'C:\\foo';
                const maliciousPath = 'C:\\foobar\\evil.txt';
                
                // Mock path.resolve to simulate Windows behavior
                const originalResolve = path.resolve;
                const originalRelative = path.relative;
                
                // Test with actual path.relative (the fix)
                try {
                    const rel = path.relative(mockRoot, maliciousPath);
                    expect(rel.startsWith('..')).toBe(true);
                    
                    // This should throw with the new validation
                    expect(() => {
                        // Simulate the new validation logic
                        if (rel.startsWith('..') || path.isAbsolute(rel)) {
                            throw new FusionError(
                                `Path traversal detected`,
                                'PATH_TRAVERSAL',
                                'error',
                                { relativePath: rel }
                            );
                        }
                    }).toThrow(FusionError);
                } finally {
                    // Restore original functions
                }
            } else {
                // Real Windows test
                const mockRoot = 'C:\\foo';
                const maliciousPath = 'C:\\foobar\\evil.txt';
                
                expect(() => validateSecurePath(maliciousPath, mockRoot)).toThrow(FusionError);
            }
        });

        it('should handle case-insensitive filesystem confusion', () => {
            // Test case variations that could confuse startsWith but not path.relative
            const root = '/Users/test';
            const variations = [
                '/users/test/../secrets.txt', // Different case
                '/Users/Test/../secrets.txt', // Different case
                '/Users/test/../Test/secrets.txt' // Case variation in escape
            ];

            variations.forEach(maliciousPath => {
                expect(() => validateSecurePath(maliciousPath, root)).toThrow(FusionError);
            });
        });
    });

    describe('Unicode and Normalization Edge Cases', () => {
        it('should handle Unicode normalization attacks', () => {
            const root = '/safe/directory';
            
            // Unicode characters that could normalize to path separators
            const unicodePaths = [
                '/safe/directory\u002e\u002e/evil.txt', // Unicode dots
                '/safe/directory\uff0e\uff0e/evil.txt', // Fullwidth dots
                '/safe/directory\u2024\u2024/evil.txt', // One dot leader
                '/safe/directory\u2025\u2025/evil.txt', // Two dot leader
            ];

            unicodePaths.forEach(maliciousPath => {
                try {
                    validateSecurePath(maliciousPath, root);
                    // If it doesn't throw, verify it's actually safe
                    const rel = path.relative(root, path.resolve(maliciousPath));
                    expect(rel.startsWith('..')).toBe(false);
                } catch (error) {
                    expect(error).toBeInstanceOf(FusionError);
                    expect((error as FusionError).code).toBe('PATH_TRAVERSAL');
                }
            });
        });

        it('should handle mixed normalization forms', () => {
            const root = '/safe/directory';
            
            // Test different Unicode normalization forms (NFKC vs NFD)
            const normalizedPaths = [
                '/safe/directory/../sensitive/file.txt', // Standard path traversal
                // Note: Unicode normalization in directory names doesn't create path traversal
                // unless they normalize to actual path separators or dots
                '/evil/directory/file.txt' // Different root entirely
            ];

            normalizedPaths.forEach(maliciousPath => {
                expect(() => validateSecurePath(maliciousPath, root)).toThrow(FusionError);
            });
            
            // Verify that Unicode directory names within safe bounds are allowed
            const safePaths = [
                '/safe/directory/\u0065\u0301/file.txt', // √© as e + combining acute
                '/safe/directory/\u00E9/file.txt' // √© as single character
            ];
            
            safePaths.forEach(safePath => {
                expect(() => validateSecurePath(safePath, root)).not.toThrow();
            });
        });
    });

    describe('Path Component Edge Cases', () => {
        it('should handle double dots split across components', () => {
            const root = '/safe/directory';
            
            // Paths where .. is split or disguised
            const tricky = [
                '/safe/directory/./../../evil.txt',
                '/safe/directory/subdir/../../evil.txt',
                '/safe/directory/.//../evil.txt',
                '/safe/directory/.///../evil.txt'
            ];

            tricky.forEach(maliciousPath => {
                expect(() => validateSecurePath(maliciousPath, root)).toThrow(FusionError);
            });
        });

        it('should handle long path segments', () => {
            const root = '/safe/directory';
            const longSegment = 'a'.repeat(1000);
            
            const longPaths = [
                `/safe/directory/../${longSegment}/evil.txt`,
                `/safe/directory/${longSegment}/../evil.txt`,
                `/${longSegment}/../safe/directory/evil.txt`
            ];

            longPaths.forEach(maliciousPath => {
                try {
                    validateSecurePath(maliciousPath, root);
                    // If it passes, make sure it's actually safe
                    const rel = path.relative(root, path.resolve(maliciousPath));
                    expect(rel.startsWith('..')).toBe(false);
                } catch (error) {
                    expect(error).toBeInstanceOf(FusionError);
                }
            });
        });
    });

    describe('Platform-Specific Edge Cases', () => {
        it('should handle Windows UNC paths', () => {
            if (os.platform() === 'win32') {
                const root = 'C:\\safe\\directory';
                const uncPaths = [
                    '\\\\server\\share\\evil.txt',
                    '\\\\?\\C:\\evil.txt',
                    '\\\\?\\UNC\\server\\share\\evil.txt'
                ];

                uncPaths.forEach(maliciousPath => {
                    expect(() => validateSecurePath(maliciousPath, root)).toThrow(FusionError);
                });
            }
        });

        it('should handle mixed separators', () => {
            const root = '/safe/directory';
            const mixedPaths = [
                '/safe/directory\\..\\evil.txt',
                '/safe\\directory\\..\\evil.txt',
                '\\safe\\directory\\..\\evil.txt'
            ];

            mixedPaths.forEach(maliciousPath => {
                try {
                    validateSecurePath(maliciousPath, root);
                    // If it doesn't throw, verify safety
                    const rel = path.relative(root, path.resolve(maliciousPath));
                    expect(rel.startsWith('..')).toBe(false);
                } catch (error) {
                    expect(error).toBeInstanceOf(FusionError);
                }
            });
        });
    });

    describe('Regression Tests for Old vs New Method', () => {
        it('should catch cases that startsWith missed', () => {
            const testCases = [
                {
                    root: '/app',
                    malicious: '/application/evil.txt', // /app is prefix but not parent
                    description: 'prefix collision'
                },
                {
                    root: '/usr/local',
                    malicious: '/usr/local-backup/evil.txt',
                    description: 'hyphenated confusion'
                },
                {
                    root: 'C:\\Users\\test',
                    malicious: 'C:\\Users\\test-backup\\evil.txt',
                    description: 'Windows prefix with suffix'
                }
            ];

            testCases.forEach(({ root, malicious, description }) => {
                // The new method should catch these
                expect(() => validateSecurePath(malicious, root)).toThrow(FusionError);
                
                // Verify with direct path.relative check
                const rel = path.relative(root, path.resolve(malicious));
                expect(rel.startsWith('..') || path.isAbsolute(rel)).toBe(true);
            });
        });

        it('should still allow legitimate paths', () => {
            const root = '/safe/directory';
            const legitimatePaths = [
                '/safe/directory/file.txt',
                '/safe/directory/sub/file.txt',
                '/safe/directory/sub/deep/file.txt',
                '/safe/directory/.hidden/file.txt'
            ];

            legitimatePaths.forEach(safePath => {
                expect(() => validateSecurePath(safePath, root)).not.toThrow();
                
                const result = validateSecurePath(safePath, root);
                expect(result).toBe(path.resolve(safePath));
                
                // Verify with path.relative
                const rel = path.relative(root, result);
                expect(rel.startsWith('..')).toBe(false);
                expect(path.isAbsolute(rel)).toBe(false);
            });
        });
    });

    describe('Error Context Validation', () => {
        it('should include relativePath in error context', () => {
            const root = '/safe/directory';
            const malicious = '/evil.txt';

            try {
                validateSecurePath(malicious, root);
                expect.fail('Should have thrown');
            } catch (error) {
                expect(error).toBeInstanceOf(FusionError);
                const fusionError = error as FusionError;
                expect(fusionError.context).toHaveProperty('relativePath');
                expect(fusionError.context.relativePath).toBeDefined();
            }
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/plugin-system.test.ts                            -->
<!-- ============================================================ -->
/**
 * Tests for Plugin System
 */
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { join } from 'node:path';
import { 
    PluginManager, 
    BasePlugin, 
    createPlugin,
    type Plugin,
    type PluginMetadata,
    type OutputStrategy
} from '../src/plugins/plugin-system.js';
import { MemoryFileSystemAdapter } from '../src/adapters/file-system.js';
import { createFilePath, type Config } from '../src/types.js';
import { defaultConfig } from '../src/utils.js';

describe('Plugin System', () => {
    let pluginManager: PluginManager;
    let fs: MemoryFileSystemAdapter;
    let config: Config;

    beforeEach(() => {
        fs = new MemoryFileSystemAdapter();
        pluginManager = new PluginManager(fs);
        config = { ...defaultConfig };
    });

    describe('PluginManager', () => {
        describe('Plugin Registration', () => {
            it('should register and retrieve plugins', () => {
                const plugin = createPlugin({
                    name: 'test-plugin',
                    version: '1.0.0',
                    description: 'Test plugin'
                });

                pluginManager.registerPlugin(plugin);
                const retrieved = pluginManager.getPlugin('test-plugin');

                expect(retrieved).toBe(plugin);
            });

            it('should unregister plugins', () => {
                const plugin = createPlugin({
                    name: 'test-plugin',
                    version: '1.0.0',
                    description: 'Test plugin'
                });

                pluginManager.registerPlugin(plugin);
                pluginManager.unregisterPlugin('test-plugin');
                
                expect(pluginManager.getPlugin('test-plugin')).toBeUndefined();
            });

            it('should configure plugins', () => {
                const plugin = createPlugin({
                    name: 'test-plugin',
                    version: '1.0.0',
                    description: 'Test plugin'
                });

                pluginManager.registerPlugin(plugin);
                pluginManager.configurePlugin('test-plugin', {
                    name: 'test-plugin',
                    enabled: false,
                    options: { key: 'value' }
                });

                const enabledPlugins = pluginManager.getEnabledPlugins();
                expect(enabledPlugins).not.toContain(plugin);
            });

            it('should list plugin metadata', () => {
                const plugin1 = createPlugin({
                    name: 'plugin1',
                    version: '1.0.0',
                    description: 'First plugin'
                });
                const plugin2 = createPlugin({
                    name: 'plugin2',
                    version: '2.0.0',
                    description: 'Second plugin'
                });

                pluginManager.registerPlugin(plugin1);
                pluginManager.registerPlugin(plugin2);

                const metadata = pluginManager.listPlugins();
                expect(metadata).toHaveLength(2);
                expect(metadata[0].name).toBe('plugin1');
                expect(metadata[1].name).toBe('plugin2');
            });
        });

        describe('Plugin Loading', () => {
            it('should handle plugin loading errors gracefully', async () => {
                const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

                // Try to load non-existent plugin
                await expect(pluginManager.loadPlugin('/non/existent/plugin.js')).rejects.toThrow();

                consoleSpy.mockRestore();
            });

            it('should load plugins from directory', async () => {
                const pluginsDir = '/plugins';
                
                // Create a mock plugin file
                fs.addFile('/plugins/test-plugin.js', `
                    export default {
                        metadata: {
                            name: 'test-plugin',
                            version: '1.0.0',
                            description: 'Test plugin'
                        }
                    };
                `);

                const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});

                await pluginManager.loadPluginsFromDirectory(pluginsDir);

                consoleSpy.mockRestore();
            });

            it('should handle missing plugins directory', async () => {
                await pluginManager.loadPluginsFromDirectory('/non/existent/dir');
                // Should not throw
            });
        });

        describe('Plugin Lifecycle', () => {
            it('should initialize plugins', async () => {
                const initSpy = vi.fn();
                const plugin = createPlugin({
                    name: 'test-plugin',
                    version: '1.0.0',
                    description: 'Test plugin'
                }, {
                    initialize: initSpy
                });

                pluginManager.registerPlugin(plugin);
                await pluginManager.initializePlugins(config);

                expect(initSpy).toHaveBeenCalledWith(config);
            });

            it('should cleanup plugins', async () => {
                const cleanupSpy = vi.fn();
                const plugin = createPlugin({
                    name: 'test-plugin',
                    version: '1.0.0',
                    description: 'Test plugin'
                }, {
                    cleanup: cleanupSpy
                });

                pluginManager.registerPlugin(plugin);
                await pluginManager.cleanupPlugins();

                expect(cleanupSpy).toHaveBeenCalled();
            });

            it('should handle plugin initialization errors', async () => {
                const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
                const plugin = createPlugin({
                    name: 'failing-plugin',
                    version: '1.0.0',
                    description: 'Failing plugin'
                }, {
                    initialize: async () => { throw new Error('Init failed'); }
                });

                pluginManager.registerPlugin(plugin);
                await pluginManager.initializePlugins(config);

                expect(consoleSpy).toHaveBeenCalled();
                consoleSpy.mockRestore();
            });

            it('should handle plugin cleanup errors', async () => {
                const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
                const plugin = createPlugin({
                    name: 'failing-plugin',
                    version: '1.0.0',
                    description: 'Failing plugin'
                }, {
                    cleanup: async () => { throw new Error('Cleanup failed'); }
                });

                pluginManager.registerPlugin(plugin);
                await pluginManager.cleanupPlugins();

                expect(consoleSpy).toHaveBeenCalled();
                consoleSpy.mockRestore();
            });
        });

        describe('Plugin Hooks', () => {
            it('should execute beforeFileProcessing hooks', async () => {
                const hookSpy = vi.fn().mockResolvedValue({
                    content: 'modified',
                    relativePath: 'test.js',
                    path: createFilePath('/test.js'),
                    size: 8
                });

                const plugin = createPlugin({
                    name: 'test-plugin',
                    version: '1.0.0',
                    description: 'Test plugin'
                }, {
                    beforeFileProcessing: hookSpy
                });

                pluginManager.registerPlugin(plugin);

                const fileInfo = {
                    content: 'original',
                    relativePath: 'test.js',
                    path: createFilePath('/test.js'),
                    size: 8
                };

                const result = await pluginManager.executeBeforeFileProcessing(fileInfo, config);

                expect(hookSpy).toHaveBeenCalledWith(fileInfo, config);
                expect(result?.content).toBe('modified');
            });

            it('should filter out files when hook returns null', async () => {
                const plugin = createPlugin({
                    name: 'filter-plugin',
                    version: '1.0.0',
                    description: 'Filter plugin'
                }, {
                    beforeFileProcessing: async () => null
                });

                pluginManager.registerPlugin(plugin);

                const fileInfo = {
                    content: 'content',
                    relativePath: 'test.js',
                    path: createFilePath('/test.js'),
                    size: 7
                };

                const result = await pluginManager.executeBeforeFileProcessing(fileInfo, config);
                expect(result).toBeNull();
            });

            it('should execute afterFileProcessing hooks', async () => {
                const hookSpy = vi.fn().mockResolvedValue('processed content');

                const plugin = createPlugin({
                    name: 'test-plugin',
                    version: '1.0.0',
                    description: 'Test plugin'
                }, {
                    afterFileProcessing: hookSpy
                });

                pluginManager.registerPlugin(plugin);

                const fileInfo = {
                    content: 'original',
                    relativePath: 'test.js',
                    path: createFilePath('/test.js'),
                    size: 8
                };

                const result = await pluginManager.executeAfterFileProcessing(fileInfo, 'content', config);

                expect(hookSpy).toHaveBeenCalledWith(fileInfo, 'content', config);
                expect(result).toBe('processed content');
            });

            it('should execute beforeFusion hooks', async () => {
                const hookSpy = vi.fn().mockResolvedValue({
                    config: { ...config, maxFileSizeKB: 100 },
                    filesToProcess: []
                });

                const plugin = createPlugin({
                    name: 'test-plugin',
                    version: '1.0.0',
                    description: 'Test plugin'
                }, {
                    beforeFusion: hookSpy
                });

                pluginManager.registerPlugin(plugin);

                const result = await pluginManager.executeBeforeFusion(config, []);

                expect(hookSpy).toHaveBeenCalledWith(config, []);
                expect(result.config.maxFileSizeKB).toBe(100);
            });

            it('should execute afterFusion hooks', async () => {
                const hookSpy = vi.fn().mockResolvedValue({ modified: true });

                const plugin = createPlugin({
                    name: 'test-plugin',
                    version: '1.0.0',
                    description: 'Test plugin'
                }, {
                    afterFusion: hookSpy
                });

                pluginManager.registerPlugin(plugin);

                const result = await pluginManager.executeAfterFusion({ original: true }, config);

                expect(hookSpy).toHaveBeenCalledWith({ original: true }, config);
                expect(result.modified).toBe(true);
            });

            it('should handle hook errors gracefully', async () => {
                const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
                
                const plugin = createPlugin({
                    name: 'failing-plugin',
                    version: '1.0.0',
                    description: 'Failing plugin'
                }, {
                    beforeFileProcessing: async () => { throw new Error('Hook failed'); }
                });

                pluginManager.registerPlugin(plugin);

                const fileInfo = {
                    content: 'content',
                    relativePath: 'test.js',
                    path: createFilePath('/test.js'),
                    size: 7
                };

                const result = await pluginManager.executeBeforeFileProcessing(fileInfo, config);
                expect(result).toBe(fileInfo);
                expect(consoleSpy).toHaveBeenCalled();

                consoleSpy.mockRestore();
            });
        });

        describe('Output Strategies', () => {
            it('should get additional output strategies from plugins', () => {
                const strategy: OutputStrategy = {
                    name: 'custom',
                    extension: '.custom',
                    generateHeader: () => 'header',
                    processFile: () => 'processed'
                };

                const plugin = createPlugin({
                    name: 'strategy-plugin',
                    version: '1.0.0',
                    description: 'Strategy plugin'
                }, {
                    registerOutputStrategies: () => [strategy]
                });

                pluginManager.registerPlugin(plugin);

                const strategies = pluginManager.getAdditionalOutputStrategies();
                expect(strategies).toContain(strategy);
            });

            it('should handle output strategy errors', () => {
                const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
                
                const plugin = createPlugin({
                    name: 'failing-strategy-plugin',
                    version: '1.0.0',
                    description: 'Failing strategy plugin'
                }, {
                    registerOutputStrategies: () => { throw new Error('Strategy failed'); }
                });

                pluginManager.registerPlugin(plugin);

                const strategies = pluginManager.getAdditionalOutputStrategies();
                expect(strategies).toEqual([]);
                expect(consoleSpy).toHaveBeenCalled();

                consoleSpy.mockRestore();
            });
        });

        describe('File Extensions', () => {
            it('should get additional file extensions from plugins', () => {
                const extensions = { custom: ['.custom1', '.custom2'] };

                const plugin = createPlugin({
                    name: 'extension-plugin',
                    version: '1.0.0',
                    description: 'Extension plugin'
                }, {
                    registerFileExtensions: () => extensions
                });

                pluginManager.registerPlugin(plugin);

                const result = pluginManager.getAdditionalFileExtensions();
                expect(result).toEqual(extensions);
            });

            it('should handle file extension errors', () => {
                const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
                
                const plugin = createPlugin({
                    name: 'failing-extension-plugin',
                    version: '1.0.0',
                    description: 'Failing extension plugin'
                }, {
                    registerFileExtensions: () => { throw new Error('Extension failed'); }
                });

                pluginManager.registerPlugin(plugin);

                const result = pluginManager.getAdditionalFileExtensions();
                expect(result).toEqual({});
                expect(consoleSpy).toHaveBeenCalled();

                consoleSpy.mockRestore();
            });
        });
    });

    describe('BasePlugin', () => {
        it('should create plugins with BasePlugin class', () => {
            class TestPlugin extends BasePlugin {
                metadata = {
                    name: 'test-plugin',
                    version: '1.0.0',
                    description: 'Test plugin'
                };
            }

            const plugin = new TestPlugin();
            expect(plugin.metadata.name).toBe('test-plugin');
        });

        it('should support optional lifecycle methods', async () => {
            class TestPlugin extends BasePlugin {
                metadata = {
                    name: 'test-plugin',
                    version: '1.0.0',
                    description: 'Test plugin'
                };

                initCalled = false;
                cleanupCalled = false;

                async initialize() {
                    this.initCalled = true;
                }

                async cleanup() {
                    this.cleanupCalled = true;
                }
            }

            const plugin = new TestPlugin();
            
            if (plugin.initialize) await plugin.initialize(config);
            if (plugin.cleanup) await plugin.cleanup();

            expect(plugin.initCalled).toBe(true);
            expect(plugin.cleanupCalled).toBe(true);
        });
    });

    describe('createPlugin helper', () => {
        it('should create plugins with metadata only', () => {
            const metadata: PluginMetadata = {
                name: 'simple-plugin',
                version: '1.0.0',
                description: 'Simple plugin'
            };

            const plugin = createPlugin(metadata);
            expect(plugin.metadata).toEqual(metadata);
        });

        it('should create plugins with hooks', () => {
            const metadata: PluginMetadata = {
                name: 'hook-plugin',
                version: '1.0.0',
                description: 'Hook plugin'
            };

            const beforeFileProcessing = vi.fn();
            const plugin = createPlugin(metadata, { beforeFileProcessing });

            expect(plugin.metadata).toEqual(metadata);
            expect(plugin.beforeFileProcessing).toBe(beforeFileProcessing);
        });

        it('should support all optional metadata fields', () => {
            const metadata: PluginMetadata = {
                name: 'full-plugin',
                version: '1.0.0',
                description: 'Full plugin',
                author: 'Test Author',
                homepage: 'https://example.com'
            };

            const plugin = createPlugin(metadata);
            expect(plugin.metadata.author).toBe('Test Author');
            expect(plugin.metadata.homepage).toBe('https://example.com');
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/property-based.test.ts                           -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Property-based tests for Project Fusion using fast-check
 */
import { describe, it, expect } from 'vitest';
import fc from 'fast-check';
import { getExtensionsFromGroups, defaultConfig } from '../src/utils.js';
import { isValidExtensionGroup } from '../src/types.js';
import type { Config } from '../src/types.js';

describe('Property-Based Tests', () => {
    describe('Extension Filtering', () => {
        // Generator for valid extension groups
        const validExtensionGroupArb = fc.constantFrom(
            'web', 'backend', 'config', 'cpp', 'scripts', 'godot', 'doc'
        );

        // Generator for file extensions
        const extensionArb = fc.string({ minLength: 1, maxLength: 10 })
            .filter(s => s.startsWith('.') && s.length > 1)
            .map(s => s.startsWith('.') ? s : `.${s}`)
            .filter(s => !s.includes(' ') && !s.includes('\n'));

        // Generator for config with extension groups
        const configArb = fc.record({
            parsedFileExtensions: fc.record({
                web: fc.array(extensionArb, { minLength: 0, maxLength: 20 }),
                backend: fc.array(extensionArb, { minLength: 0, maxLength: 20 }),
                config: fc.array(extensionArb, { minLength: 0, maxLength: 20 }),
                cpp: fc.array(extensionArb, { minLength: 0, maxLength: 20 }),
                scripts: fc.array(extensionArb, { minLength: 0, maxLength: 20 }),
                godot: fc.array(extensionArb, { minLength: 0, maxLength: 20 }),
                doc: fc.array(extensionArb, { minLength: 0, maxLength: 20 })
            })
        }, { requiredKeys: ['parsedFileExtensions'] }) as fc.Arbitrary<Partial<Config>>;

        it('should always return valid extensions when given valid groups', () => {
            fc.assert(fc.property(
                fc.array(validExtensionGroupArb, { minLength: 1, maxLength: 7 }),
                (groups) => {
                    const config = { ...defaultConfig };
                    const extensions = getExtensionsFromGroups(config, groups);
                    
                    // All returned extensions should start with a dot
                    expect(extensions.every(ext => ext.startsWith('.'))).toBe(true);
                    
                    // Extensions should be strings
                    expect(extensions.every(ext => typeof ext === 'string')).toBe(true);
                    
                    // Should not contain empty strings
                    expect(extensions.every(ext => ext.length > 1)).toBe(true);
                    
                    // Function may return duplicates if same group is specified multiple times
                    // This is acceptable behavior
                    expect(extensions.length).toBeGreaterThanOrEqual(0);
                }
            ));
        });

        it('should handle empty group arrays gracefully', () => {
            fc.assert(fc.property(
                configArb,
                (partialConfig) => {
                    const config = { ...defaultConfig, ...partialConfig };
                    const extensions = getExtensionsFromGroups(config, []);
                    
                    // Empty groups should return all extensions
                    expect(Array.isArray(extensions)).toBe(true);
                    expect(extensions.length).toBeGreaterThanOrEqual(0);
                }
            ));
        });

        it('should handle unknown groups by ignoring them', () => {
            fc.assert(fc.property(
                fc.array(fc.string(), { minLength: 1, maxLength: 10 })
                    .filter(groups => groups.every(g => !isValidExtensionGroup(g))),
                (unknownGroups) => {
                    const config = { ...defaultConfig };
                    const extensions = getExtensionsFromGroups(config, unknownGroups);
                    
                    // Unknown groups should result in empty array
                    expect(extensions).toEqual([]);
                }
            ));
        });

        it('should handle mixed valid and invalid groups', () => {
            fc.assert(fc.property(
                fc.tuple(
                    fc.array(validExtensionGroupArb, { minLength: 1, maxLength: 3 }),
                    fc.array(fc.string().filter(s => !isValidExtensionGroup(s)), { minLength: 1, maxLength: 3 })
                ),
                ([validGroups, invalidGroups]) => {
                    const config = { ...defaultConfig };
                    const mixedGroups = [...validGroups, ...invalidGroups];
                    const extensions = getExtensionsFromGroups(config, mixedGroups);
                    
                    // Should only return extensions from valid groups
                    const validOnlyExtensions = getExtensionsFromGroups(config, validGroups);
                    expect(extensions).toEqual(validOnlyExtensions);
                }
            ));
        });

        it('should handle duplicate groups by including extensions multiple times', () => {
            fc.assert(fc.property(
                fc.array(validExtensionGroupArb, { minLength: 2, maxLength: 7 }),
                (groups) => {
                    const config = { ...defaultConfig };
                    const extensions = getExtensionsFromGroups(config, groups);
                    
                    // Extensions may contain duplicates if same group is specified multiple times
                    // This is the current behavior and is acceptable
                    expect(Array.isArray(extensions)).toBe(true);
                    expect(extensions.every(ext => typeof ext === 'string')).toBe(true);
                }
            ));
        });

        it('should handle custom config extensions properly', () => {
            fc.assert(fc.property(
                configArb,
                validExtensionGroupArb,
                (partialConfig, group) => {
                    const config = { ...defaultConfig, ...partialConfig } as Config;
                    const extensions = getExtensionsFromGroups(config, [group]);
                    
                    // Extensions should come from the specified group in config
                    const expectedExtensions = config.parsedFileExtensions[group] || [];
                    expect(extensions).toEqual([...expectedExtensions]);
                }
            ));
        });
    });

    describe('Extension Group Validation', () => {
        it('should correctly identify valid extension groups', () => {
            fc.assert(fc.property(
                fc.string().filter(s => {
                    // Filter out object prototype properties that could cause issues
                    const prototypeMethods = ['__proto__', 'constructor', 'prototype', 'toString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable'];
                    return !prototypeMethods.includes(s);
                }),
                (input) => {
                    const isValid = isValidExtensionGroup(input);
                    const validGroups = ['web', 'backend', 'config', 'cpp', 'scripts', 'godot', 'doc'];
                    
                    if (validGroups.includes(input)) {
                        expect(isValid).toBe(true);
                    } else {
                        expect(isValid).toBe(false);
                    }
                }
            ));
        });

        // Test that valid groups are consistently valid
        it('should have stable validation for known valid groups', () => {
            const validGroups = ['web', 'backend', 'config', 'cpp', 'scripts', 'godot', 'doc'];
            
            fc.assert(fc.property(
                fc.constantFrom(...validGroups),
                (group) => {
                    expect(isValidExtensionGroup(group)).toBe(true);
                }
            ));
        });
    });

    describe('Config Merging Properties', () => {
        // Generator for partial configs
        const partialConfigArb = fc.record({
            generateText: fc.boolean(),
            generateMarkdown: fc.boolean(),
            generateHtml: fc.boolean(),
            maxFileSizeKB: fc.integer({ min: 1, max: 10000 }),
            parseSubDirectories: fc.boolean(),
            copyToClipboard: fc.boolean(),
            useGitIgnoreForExcludes: fc.boolean(),
            generatedFileName: fc.string({ minLength: 1, maxLength: 50 })
                .filter(s => !s.includes('/') && !s.includes('\\') && s.trim().length > 0),
            ignorePatterns: fc.array(fc.string(), { maxLength: 10 })
        }, { requiredKeys: [] });

        it('should preserve user-provided values when merging configs', () => {
            fc.assert(fc.property(
                partialConfigArb,
                (partialConfig) => {
                    // This tests the behavior conceptually - actual merging happens in api.ts
                    // We're testing that the principle holds: user values should override defaults
                    const merged = { ...defaultConfig, ...partialConfig };
                    
                    // User-provided values should be preserved
                    Object.keys(partialConfig).forEach(key => {
                        expect(merged[key as keyof typeof merged]).toEqual(
                            partialConfig[key as keyof typeof partialConfig]
                        );
                    });
                    
                    // Required fields should always be present
                    expect(merged).toHaveProperty('schemaVersion');
                    expect(merged).toHaveProperty('parsedFileExtensions');
                    expect(merged).toHaveProperty('rootDirectory');
                }
            ));
        });
    });

    describe('Path and File Handling Properties', () => {
        // Generator for file paths (simplified)
        const filePathArb = fc.string({ minLength: 1, maxLength: 100 })
            .filter(s => !s.includes('\0') && s.trim().length > 0);

        const extensionArb = fc.constantFrom('.js', '.ts', '.py', '.java', '.go', '.rs', '.html', '.css');

        it('should handle various file paths consistently', () => {
            fc.assert(fc.property(
                filePathArb,
                extensionArb,
                (basePath, extension) => {
                    const fullPath = basePath + extension;
                    
                    // Basic properties that should always hold
                    expect(typeof fullPath).toBe('string');
                    expect(fullPath.length).toBeGreaterThan(0);
                    expect(fullPath.endsWith(extension)).toBe(true);
                }
            ));
        });
    });

    describe('Error Handling Properties', () => {
        it('should handle edge cases in extension processing', () => {
            fc.assert(fc.property(
                fc.array(fc.string(), { maxLength: 20 }),
                (arbitraryGroups) => {
                    const config = { ...defaultConfig };
                    
                    // Should never throw an error, even with arbitrary input
                    expect(() => {
                        const result = getExtensionsFromGroups(config, arbitraryGroups);
                        expect(Array.isArray(result)).toBe(true);
                    }).not.toThrow();
                }
            ));
        });

        it('should handle empty and null-like inputs gracefully', () => {
            const config = { ...defaultConfig };
            
            // Test various edge cases
            expect(() => getExtensionsFromGroups(config, [])).not.toThrow();
            expect(() => getExtensionsFromGroups(config, [''])).not.toThrow();
            expect(() => getExtensionsFromGroups(config, [' '])).not.toThrow();
            
            // Results should be predictable
            expect(getExtensionsFromGroups(config, [])).toEqual(
                expect.arrayContaining([])
            );
        });
    });

    describe('Performance Properties', () => {
        it('should handle large extension groups efficiently', () => {
            // Move validExtensionGroupArb here to fix scoping issue
            const validExtensionGroupArb = fc.constantFrom(
                'web', 'backend', 'config', 'cpp', 'scripts', 'godot', 'doc'
            );
            
            fc.assert(fc.property(
                fc.array(validExtensionGroupArb, { minLength: 1, maxLength: 7 }),
                (groups) => {
                    const config = { ...defaultConfig };
                    const startTime = Date.now();
                    
                    // Should complete quickly even with all groups
                    const extensions = getExtensionsFromGroups(config, groups);
                    const endTime = Date.now();
                    
                    // Should complete in reasonable time (less than 10ms)
                    expect(endTime - startTime).toBeLessThan(10);
                    expect(Array.isArray(extensions)).toBe(true);
                }
            ));
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/schema.test.ts                                   -->
<!-- ============================================================ -->
import { describe, it, expect } from 'vitest';
import { ConfigSchemaV1 } from '../src/schema.js';
import { defaultConfig } from '../src/utils.js';

describe('schema', () => {
  describe('ConfigSchemaV1', () => {
    it('should validate default config', () => {
      const result = ConfigSchemaV1.safeParse(defaultConfig);
      expect(result.success).toBe(true);
    });

    it('should validate minimal valid config', () => {
      const minimalConfig = {
        schemaVersion: 1,
        generatedFileName: "test-fusion",
        copyToClipboard: false,
        generateText: true,
        generateMarkdown: true,
        generateHtml: false,
        parsedFileExtensions: {
          web: [".js", ".ts"]
        },
        rootDirectory: ".",
        parseSubDirectories: true,
        maxFileSizeKB: 1024,
        ignorePatterns: [],
        useGitIgnoreForExcludes: true
      };

      const result = ConfigSchemaV1.safeParse(minimalConfig);
      expect(result.success).toBe(true);
    });

    it('should reject config with invalid schema version', () => {
      const invalidConfig = {
        ...defaultConfig,
        schemaVersion: 2
      };

      const result = ConfigSchemaV1.safeParse(invalidConfig);
      expect(result.success).toBe(false);
    });

    it('should reject config with missing required fields', () => {
      const invalidConfig = {
        schemaVersion: 1
        // All other fields have defaults, so this should actually pass
      };

      const result = ConfigSchemaV1.safeParse(invalidConfig);
      expect(result.success).toBe(true); // Schema has defaults for all fields
    });

    it('should reject config with invalid copyToClipboard type', () => {
      const invalidConfig = {
        ...defaultConfig,
        copyToClipboard: "true" // Should be boolean
      };

      const result = ConfigSchemaV1.safeParse(invalidConfig);
      expect(result.success).toBe(false);
    });

    it('should validate config with copyToClipboard true', () => {
      const validConfig = {
        ...defaultConfig,
        copyToClipboard: true
      };

      const result = ConfigSchemaV1.safeParse(validConfig);
      expect(result.success).toBe(true);
    });

    it('should validate config with HTML generation enabled', () => {
      const validConfig = {
        ...defaultConfig,
        generateHtml: true
      };

      const result = ConfigSchemaV1.safeParse(validConfig);
      expect(result.success).toBe(true);
    });

    it('should validate config with HTML generation enabled', () => {
      const validConfig = {
        ...defaultConfig,
        generateHtml: true
      };

      const result = ConfigSchemaV1.safeParse(validConfig);
      expect(result.success).toBe(true);
    });
  });
});

<!-- ============================================================ -->
<!-- FILE: tests/security.test.ts                                 -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Security tests for Project Fusion
 */
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { join } from 'node:path';
import { writeFile, mkdir, rm } from 'node:fs/promises';
import { existsSync } from 'node:fs';
import { processFusion } from '../src/fusion.js';
import { defaultConfig } from '../src/utils.js';

describe('Security Tests', () => {
    const testDir = join(process.cwd(), 'temp', 'security-test');

    beforeEach(async () => {
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        await mkdir(testDir, { recursive: true });
        process.chdir(testDir);
    });

    afterEach(async () => {
        process.chdir(join(testDir, '..', '..'));
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    describe('HTML Injection Protection', () => {
        it('should escape HTML in file content', async () => {
            // Create malicious HTML content
            const maliciousContent = `
console.log("test");
<script>alert('XSS')</script>
<img src="x" onerror="alert('XSS')">
&lt;div&gt;Already escaped&lt;/div&gt;
"quotes" & 'apostrophes'
`;

            await writeFile('malicious.js', maliciousContent);

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateHtml: true,
                generateText: false,
                generateMarkdown: false,
                parsedFileExtensions: {
                    web: ['.js']
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            // Read generated HTML
            const htmlContent = await import('fs').then(fs => 
                fs.promises.readFile(join(testDir, 'project-fusioned.html'), 'utf8')
            );

            // Verify all dangerous HTML is escaped
            expect(htmlContent).toContain('&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;');
            expect(htmlContent).toContain('&lt;img src=&quot;x&quot; onerror=&quot;alert(&#39;XSS&#39;)&quot;&gt;');
            expect(htmlContent).toContain('&amp;lt;div&amp;gt;Already escaped&amp;lt;/div&amp;gt;');
            expect(htmlContent).toContain('&quot;quotes&quot; &amp; &#39;apostrophes&#39;');

            // Verify no unescaped dangerous content
            expect(htmlContent).not.toContain('<script>alert(');
            expect(htmlContent).not.toContain('<img src="x"');
            expect(htmlContent).not.toContain('onerror="alert(');
        });

        it('should escape HTML in file paths', async () => {
            // Create files with dangerous names
            const dangerousFileName = '<script>alert("path").js';
            const safeFileName = 'safe-file.js';

            await writeFile(safeFileName, 'console.log("safe");');
            
            // We can't actually create a file with < > in the name on most filesystems
            // So we'll test by creating a file and then simulating the dangerous path
            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateHtml: true,
                generateText: false,
                generateMarkdown: false,
                parsedFileExtensions: {
                    web: ['.js']
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            // Read generated HTML
            const htmlContent = await import('fs').then(fs => 
                fs.promises.readFile(join(testDir, 'project-fusioned.html'), 'utf8')
            );

            // File paths should be HTML-escaped in titles and TOC
            expect(htmlContent).toContain('safe-file.js');
            
            // Verify no unescaped angle brackets that could be dangerous
            const tocSection = htmlContent.split('<div class="toc">')[1]?.split('</div>')[0];
            const titleSections = htmlContent.split('<h2>üìÑ ');
            
            expect(tocSection).toBeDefined();
            expect(titleSections.length).toBeGreaterThan(1);
            
            // All file references should not contain unescaped HTML
            titleSections.slice(1).forEach(section => {
                const title = section.split('</h2>')[0];
                expect(title).not.toContain('<script');
                expect(title).not.toContain('onerror=');
            });
        });

        it('should escape HTML in project title and version', async () => {
            // Create a package.json with dangerous content
            const dangerousPackageJson = {
                name: '<script>alert("name")</script>',
                version: '1.0.0<img src=x onerror=alert("version")>',
                description: 'Test package'
            };

            await writeFile('package.json', JSON.stringify(dangerousPackageJson, null, 2));
            await writeFile('test.js', 'console.log("test");');

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateHtml: true,
                generateText: false,
                generateMarkdown: false,
                parsedFileExtensions: {
                    web: ['.js']
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            // Read generated HTML
            const htmlContent = await import('fs').then(fs => 
                fs.promises.readFile(join(testDir, 'project-fusioned.html'), 'utf8')
            );

            // Project title should be escaped
            expect(htmlContent).toContain('&lt;script&gt;alert(&quot;name&quot;)&lt;/script&gt;');
            expect(htmlContent).toContain('1.0.0&lt;img src=x onerror=alert(&quot;version&quot;)&gt;');
            
            // Verify no unescaped dangerous content in header
            const headerSection = htmlContent.split('<div class="header">')[1]?.split('</div>')[0];
            expect(headerSection).toBeDefined();
            expect(headerSection).not.toContain('<script>alert(');
            expect(headerSection).not.toContain('<img src=x');
            // The dangerous tags are escaped, making them safe
            expect(headerSection).not.toContain('<script>');
            expect(headerSection).not.toContain('<img ');
        });
    });

    describe('Path Traversal Protection', () => {
        it('should handle relative paths safely', async () => {
            await writeFile('normal.js', 'console.log("normal");');
            
            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateHtml: true,
                parseSubDirectories: true,
                parsedFileExtensions: {
                    web: ['.js']
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            // Should only process files within the root directory
            const htmlContent = await import('fs').then(fs => 
                fs.promises.readFile(join(testDir, 'project-fusioned.html'), 'utf8')
            );

            expect(htmlContent).toContain('normal.js');
            // Should not escape outside the test directory
            expect(htmlContent).not.toContain('../../');
            expect(htmlContent).not.toContain('../security.test.ts');
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/snapshots.test.ts                                -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Snapshot tests for verifying MD/HTML format output
 */
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { join } from 'node:path';
import { writeFile, mkdir, rm, readFile } from 'node:fs/promises';
import { existsSync } from 'node:fs';
import { processFusion } from '../src/fusion.js';
import { defaultConfig } from '../src/utils.js';

describe('Format Snapshot Tests', () => {
    const testDir = join(process.cwd(), 'temp', 'snapshot-test');
    const originalCwd = process.cwd();

    beforeEach(async () => {
        // Clean up and create test directory
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        await mkdir(testDir, { recursive: true });
        process.chdir(testDir);
    });

    afterEach(async () => {
        process.chdir(originalCwd);
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    describe('Markdown Format Snapshots', () => {
        it('should generate consistent markdown format for JavaScript files', async () => {
            // Create sample JavaScript files
            await writeFile('index.js', `// Main application entry point
const express = require('express');
const app = express();

app.get('/', (req, res) => {
    res.send('Hello, World!');
});

app.listen(3000, () => {
    console.log('Server running on port 3000');
});`);

            await writeFile('utils.js', `// Utility functions
function formatDate(date) {
    return date.toISOString().split('T')[0];
}

function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

module.exports = { formatDate, capitalize };`);

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateText: false,
                generateMarkdown: true,
                generateHtml: false,
                generatedFileName: 'test-fusion',
                parsedFileExtensions: {
                    web: ['.js']
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            const mdContent = await readFile('test-fusion.md', 'utf8');
            
            // Normalize timestamps for consistent snapshots
            const normalizedMd = mdContent
                .replace(/\*\*Generated:\*\* [^\n]+/g, '**Generated:** [TIMESTAMP]')
                .replace(/\*\*UTC:\*\* [^\n]+/g, '**UTC:** [UTC_TIMESTAMP]');
            
            // Test structure and content
            expect(normalizedMd).toMatchSnapshot('javascript-files.md');
        });

        it('should generate consistent markdown format for TypeScript files', async () => {
            await writeFile('types.ts', `// Type definitions
export interface User {
    id: number;
    name: string;
    email: string;
    createdAt: Date;
}

export type UserRole = 'admin' | 'user' | 'moderator';

export interface CreateUserRequest {
    name: string;
    email: string;
    role?: UserRole;
}`);

            await writeFile('service.ts', `// User service
import { User, CreateUserRequest, UserRole } from './types.js';

export class UserService {
    private users: User[] = [];
    private nextId = 1;

    createUser(request: CreateUserRequest): User {
        const user: User = {
            id: this.nextId++,
            name: request.name,
            email: request.email,
            createdAt: new Date()
        };
        
        this.users.push(user);
        return user;
    }

    findUser(id: number): User | undefined {
        return this.users.find(user => user.id === id);
    }
}`);

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateText: false,
                generateMarkdown: true,
                generateHtml: false,
                generatedFileName: 'typescript-fusion',
                parsedFileExtensions: {
                    web: ['.ts']
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            const mdContent = await readFile('typescript-fusion.md', 'utf8');
            
            // Normalize timestamps for consistent snapshots
            const normalizedMd = mdContent
                .replace(/\*\*Generated:\*\* [^\n]+/g, '**Generated:** [TIMESTAMP]')
                .replace(/\*\*UTC:\*\* [^\n]+/g, '**UTC:** [UTC_TIMESTAMP]');
                
            expect(normalizedMd).toMatchSnapshot('typescript-files.md');
        });

        it('should generate consistent markdown format for mixed file types', async () => {
            await writeFile('config.json', `{
  "name": "test-project",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.0",
    "typescript": "^5.0.0"
  },
  "scripts": {
    "start": "node index.js",
    "build": "tsc"
  }
}`);

            await writeFile('README.md', `# Test Project

This is a test project for snapshot testing.

## Features

- **Fast**: Built with performance in mind
- **Secure**: Follows security best practices
- **Reliable**: Comprehensive test coverage

## Installation

\`\`\`bash
npm install
npm start
\`\`\`

## License

MIT License`);

            await writeFile('script.sh', `#!/bin/bash
# Deployment script

echo "Starting deployment..."

# Build the project
npm run build

# Run tests
npm test

# Deploy to production
echo "Deploying to production..."
rsync -av dist/ user@server:/var/www/app/

echo "Deployment complete!"`);

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateText: false,
                generateMarkdown: true,
                generateHtml: false,
                generatedFileName: 'mixed-fusion',
                parsedFileExtensions: {
                    config: ['.json'],
                    doc: ['.md'],
                    scripts: ['.sh']
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            const mdContent = await readFile('mixed-fusion.md', 'utf8');
            
            // Normalize timestamps for consistent snapshots
            const normalizedMd = mdContent
                .replace(/\*\*Generated:\*\* [^\n]+/g, '**Generated:** [TIMESTAMP]')
                .replace(/\*\*UTC:\*\* [^\n]+/g, '**UTC:** [UTC_TIMESTAMP]');
                
            expect(normalizedMd).toMatchSnapshot('mixed-files.md');
        });
    });

    describe('HTML Format Snapshots', () => {
        it('should generate consistent HTML format for JavaScript files', async () => {
            await writeFile('app.js', `// Simple Express application
const express = require('express');
const path = require('path');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(express.json());
app.use(express.static('public'));

// Routes
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

app.get('/api/health', (req, res) => {
    res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Start server
app.listen(PORT, () => {
    console.log(\`Server running on http://localhost:\${PORT}\`);
});`);

            await writeFile('helpers.js', `// Helper functions
const crypto = require('crypto');

/**
 * Generate a random ID
 * @param {number} length - Length of the ID
 * @returns {string} Random ID
 */
function generateId(length = 8) {
    return crypto.randomBytes(length).toString('hex');
}

/**
 * Validate email format
 * @param {string} email - Email to validate
 * @returns {boolean} True if valid
 */
function isValidEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
}

module.exports = {
    generateId,
    isValidEmail
};`);

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateText: false,
                generateMarkdown: false,
                generateHtml: true,
                generatedFileName: 'html-test',
                parsedFileExtensions: {
                    web: ['.js']
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            const htmlContent = await readFile('html-test.html', 'utf8');
            
            // Normalize timestamps for consistent snapshots
            const normalizedHtml = htmlContent
                .replace(/Generated:<\/strong> [^<]+/g, 'Generated:</strong> [TIMESTAMP]')
                .replace(/UTC:<\/strong> [^<]+/g, 'UTC:</strong> [UTC_TIMESTAMP]');
            
            expect(normalizedHtml).toMatchSnapshot('javascript-files.html');
        });

        it('should generate consistent HTML format with proper escaping', async () => {
            await writeFile('template.html', `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Template</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        .header {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Welcome to Test App</h1>
            <p>This is a <strong>test</strong> application with <em>HTML</em> content.</p>
        </div>
        
        <main>
            <h2>Features & Benefits</h2>
            <ul>
                <li>Fast & reliable</li>
                <li>Secure by design</li>
                <li>Easy to use</li>
            </ul>
            
            <p>Contact us at: <a href="mailto:test@example.com">test@example.com</a></p>
        </main>
    </div>
    
    <script>
        console.log('Page loaded successfully!');
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM ready');
        });
    </script>
</body>
</html>`);

            await writeFile('styles.css', `/* Global styles */
* {
    box-sizing: border-box;
}

body {
    margin: 0;
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    line-height: 1.6;
    color: #333;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 20px;
}

/* Button styles */
.btn {
    display: inline-block;
    padding: 12px 24px;
    background: #007bff;
    color: white;
    text-decoration: none;
    border-radius: 4px;
    transition: background 0.3s ease;
}

.btn:hover {
    background: #0056b3;
}

/* Responsive design */
@media (max-width: 768px) {
    .container {
        padding: 0 10px;
    }
    
    .btn {
        display: block;
        text-align: center;
        margin: 10px 0;
    }
}`);

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateText: false,
                generateMarkdown: false,
                generateHtml: true,
                generatedFileName: 'html-escape-test',
                parsedFileExtensions: {
                    web: ['.html', '.css']
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            const htmlContent = await readFile('html-escape-test.html', 'utf8');
            
            // Normalize timestamps
            const normalizedHtml = htmlContent
                .replace(/Generated:<\/strong> [^<]+/g, 'Generated:</strong> [TIMESTAMP]')
                .replace(/UTC:<\/strong> [^<]+/g, 'UTC:</strong> [UTC_TIMESTAMP]');
            
            expect(normalizedHtml).toMatchSnapshot('html-with-escaping.html');
        });

        it('should generate HTML with proper table of contents structure', async () => {
            await mkdir('api', { recursive: true });
            await mkdir('components', { recursive: true });
            await mkdir('utils', { recursive: true });
            
            await writeFile('api/users.js', 'const users = [];');
            await writeFile('api/posts.js', 'const posts = [];');
            await writeFile('components/Header.js', 'export default function Header() {}');
            await writeFile('components/Footer.js', 'export default function Footer() {}');
            await writeFile('utils/database.js', 'class Database {}');

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateText: false,
                generateMarkdown: false,
                generateHtml: true,
                generatedFileName: 'toc-test',
                parsedFileExtensions: {
                    web: ['.js']
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            const htmlContent = await readFile('toc-test.html', 'utf8');
            
            // Check TOC structure
            expect(htmlContent).toContain('<div class="toc">');
            expect(htmlContent).toContain('<h2>üìÅ Table of Contents</h2>');
            expect(htmlContent).toContain('href="#api-users-js"');
            expect(htmlContent).toContain('href="#components-header-js"');
            
            // Normalize and snapshot
            const normalizedHtml = htmlContent
                .replace(/Generated:<\/strong> [^<]+/g, 'Generated:</strong> [TIMESTAMP]')
                .replace(/UTC:<\/strong> [^<]+/g, 'UTC:</strong> [UTC_TIMESTAMP]');
            
            expect(normalizedHtml).toMatchSnapshot('html-with-toc.html');
        });
    });

    describe('Cross-Format Consistency', () => {
        it('should maintain content consistency between markdown and HTML formats', async () => {
            await writeFile('example.ts', `// Example TypeScript module
export interface Config {
    apiUrl: string;
    timeout: number;
    retries: number;
}

export class ApiClient {
    constructor(private config: Config) {}
    
    async get<T>(path: string): Promise<T> {
        const response = await fetch(\`\${this.config.apiUrl}\${path}\`);
        if (!response.ok) {
            throw new Error(\`HTTP \${response.status}\`);
        }
        return response.json();
    }
}`);

            const config = {
                ...defaultConfig,
                rootDirectory: testDir,
                generateText: false,
                generateMarkdown: true,
                generateHtml: true,
                generatedFileName: 'consistency-test',
                parsedFileExtensions: {
                    web: ['.ts']
                }
            };

            const result = await processFusion(config);
            expect(result.success).toBe(true);

            const mdContent = await readFile('consistency-test.md', 'utf8');
            const htmlContent = await readFile('consistency-test.html', 'utf8');

            // Both should contain the same source code
            expect(mdContent).toContain('export interface Config');
            expect(htmlContent).toContain('export interface Config');
            
            expect(mdContent).toContain('export class ApiClient');
            expect(htmlContent).toContain('export class ApiClient');
            
            // Both should reference the same file
            expect(mdContent).toContain('example.ts');
            expect(htmlContent).toContain('example.ts');
            
            // Both should have proper structure
            expect(mdContent).toContain('## üìÑ example.ts');
            expect(htmlContent).toContain('üìÑ example.ts');
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/types.test.ts                                    -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for type definitions and branded types
 */
import { describe, expect, it } from 'vitest';
import { createFilePath, FusionError } from '../src/types.js';
import type { FilePath, FusionErrorCode, FusionErrorSeverity } from '../src/types.js';

describe('Branded Types', () => {
    describe('createFilePath', () => {
        it('should create a valid FilePath from a string', () => {
            const path = createFilePath('/valid/path/to/file.txt');
            expect(path).toBe('/valid/path/to/file.txt');
            expect(typeof path).toBe('string');
        });
        
        it('should throw FusionError for invalid inputs', () => {
            expect(() => createFilePath('')).toThrow(FusionError);
            expect(() => createFilePath('')).toThrow('Invalid file path provided');
            
            // @ts-expect-error Testing invalid input
            expect(() => createFilePath(null)).toThrow(FusionError);
            
            // @ts-expect-error Testing invalid input
            expect(() => createFilePath(undefined)).toThrow(FusionError);
            
            // @ts-expect-error Testing invalid input
            expect(() => createFilePath(123)).toThrow(FusionError);
        });
        
        it('should handle paths with special characters', () => {
            const specialPaths = [
                '/path with spaces/file.txt',
                '/path-with-dashes/file.txt',
                '/path_with_underscores/file.txt',
                '/path/with/unicode/Êñá‰ª∂.txt',
                'C:\\Windows\\System32\\file.txt',
                './relative/path/file.txt',
                '../parent/path/file.txt'
            ];
            
            specialPaths.forEach(p => {
                const filePath = createFilePath(p);
                expect(filePath).toBe(p);
            });
        });
        
        it('should maintain type safety', () => {
            const path = createFilePath('/test/path.txt');
            
            // This should satisfy the FilePath type
            const acceptsFilePath = (fp: FilePath): string => fp;
            expect(acceptsFilePath(path)).toBe('/test/path.txt');
        });
    });
});

describe('FusionError', () => {
    describe('constructor', () => {
        it('should create error with required parameters', () => {
            const error = new FusionError('Test error', 'INVALID_PATH');
            
            expect(error).toBeInstanceOf(Error);
            expect(error).toBeInstanceOf(FusionError);
            expect(error.message).toBe('Test error');
            expect(error.code).toBe('INVALID_PATH');
            expect(error.severity).toBe('error'); // Default severity
            expect(error.name).toBe('FusionError');
            expect(error.context).toBeUndefined();
        });
        
        it('should accept custom severity', () => {
            const errorSeverity = new FusionError('Error', 'INVALID_PATH', 'error');
            const warningSeverity = new FusionError('Warning', 'UNKNOWN_EXTENSION_GROUP', 'warning');
            const infoSeverity = new FusionError('Info', 'INVALID_PATH', 'info');
            
            expect(errorSeverity.severity).toBe('error');
            expect(warningSeverity.severity).toBe('warning');
            expect(infoSeverity.severity).toBe('info');
        });
        
        it('should accept context object', () => {
            const context = {
                path: '/test/file.txt',
                line: 42,
                details: 'Additional information'
            };
            
            const error = new FusionError(
                'Error with context',
                'INVALID_PATH',
                'error',
                context
            );
            
            expect(error.context).toEqual(context);
        });
        
        it('should have proper stack trace', () => {
            const error = new FusionError('Stack test', 'INVALID_PATH');
            
            expect(error.stack).toBeDefined();
            expect(error.stack).toContain('FusionError: Stack test');
            expect(error.stack).toContain('types.test.ts');
        });
    });
    
    describe('Error Codes', () => {
        it('should only accept valid error codes', () => {
            const validCodes: FusionErrorCode[] = [
                'INVALID_PATH',
                'UNKNOWN_EXTENSION_GROUP'
            ];
            
            validCodes.forEach(code => {
                const error = new FusionError('Test', code);
                expect(error.code).toBe(code);
            });
        });
        
        it('should maintain type safety for error codes', () => {
            // This should compile
            const error1 = new FusionError('Test', 'INVALID_PATH');
            const error2 = new FusionError('Test', 'UNKNOWN_EXTENSION_GROUP');
            
            expect(error1.code).toBe('INVALID_PATH');
            expect(error2.code).toBe('UNKNOWN_EXTENSION_GROUP');
            
            // TypeScript should prevent invalid codes at compile time
            // @ts-expect-error Invalid error code
            const invalidError = new FusionError('Test', 'INVALID_CODE');
        });
    });
    
    describe('Error Severity', () => {
        it('should only accept valid severity levels', () => {
            const validSeverities: FusionErrorSeverity[] = [
                'error',
                'warning',
                'info'
            ];
            
            validSeverities.forEach(severity => {
                const error = new FusionError('Test', 'INVALID_PATH', severity);
                expect(error.severity).toBe(severity);
            });
        });
        
        it('should maintain type safety for severity', () => {
            // Valid severities
            const error1 = new FusionError('Test', 'INVALID_PATH', 'error');
            const error2 = new FusionError('Test', 'INVALID_PATH', 'warning');
            const error3 = new FusionError('Test', 'INVALID_PATH', 'info');
            
            expect(error1.severity).toBe('error');
            expect(error2.severity).toBe('warning');
            expect(error3.severity).toBe('info');
            
            // TypeScript should prevent invalid severity at compile time
            // @ts-expect-error Invalid severity
            const invalidError = new FusionError('Test', 'INVALID_PATH', 'critical');
        });
    });
    
    describe('Error Usage Patterns', () => {
        it('should be catchable as FusionError', () => {
            try {
                throw new FusionError('Catchable error', 'INVALID_PATH');
            } catch (error) {
                expect(error).toBeInstanceOf(FusionError);
                if (error instanceof FusionError) {
                    expect(error.code).toBe('INVALID_PATH');
                    expect(error.severity).toBe('error');
                }
            }
        });
        
        it('should be catchable as generic Error', () => {
            try {
                throw new FusionError('Generic error', 'UNKNOWN_EXTENSION_GROUP');
            } catch (error) {
                expect(error).toBeInstanceOf(Error);
                if (error instanceof Error) {
                    expect(error.message).toBe('Generic error');
                }
            }
        });
        
        it('should support error chaining with context', () => {
            const originalError = new Error('Original error');
            
            const fusionError = new FusionError(
                'Wrapped error: ' + originalError.message,
                'INVALID_PATH',
                'error',
                { originalError: originalError.message, timestamp: Date.now() }
            );
            
            expect(fusionError.message).toContain('Original error');
            expect(fusionError.context).toHaveProperty('originalError');
            expect(fusionError.context?.originalError).toBe('Original error');
        });
        
        it('should be serializable', () => {
            const error = new FusionError(
                'Serializable error',
                'INVALID_PATH',
                'warning',
                { data: 'test' }
            );
            
            const serialized = JSON.stringify({
                message: error.message,
                code: error.code,
                severity: error.severity,
                context: error.context
            });
            
            const deserialized = JSON.parse(serialized);
            
            expect(deserialized.message).toBe('Serializable error');
            expect(deserialized.code).toBe('INVALID_PATH');
            expect(deserialized.severity).toBe('warning');
            expect(deserialized.context).toEqual({ data: 'test' });
        });
    });
    
    describe('Integration with createFilePath', () => {
        it('should throw FusionError with correct code', () => {
            try {
                createFilePath('');
            } catch (error) {
                expect(error).toBeInstanceOf(FusionError);
                if (error instanceof FusionError) {
                    expect(error.code).toBe('INVALID_PATH');
                    expect(error.severity).toBe('error');
                    expect(error.message).toBe('Invalid file path provided');
                }
            }
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/utility-types.test.ts                            -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Tests for utility types
 */
import { describe, it, expect } from 'vitest';
import {
    type NonEmptyArray,
    isNonEmptyArray,
    createNonEmptyArray,
    type ExtensionGroupName,
    EXTENSION_GROUPS,
    isValidExtensionGroup,
    getExtensionsForGroup,
    FusionError
} from '../src/types.js';

describe('Utility Types', () => {
    describe('NonEmptyArray', () => {
        it('should correctly identify non-empty arrays', () => {
            expect(isNonEmptyArray([1, 2, 3])).toBe(true);
            expect(isNonEmptyArray(['a'])).toBe(true);
            expect(isNonEmptyArray([])).toBe(false);
        });

        it('should create non-empty arrays from valid arrays', () => {
            const result = createNonEmptyArray([1, 2, 3]);
            expect(result).toEqual([1, 2, 3]);
            
            // TypeScript should infer this as NonEmptyArray<number>
            const first: number = result[0];
            expect(first).toBe(1);
        });

        it('should throw error for empty arrays', () => {
            expect(() => createNonEmptyArray([])).toThrow(FusionError);
            expect(() => createNonEmptyArray([])).toThrow('Array must contain at least one element');
        });

        it('should preserve readonly nature', () => {
            const readonlyArray = [1, 2, 3] as const;
            const result = createNonEmptyArray(readonlyArray);
            
            // Should be assignable to NonEmptyArray
            const typed: NonEmptyArray<number> = result;
            expect(typed[0]).toBe(1);
        });
    });

    describe('ExtensionGroup', () => {
        it('should have correct extension groups defined', () => {
            expect(EXTENSION_GROUPS.web).toContain('.js');
            expect(EXTENSION_GROUPS.web).toContain('.ts');
            expect(EXTENSION_GROUPS.backend).toContain('.py');
            expect(EXTENSION_GROUPS.config).toContain('.json');
            expect(EXTENSION_GROUPS.cpp).toContain('.cpp');
            expect(EXTENSION_GROUPS.scripts).toContain('.sh');
            expect(EXTENSION_GROUPS.godot).toContain('.gd');
            expect(EXTENSION_GROUPS.doc).toContain('.md');
        });

        it('should validate extension group names', () => {
            expect(isValidExtensionGroup('web')).toBe(true);
            expect(isValidExtensionGroup('backend')).toBe(true);
            expect(isValidExtensionGroup('config')).toBe(true);
            expect(isValidExtensionGroup('invalid')).toBe(false);
            expect(isValidExtensionGroup('')).toBe(false);
        });

        it('should get extensions for valid groups', () => {
            const webExtensions = getExtensionsForGroup('web');
            expect(webExtensions).toContain('.js');
            expect(webExtensions).toContain('.ts');
            
            const backendExtensions = getExtensionsForGroup('backend');
            expect(backendExtensions).toContain('.py');
            expect(backendExtensions).toContain('.java');
        });

        it('should have all extensions as non-empty arrays', () => {
            const groupNames: ExtensionGroupName[] = Object.keys(EXTENSION_GROUPS) as ExtensionGroupName[];
            
            for (const groupName of groupNames) {
                const extensions = getExtensionsForGroup(groupName);
                expect(isNonEmptyArray(extensions)).toBe(true);
                expect(extensions.length).toBeGreaterThan(0);
            }
        });

        it('should have extensions starting with dot', () => {
            const groupNames: ExtensionGroupName[] = Object.keys(EXTENSION_GROUPS) as ExtensionGroupName[];
            
            for (const groupName of groupNames) {
                const extensions = getExtensionsForGroup(groupName);
                for (const ext of extensions) {
                    expect(ext.startsWith('.')).toBe(true);
                    expect(ext.length).toBeGreaterThan(1);
                }
            }
        });

        it('should not have duplicate extensions within groups', () => {
            const groupNames: ExtensionGroupName[] = Object.keys(EXTENSION_GROUPS) as ExtensionGroupName[];
            
            for (const groupName of groupNames) {
                const extensions = getExtensionsForGroup(groupName);
                const uniqueExtensions = new Set(extensions);
                expect(uniqueExtensions.size).toBe(extensions.length);
            }
        });

        it('should have extensions in alphabetical order within groups', () => {
            const groupNames: ExtensionGroupName[] = Object.keys(EXTENSION_GROUPS) as ExtensionGroupName[];
            
            for (const groupName of groupNames) {
                const extensions = getExtensionsForGroup(groupName);
                const sortedExtensions = [...extensions].sort();
                expect(extensions).toEqual(sortedExtensions);
            }
        });
    });

    describe('Type Safety', () => {
        it('should prevent invalid extension group access at compile time', () => {
            // This should work fine
            const validGroup: ExtensionGroupName = 'web';
            const extensions = getExtensionsForGroup(validGroup);
            expect(extensions).toBeDefined();
            
            // This would cause a TypeScript error if uncommented:
            // const invalidGroup: ExtensionGroupName = 'invalid';
            // getExtensionsForGroup(invalidGroup);
        });

        it('should enforce non-empty array constraints', () => {
            // This should work
            const validArray: NonEmptyArray<string> = ['.js', '.ts'];
            expect(validArray[0]).toBe('.js');
            
            // This would cause a TypeScript error if uncommented:
            // const invalidArray: NonEmptyArray<string> = [];
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/utils-coverage.test.ts                           -->
<!-- ============================================================ -->
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 the99studio
/**
 * Additional tests to achieve 100% coverage for utils.ts
 */
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { join } from 'node:path';
import { writeFile, mkdir, rm, chmod, readFile } from 'fs-extra';
import { existsSync } from 'node:fs';
import {
    loadConfig,
    writeLog,
    validateSecurePath,
    validateNoSymlinks,
    isBinaryFile,
    getMarkdownLanguage
} from '../src/utils.js';
import { FusionError } from '../src/types.js';

describe('Utils Coverage Tests', () => {
    const testDir = join(process.cwd(), 'temp', 'utils-coverage-test');
    const originalCwd = process.cwd();

    beforeEach(async () => {
        // Clear all mocks before each test
        vi.clearAllMocks();
        
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
        await mkdir(testDir, { recursive: true });
        process.chdir(testDir);
    });

    afterEach(async () => {
        process.chdir(originalCwd);
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    describe('loadConfig error handling', () => {
        it('should handle unknown validation errors', async () => {
            const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
            
            // Create config with invalid JSON structure
            await writeFile('project-fusion.json', '{"schemaVersion": []}');

            const config = await loadConfig();
            
            expect(config).toEqual(expect.objectContaining({
                schemaVersion: 1,
                generatedFileName: 'project-fusioned'
            }));
            
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Configuration validation failed'));
            
            consoleSpy.mockRestore();
        });

    });

    describe('writeLog error handling', () => {
        it('should handle log write errors gracefully', async () => {
            const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
            
            // Try to write to an invalid path
            await writeLog('/invalid/path/that/does/not/exist.log', 'test content');
            
            expect(consoleSpy).toHaveBeenCalledWith('Error writing log:', expect.any(Error));
            
            consoleSpy.mockRestore();
        });
    });


    describe('validateSecurePath error handling', () => {
        it('should detect path traversal attacks', () => {
            expect(() => {
                validateSecurePath('../../../etc/passwd', '/safe/directory');
            }).toThrow(FusionError);
        });

        it('should handle invalid paths', () => {
            expect(() => {
                validateSecurePath('\x00invalid', '/safe/directory');
            }).toThrow(FusionError);
        });

        it('should validate safe paths', () => {
            const safePath = validateSecurePath('./file.txt', process.cwd());
            expect(safePath).toBeDefined();
        });
    });

    describe('validateNoSymlinks', () => {
        it('should handle nonexistent files', async () => {
            const result = await validateNoSymlinks('/nonexistent/file.txt');
            expect(result).toBe(false);
        });

        it('should allow regular files', async () => {
            await writeFile('regular.txt', 'content');
            const result = await validateNoSymlinks('./regular.txt');
            expect(result).toBe(true);
        });
    });

    describe('isBinaryFile edge cases', () => {
        it('should handle empty files', async () => {
            await writeFile('empty.txt', '');
            const result = await isBinaryFile('./empty.txt');
            expect(result).toBe(false);
        });

        it('should detect binary files with null bytes', async () => {
            // Create a file with null bytes
            const binaryContent = Buffer.from([0x00, 0x01, 0x02, 0x03]);
            await writeFile('binary.bin', binaryContent);
            
            const result = await isBinaryFile('./binary.bin');
            expect(result).toBe(true);
        });

        it('should detect files with high ratio of non-printable characters', async () => {
            // Create content with lots of non-printable characters
            const nonPrintableContent = Buffer.from(Array.from({ length: 1000 }, (_, i) => i % 256));
            await writeFile('nonprintable.bin', nonPrintableContent);
            
            const result = await isBinaryFile('./nonprintable.bin');
            expect(result).toBe(true);
        });

        it('should handle file read errors', async () => {
            // File that doesn't exist
            const result = await isBinaryFile('./nonexistent.txt');
            expect(result).toBe(false);
        });

        it('should handle files with undefined bytes gracefully', async () => {
            // This tests the byte checking logic with edge cases
            const content = Buffer.alloc(100);
            content.fill(32); // Fill with spaces (printable)
            await writeFile('spaces.txt', content);
            
            const result = await isBinaryFile('./spaces.txt');
            expect(result).toBe(false);
        });
    });

    describe('getMarkdownLanguage comprehensive mapping', () => {
        it('should handle case sensitivity', () => {
            expect(getMarkdownLanguage('.JS')).toBe('javascript');
            expect(getMarkdownLanguage('.dockerfile')).toBe('dockerfile');
            expect(getMarkdownLanguage('Dockerfile')).toBe('dockerfile');
        });

        it('should handle special file basenames', () => {
            expect(getMarkdownLanguage('Makefile')).toBe('makefile');
            expect(getMarkdownLanguage('Gemfile')).toBe('ruby');
            expect(getMarkdownLanguage('Vagrantfile')).toBe('ruby');
            expect(getMarkdownLanguage('requirements.txt')).toBe('text');
        });

        it('should fall back to text for unknown extensions', () => {
            expect(getMarkdownLanguage('.unknown')).toBe('text');
            expect(getMarkdownLanguage('.weird-extension')).toBe('text');
            expect(getMarkdownLanguage('')).toBe('text');
        });

        it('should handle all supported languages', () => {
            // Test a comprehensive set of languages
            const testCases = [
                ['.py', 'python'],
                ['.rs', 'rust'],
                ['.go', 'go'],
                ['.java', 'java'],
                ['.cpp', 'cpp'],
                ['.c', 'c'],
                ['.h', 'c'],
                ['.hpp', 'cpp'],
                ['.cs', 'csharp'],
                ['.php', 'php'],
                ['.rb', 'ruby'],
                ['.html', 'html'],
                ['.css', 'css'],
                ['.js', 'javascript'],
                ['.ts', 'typescript'],
                ['.jsx', 'jsx'],
                ['.tsx', 'tsx'],
                ['.vue', 'vue'],
                ['.json', 'json'],
                ['.yaml', 'yaml'],
                ['.yml', 'yaml'],
                ['.toml', 'toml'],
                ['.xml', 'xml'],
                ['.md', 'markdown'],
                ['.sh', 'bash'],
                ['.bash', 'bash'],
                ['.ps1', 'powershell'],
                ['.sql', 'sql'],
                ['.gd', 'gdscript']
            ];

            for (const [ext, expected] of testCases) {
                expect(getMarkdownLanguage(ext)).toBe(expected);
            }
        });
    });
});

<!-- ============================================================ -->
<!-- FILE: tests/utils.test.ts                                    -->
<!-- ============================================================ -->
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs-extra';
import path from 'path';
import { 
  getMarkdownLanguage, 
  getExtensionsFromGroups, 
  formatTimestamp,
  formatLocalTimestamp,
  loadConfig,
  writeLog,
  ensureDirectoryExists
} from '../src/utils.js';
import { defaultConfig } from '../src/utils.js';

describe('utils', () => {
  describe('getMarkdownLanguage', () => {
    it('should return correct language for file extensions', () => {
      expect(getMarkdownLanguage('.ts')).toBe('typescript');
      expect(getMarkdownLanguage('.js')).toBe('javascript');
      expect(getMarkdownLanguage('.py')).toBe('python');
      expect(getMarkdownLanguage('.json')).toBe('json');
    });

    it('should return correct language for files without extensions', () => {
      expect(getMarkdownLanguage('Dockerfile')).toBe('dockerfile');
      expect(getMarkdownLanguage('Makefile')).toBe('makefile');
      expect(getMarkdownLanguage('Jenkinsfile')).toBe('groovy');
    });

    it('should return text for unknown extensions', () => {
      expect(getMarkdownLanguage('.unknown')).toBe('text');
      expect(getMarkdownLanguage('UnknownFile')).toBe('text');
    });

    it('should handle case insensitive extensions', () => {
      expect(getMarkdownLanguage('.TS')).toBe('typescript');
      expect(getMarkdownLanguage('.JS')).toBe('javascript');
    });
  });

  describe('getExtensionsFromGroups', () => {
    it('should return all extensions when no groups specified', () => {
      const extensions = getExtensionsFromGroups(defaultConfig);
      expect(extensions.length).toBeGreaterThan(0);
      expect(extensions).toContain('.js');
      expect(extensions).toContain('.py');
      expect(extensions).toContain('.json');
    });

    it('should return extensions for specific groups', () => {
      const extensions = getExtensionsFromGroups(defaultConfig, ['web']);
      expect(extensions).toContain('.js');
      expect(extensions).toContain('.ts');
      expect(extensions).toContain('.html');
      expect(extensions).not.toContain('.py');
    });

    it('should return extensions for multiple groups', () => {
      const extensions = getExtensionsFromGroups(defaultConfig, ['web', 'backend']);
      expect(extensions).toContain('.js');
      expect(extensions).toContain('.py');
      expect(extensions).toContain('.go');
    });

    it('should handle unknown groups gracefully', () => {
      // Should return empty array for unknown groups and log warning
      const result = getExtensionsFromGroups(defaultConfig, ['unknown']);
      expect(result).toEqual([]);
    });
  });

  describe('formatTimestamp', () => {
    it('should format current date when no date provided', () => {
      const timestamp = formatTimestamp();
      expect(timestamp).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/);
    });

    it('should format provided date', () => {
      const date = new Date('2025-01-01T12:00:00.000Z');
      const timestamp = formatTimestamp(date);
      expect(timestamp).toBe('2025-01-01T12:00:00.000Z');
    });
  });

  describe('formatLocalTimestamp', () => {
    it('should format current date when no date provided', () => {
      const timestamp = formatLocalTimestamp();
      expect(timestamp).toMatch(/^\d{2}\/\d{2}\/\d{4} \d{2}:\d{2}:\d{2}/);
    });

    it('should format provided date', () => {
      const date = new Date('2025-01-01T12:00:00.000Z');
      const timestamp = formatLocalTimestamp(date);
      expect(timestamp).toContain('01/01/2025');
    });
  });

  describe('file operations', () => {
    const testDir = path.resolve('./temp/test-utils');
    const testFile = path.join(testDir, 'test.txt');

    beforeEach(async () => {
      await fs.ensureDir(testDir);
    });

    afterEach(async () => {
      await fs.remove(testDir);
    });

    describe('ensureDirectoryExists', () => {
      it('should create directory if it does not exist', async () => {
        const newDir = path.join(testDir, 'new-dir');
        expect(await fs.pathExists(newDir)).toBe(false);
        
        await ensureDirectoryExists(newDir);
        expect(await fs.pathExists(newDir)).toBe(true);
      });

      it('should not fail if directory already exists', async () => {
        await ensureDirectoryExists(testDir);
        // Should not throw
        await ensureDirectoryExists(testDir);
        expect(await fs.pathExists(testDir)).toBe(true);
      });
    });


    describe('writeLog', () => {
      it('should write log content to file', async () => {
        const logFile = path.join(testDir, 'test.log');
        const logContent = 'Log entry';
        
        await writeLog(logFile, logContent);
        expect(await fs.pathExists(logFile)).toBe(true);
        const content = await fs.readFile(logFile, 'utf8');
        expect(content).toBe(logContent + '\n');
      });

      it('should append log content when append is true', async () => {
        const logFile = path.join(testDir, 'test.log');
        const firstEntry = 'First entry';
        const secondEntry = 'Second entry';
        
        await writeLog(logFile, firstEntry);
        await writeLog(logFile, secondEntry, true);
        
        const content = await fs.readFile(logFile, 'utf8');
        expect(content).toBe(firstEntry + '\n' + secondEntry + '\n');
      });

      it('should overwrite log content when append is false', async () => {
        const logFile = path.join(testDir, 'test.log');
        const firstEntry = 'First entry';
        const secondEntry = 'Second entry';
        
        await writeLog(logFile, firstEntry);
        await writeLog(logFile, secondEntry, false);
        
        const content = await fs.readFile(logFile, 'utf8');
        expect(content).toBe(secondEntry + '\n');
      });
    });
  });

  describe('loadConfig', () => {
    const testDir = path.resolve('./temp/test-config');
    const configFile = path.join(testDir, 'project-fusion.json');

    beforeEach(async () => {
      await fs.ensureDir(testDir);
      // Set working directory to test directory
      process.chdir(testDir);
    });

    afterEach(async () => {
      // Restore original working directory
      process.chdir(path.resolve('./../../'));
      await fs.remove(testDir);
    });

    it('should return default config when no config file exists', async () => {
      const config = await loadConfig();
      expect(config).toEqual(defaultConfig);
    });

    it('should load valid config from file', async () => {
      const validConfig = {
        schemaVersion: 1,
        generatedFileName: 'custom-fusion',
        copyToClipboard: true,
        generateText: true,
        generateMarkdown: false,
        generateHtml: true,
        parsedFileExtensions: {
          web: ['.js', '.ts']
        },
        parseSubDirectories: false,
        rootDirectory: '.',
        maxFileSizeKB: 512,
        ignorePatterns: ['*.log'],
        useGitIgnoreForExcludes: false
      };

      await fs.writeJson(configFile, validConfig);
      const config = await loadConfig();
      // Config will be merged with defaults, so just check our specific values
      expect(config.schemaVersion).toBe(validConfig.schemaVersion);
      expect(config.generatedFileName).toBe(validConfig.generatedFileName);
      expect(config.copyToClipboard).toBe(validConfig.copyToClipboard);
      expect(config.generateText).toBe(validConfig.generateText);
      expect(config.generateMarkdown).toBe(validConfig.generateMarkdown);
      expect(config.generateHtml).toBe(validConfig.generateHtml);
      expect(config.parsedFileExtensions.web).toEqual(validConfig.parsedFileExtensions.web);
      expect(config.parseSubDirectories).toBe(validConfig.parseSubDirectories);
      expect(config.rootDirectory).toBe(validConfig.rootDirectory);
      expect(config.maxFileSizeKB).toBe(validConfig.maxFileSizeKB);
      expect(config.ignorePatterns).toEqual(validConfig.ignorePatterns);
      expect(config.useGitIgnoreForExcludes).toBe(validConfig.useGitIgnoreForExcludes);
    });

    it('should return default config for invalid JSON', async () => {
      await fs.writeFile(configFile, 'invalid json {');
      const config = await loadConfig();
      expect(config).toEqual(defaultConfig);
    });

    it('should return default config for invalid schema', async () => {
      const invalidConfig = {
        schemaVersion: 'invalid',
        invalidField: true
      };

      await fs.writeJson(configFile, invalidConfig);
      const config = await loadConfig();
      expect(config).toEqual(defaultConfig);
    });
  });
});

<!-- ============================================================ -->
<!-- FILE: TODO.md                                                -->
<!-- ============================================================ -->
# TODO ‚Äî Project Fusion (Prioritized Review)

> Critical items first, with ‚ù§Ô∏è = strongly agree, ‚ö†Ô∏è = warning/caution, ‚úÖ = done

## üî¥ CRITICAL - Security & Robustness (Do ASAP)

### ‚ù§Ô∏è Resource Limits
- [ ] **Implement maxFiles and maxTotalSizeMB caps**: Essential for monorepos to prevent infinite scans
  - Default: `maxFiles: 10000`, `maxTotalSizeMB: 100`
  - Fail gracefully with helpful message suggesting `--include` patterns
- [ ] **Add memory usage monitoring**: Track and warn when approaching Node.js heap limits

## üü† HIGH - Core Functionality

### ‚ù§Ô∏è Symlink Configuration
- [ ] **Expose allowSymlinks in config**: Currently hardcoded, should be in `project-fusion.json`
  - Add CLI flag `--allow-symlinks` with security warning
  - Document security implications in README

### ‚ö†Ô∏è Ignore Patterns Optimization
- [ ] **Test default ignore patterns**: Validate they don't over-match
- [ ] **WARNING**: Be careful about making defaults too lean. Current patterns are comprehensive for a reason:
  - `*.svg` files often contain useful documentation diagrams
  - Keep current defaults but add `overrideDefaults` option for power users
  - Consider `suggestedIgnores` as additional opt-in patterns

## üü° MEDIUM - Developer Experience

### ‚ù§Ô∏è Package Distribution
- [ ] **Add subpath exports**: Enable targeted imports like `project-fusion/fluent`
  ```json
  "exports": {
    ".": "./dist/index.js",
    "./api": "./dist/api.js",
    "./fluent": "./dist/fluent.js",
    "./plugins": "./dist/plugins/index.js"
  }
  ```

### ‚ù§Ô∏è CLI Enhancements
- [ ] **Output format flags**: `--html`, `--md`, `--txt` (override config)
- [ ] **Naming flags**: `--name <filename>`, `--out <directory>`
- [ ] **Control flags**: `--no-clipboard`, `--groups <csv>`
- [ ] **Preview mode**: `--preview` to list files without generating output
- [ ] **Summary on empty**: Show helpful message when no files match

## üß™ TESTING - Quality Assurance

### ‚ù§Ô∏è End-to-End Testing
- [ ] **CLI E2E test suite**: Spawn actual binary with fixtures
  - Test exit codes, file generation, error messages
  - Test all CLI flags and combinations
  - Validate output file integrity

### ‚ù§Ô∏è Performance Testing
- [ ] **Stress tests**: Generate thousands of files to validate caps
- [ ] **Memory leak tests**: Ensure proper cleanup in watch mode
- [ ] **Benchmark suite**: Track performance regressions

### Security Testing
- [ ] **Fuzzing**: Test with malformed inputs, special characters
- [ ] **Permission tests**: Verify behavior with read-only files/dirs

## üîµ LOW - Nice to Have

### Documentation
- [ ] **Comparison table**: vs Repomix, code2prompt, repo2txt
- [ ] **Security guide**: Best practices for safe usage
- [ ] **API docs**: Generate from TSDoc comments

### HTML Output
- [ ] **Accessibility**: Add ARIA labels, skip links, keyboard navigation
- [ ] **Sticky TOC**: Make sidebar sticky with scroll spy
- [ ] **Line numbers**: Optional toggle for code blocks

### Build & CI
- [ ] **GitHub Action**: Automated test/build/publish workflow
- [ ] **Release automation**: Semantic versioning with conventional commits
- [ ] **Bundle optimization**: Consider tsup/rolldown for faster CLI starts

### Future Features
- [ ] **Watch mode**: Auto-regenerate on file changes
- [ ] **VS Code extension**: Quick preview and generation
- [ ] **Config profiles**: Named presets for different use cases
- [ ] **Plugin marketplace**: Community plugin discovery

---

## Implementation Notes

### Path.relative Implementation (High Priority)
```typescript
export function validateSecurePath(filePath: string, rootDirectory: string): string {
  const resolvedRoot = path.resolve(rootDirectory);
  const resolvedFile = path.resolve(filePath);
  const rel = path.relative(resolvedRoot, resolvedFile);
  
  // More robust than startsWith
  if (rel.startsWith('..') || path.isAbsolute(rel)) {
    throw new FusionError(
      `Path traversal detected: '${filePath}' escapes root directory`,
      'PATH_TRAVERSAL',
      'error',
      { filePath, rootDirectory, resolvedFile, resolvedRoot, rel }
    );
  }
  return resolvedFile;
}
```


<!-- ============================================================ -->
<!-- FILE: tsconfig.json                                          -->
<!-- ============================================================ -->
{
    "compilerOptions": {
        "target": "ES2022",
        "module": "NodeNext",
        "moduleResolution": "NodeNext",
        "esModuleInterop": true,
        "resolveJsonModule": true,
        "strict": true,
        "declaration": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "noUncheckedIndexedAccess": true,
        "exactOptionalPropertyTypes": true,
        "verbatimModuleSyntax": true,
        "useUnknownInCatchVariables": true,
        "noPropertyAccessFromIndexSignature": true,
        "noImplicitReturns": true,
        "moduleDetection": "force",
        "outDir": "./dist",
        "rootDir": "./src"
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "dist"]
}

<!-- ============================================================ -->
<!-- FILE: vitest.config.ts                                       -->
<!-- ============================================================ -->
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      reportsDirectory: './coverage',
      include: ['src/**/*.ts'],
      exclude: [
        'src/**/*.d.ts',
        'src/cli.ts', // CLI entry point - harder to test
        'node_modules/**'
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      }
    }
  },
});

